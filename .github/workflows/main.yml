
# boost (2h ws30)
# cmake (1:30h ws30)
# pyilmbase (1:46 ws30)
name: CI

on:
  workflow_dispatch:
    branches:
      - '*'
  push:
    branches:
      - '*'
  pull_request:
    branches:
      - '*'
  release:
      types: [published]

env:
  DISPLAY: ":99.0"
  TRAVIS: "1" # this triggers -t instead of -ti in docker run
  ARNOLD_LICENSE_ORDER: none # Don't waste time looking for a license that doesn't exist
  BUILD_DIR: "pipeline/build/"
  CACHE_DIR: "pipeline/libs/"
  STUDIO: "pipevfx"
  GITHUB_ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  PREVIOUS_MATRIX_NAME: "phase1"

# concurrency:
#   group: ${{ github.ref_name }}
#   cancel-in-progress: true

jobs:
  build:
    strategy:
      # cancel other jobs in the build matrix if one job fails.
      fail-fast: true
      max-parallel: 1
      matrix:
        name: [
          phase1,
          phase2,
          phase3,
          phase4,
          phase5,
          phase6,
          phase7,
          phase8,
          phase9,
          phase10,
          phase11,
          phase12,
          phase14,
          phase15
        ]

    runs-on: ubuntu-20.04

    steps:
    - name: DockerCache
      uses: actions/cache@v1
      with:
        path: /var/lib/docker/
        key: |
          ${{ env.STUDIO }}-${{ github.ref_name }}-docker
        restore-keys: |
          ${{ env.STUDIO }}-${{ github.ref_name }}-docker

    # we try to speed up things by checking out just once,
    # and caching the phase1 root folder, so we don't have to
    # checkout again.
    - uses: actions/checkout@v2
      if: matrix.name == 'phase1'

    - name: Cache
      uses: actions/cache@v1
      with:
        path: ./
        key: |
          ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}
        restore-keys: |
          ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}

    # and we use artifacts to pass on the built packages from the previous
    # job to the next!
    - uses: actions/download-artifact@v2
      if: matrix.name != 'phase1'
      with:
        name: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ matrix.name  }}-${{ github.sha }}.tar.gz

    - name: Expand the previously saved libs folder so we can continue building...
      if: matrix.name != 'phase1'
      run: |
        ls -l --color=yes ; \
        tar xf ${{ env.STUDIO }}-${{ github.ref_name }}-${{ matrix.name  }}-${{ github.sha }}.tar.gz ; \
        ls -l --color=yes ; \
        ls -l --color=yes pipeline/libs/linux/x86_64/pipevfx.5.0.0/ ; \

    # - name: 'Install Python Modules'
    #   run: pip install PyJWT==1.7.1 PyGitHub==1.45

    - name: Build PipeVFX ${{ matrix.name }}
      run: |
        mkdir -p pipeline/libs/linux/x86_64/pipevfx.5.0.0/ ; \
        ls -l pipeline/libs/linux/x86_64/pipevfx.5.0.0/ ; \
        make build DOCKER=0 PKG=${{ matrix.name }}

    - name: Save out pipeline/libs/ folder as artifact
      run: |
        export NEXT_MATRIX_NAME=$(echo $(expr $(echo ${{ matrix.name }} | sed 's/phase//') + 1) | awk '{print "phase"$1}')
        echo "NEXT_MATRIX_NAME=$NEXT_MATRIX_NAME" >> $GITHUB_ENV
        tar -czf ${{ env.STUDIO }}-${{ github.ref_name }}-$NEXT_MATRIX_NAME-${{ github.sha }}.tar.gz ${{ env.CACHE_DIR }}/

    - uses: actions/upload-artifact@v2
      with:
        name: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ env.NEXT_MATRIX_NAME  }}-${{ github.sha }}.tar.gz
        path: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ env.NEXT_MATRIX_NAME  }}-${{ github.sha }}.tar.gz



  libs_cache:
    needs: build
    if: ${{ always() }}

    runs-on: ubuntu-20.04

    steps:
    - name: Cache
      uses: actions/cache@v1
      with:
        path: ${{ env.CACHE_DIR }}
        key: |
          ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}
        restore-keys: |
          ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}

    - name: Publish Cache
      run: tar -czf ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz ${{ env.CACHE_DIR }}

    - uses: actions/upload-artifact@v2
      with:
        name: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz
        path: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz

  libs_release:
    needs: build

    runs-on: ubuntu-20.04

    steps:
    - name: Cache
      uses: actions/cache@v1
      with:
        path: ${{ env.CACHE_DIR }}
        key: |
          ${{ env.STUDIO }}-${{ github.ref_name }}-${{ env.PREVIOUS_MATRIX_NAME }}-${{ github.sha }}
        restore-keys: |
          ${{ env.STUDIO }}-${{ github.ref_name }}-${{ env.PREVIOUS_MATRIX_NAME }}-${{ github.sha }}

    - name: Publish Cache
      run: tar -czf ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz ${{ env.CACHE_DIR }}/

    - uses: actions/upload-artifact@v2
      with:
        name: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz
        path: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz

    # - name: Validate
    #   run: |
    #     echo "::add-matcher::./.github/workflows/main/problemMatchers/validateRelease.json"
    #     ./config/validateRelease.py --archive ${{ env.GAFFER_BUILD_NAME }}.tar.gz ${{ env.GAFFER_VALIDATE_EXTRA_FLAGS }}
    #     echo "::remove-matcher owner=validateRelease::"
    #   if: matrix.publish

    # - name: Publish Release
    #   run: |
    #     ./config/publishRelease.py --archive ${{ env.GAFFER_BUILD_NAME }}.tar.gz --repo ${{ github.repository }} --releaseId ${{ env.GAFFER_GITHUB_RELEASEID }}
    #   if: matrix.publish && env.GAFFER_GITHUB_RELEASEID != ''
    #   env:
    #     GITHUB_ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # - name: Limit cache size
    #   # GitHub has a limit of 5G for all caches in a repository. Because we write new
    #   # files into `./sconsCache` with every build, we must trim its size to avoid
    #   # unbounded growth. In practice, the archives that get uploaded are much smaller
    #   # than the limit we apply here, because they're compressed.
    #   run: ./.github/workflows/main/limitDirectorySize.py --directory ./sconsCache --megabytes ${{ matrix.sconsCacheMegabytes }} --verbose
