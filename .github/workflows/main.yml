
# boost (2h ws30)
# cmake (1:30h ws30)
# pyilmbase (1:46 ws30)
name: CI

on:
  workflow_dispatch:
    branches:
      - '*'
  push:
    branches:
      - '*'
  pull_request:
    branches:
      - '*'
  release:
      types: [published]

env:
  DISPLAY: ":99.0"
  TRAVIS: "1" # this triggers -t instead of -ti in docker run
  ARNOLD_LICENSE_ORDER: none # Don't waste time looking for a license that doesn't exist
  BUILD_DIR: "pipeline/build/"
  CACHE_DIR: "pipeline/libs/"
  STUDIO: "pipevfx"
  GITHUB_ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}

# concurrency:
#   group: ${{ github.ref_name }}
#   cancel-in-progress: true

jobs:
  matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - id: set-matrix
        run: |
            make matrix | tee output.txt
            matrix=$(cat output.txt | grep name)
            echo $matrix
            echo $matrix | jq .
            echo "::set-output name=matrix::$matrix"

  check-matrix:
    runs-on: ubuntu-latest
    needs: matrix
    steps:
      - name: Install json2yaml
        run: |
          sudo npm install -g json2yaml

      - name: Check matrix definition
        run: |
          matrix='${{ needs.matrix.outputs.matrix }}'
          echo $matrix
          echo $matrix | jq .
          echo $matrix | json2yaml

  build:
    needs: matrix
    strategy:
      # cancel other jobs in the build matrix if one job fails.
      fail-fast: true
      max-parallel: 1
      matrix: ${{fromJson(needs.matrix.outputs.matrix)}}
        # name: [
        #   phase1,
        #   phase2,
        #   phase3,
        #   phase4,
        #   phase5,
        #   phase6,
        #   phase7,
        #   phase8,
        #   phase9,
        #   phase10,
        #   phase11,
        #   phase12
        # ]

    runs-on: ubuntu-latest
    steps:

    # - name: 'Install Python Modules'
    #   run: pip install PyJWT==1.7.1 PyGitHub==1.45

    - uses: actions/checkout@v2
      with:
        fetch-depth: 0

    # - name: retrieve root folder cache
    #   uses: actions/cache@v1
    #   with:
    #     path: ./
    #     key: |
    #       ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}
    #     restore-keys: |
    #       ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}

    # ================================================================================================================
    # restore pipeline/libs from previous run
    # ================================================================================================================
    # and we use artifacts to pass on the built packages from the previous
    # job to the next!
    - name: download artifact from previous run
      uses: actions/download-artifact@v2
      if: matrix.name != 'phase1'
      with:
          name: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ matrix.name  }}-${{ github.sha }}.tar.gz
        # name: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz

    # extract pipeline/libs from the previous uploaded artifact
    - name: expand the previously saved libs folder so we can continue building
      if: matrix.name != 'phase1'
      run: |
        tar xf ${{ env.STUDIO }}-${{ github.ref_name }}-${{ matrix.name  }}-${{ github.sha }}.tar.gz ; \
        ls -lh --color=yes ; \
        ls -lh --color=yes pipeline/libs/linux/x86_64/pipevfx.5.0.0/


    # ================================================================================================================
    # run scons
    # ================================================================================================================
    # build packages
    - name: build PipeVFX ${{ matrix.name }}
      run: |
        mkdir -p pipeline/libs/linux/x86_64/pipevfx.5.0.0/ ; \
        ls -l pipeline/libs/linux/x86_64/pipevfx.5.0.0/ ; \
        make build DOCKER=0 PKG=${{ matrix.name }}

    # ================================================================================================================
    # upload pipeline/libs to an artifact with the next phase name, so we can restore it on the next phase
    # ================================================================================================================
    # after building, we save the pipeline/libs folder as an artifact with the
    # name of the next phase, so the next phase can download and extract!
    - name: save out pipeline/libs/ folder as artifact
      run: |
        export NEXT_MATRIX_NAME=$(echo $(expr $(echo ${{ matrix.name }} | sed 's/phase//') + 1) | awk '{print "phase"$1}') ;\
        echo "NEXT_MATRIX_NAME=$NEXT_MATRIX_NAME" >> $GITHUB_ENV ;\
        tar -czf ${{ env.STUDIO }}-${{ github.ref_name }}-$NEXT_MATRIX_NAME-${{ github.sha }}.tar.gz ${{ env.CACHE_DIR }}/

    # upload next-phase artifact
    - name: upload pipeline/libs as artifact
      uses: actions/upload-artifact@v2
      with:
        name: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ env.NEXT_MATRIX_NAME  }}-${{ github.sha }}.tar.gz
        path: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ env.NEXT_MATRIX_NAME  }}-${{ github.sha }}.tar.gz


    # remove all tar archive files just in case
    - name: Remove archive after upload so it won't be cached
      run: rm -rf ./*.tar*

  # cleanup:
  #   needs: build
  #   if: ${{ always() }}
  #   strategy:
  #     # cancel other jobs in the build matrix if one job fails.
  #     fail-fast: true
  #     max-parallel: 1
  #     matrix:
  #       name: [
  #         phase1,
  #         phase2,
  #         phase3,
  #         phase4,
  #         phase5,
  #         phase6,
  #         phase7,
  #         phase8,
  #         phase9,
  #         phase10,
  #         phase11,
  #         phase12,
  #         phase14,
  #         phase15
  #       ]
  #
  #   runs-on: ubuntu-latest
  #   steps:
  #   - name: Cleanup artifacts we don't need!
  #     uses: geekyeggo/delete-artifact@v1
  #     with:
  #       failOnError: false
  #       name: |
  #         ${{ env.STUDIO }}-${{ github.ref_name }}-${{ matrix.name }}-${{ github.sha }}.tar.gz

  # libs_cache:
  #   needs: build
  #   if: ${{ always() }}
  #
  #   runs-on: ubuntu-latest
  #
  #   steps:
  #   - name: Cache
  #     uses: actions/cache@v1
  #     with:
  #       path: ${{ env.CACHE_DIR }}
  #       key: |
  #         ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}
  #       restore-keys: |
  #         ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}
  #
  #   - name: Publish Cache
  #     run: tar -czf ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz /pipeline/libs/
  #
  #   - uses: actions/upload-artifact@v2
  #     with:
  #       name: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz
  #       path: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz
  #
  # libs_release:
  #   needs: build
  #
  #   runs-on: ubuntu-latest
  #
  #   steps:
  #   - name: Cache
  #     uses: actions/cache@v1
  #     with:
  #       path: ${{ env.CACHE_DIR }}
  #       key: |
  #         ${{ env.STUDIO }}-${{ github.ref_name }}-${{ env.PREVIOUS_MATRIX_NAME }}-${{ github.sha }}
  #       restore-keys: |
  #         ${{ env.STUDIO }}-${{ github.ref_name }}-${{ env.PREVIOUS_MATRIX_NAME }}-${{ github.sha }}
  #
  #   - name: Publish Cache
  #     run: tar -czf ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz ${{ env.CACHE_DIR }}/
  #
  #   - uses: actions/upload-artifact@v2
  #     with:
  #       name: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz
  #       path: ${{ env.STUDIO }}-${{ github.ref_name }}-${{ github.sha }}.tar.gz
