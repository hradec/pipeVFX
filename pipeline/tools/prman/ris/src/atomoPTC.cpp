/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2016 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

/* $Revision: #4 $ */

#include "RixPattern.h"
#include "RixShadingUtils.h"


#include "IECore.h"
#include "PointsPrimitive.h"
#include "PointsPrimitiveEvaluator.h"

class PxrChecker : public RixPattern
{
    enum ParamIds
    {
        /* outputs */
        k_resultRGB = 0,
        k_resultR,
        k_resultG,
        k_resultB,
        /* inputs */
        k_colorA,
        k_colorB,
        k_manifold,
        k_manifoldQ,
        k_manifoldQradius,
        k_manifoldEnd,
        /* end of table */
        k_numParams,
    };

public:
    IECore::PointsPrimitive * ptc;

    virtual int Init(RixContext &ctx, char const *pluginPath);
    virtual void Finalize(RixContext &ctx);
    virtual RixSCParamInfo const *GetParamTable();
    virtual int ComputeOutputParams(RixShadingContext const *sCtx,
                                    int *nOutputs,
                                    OutputSpec **outputs,
                                    RtConstPointer dataPtr,
                                    RixSCParamInfo const *instanceTable);
};

int
PxrChecker::Init(RixContext &ctx, char const *pluginPath)
{

	// get points
    IECore::FloatVectorData *zr  = new IECore::FloatVectorData();
    IECore::FloatVectorData *zid = new IECore::FloatVectorData();
    IECore::V3fVectorData   * p  = new IECore::V3fVectorData();
    IECore::V3fVectorData   * n  = new IECore::V3fVectorData();
    IECore::V3fVectorData   * c  = new IECore::V3fVectorData();
    FILE *f = fopen("/tmp/zz.ptc", "r");
    char line[512];
    float r, px, py, pz, nx,ny,nz, cr,cg,cb, id;
    while( ! feof(f) ){
        // fgets(line, 256, f);

        int ret = fscanf(f, "[%g,[%g,%g,%g],[%g,%g,%g,],[%g,%g,%g],%g]\n", &r, &px, &py, &pz, &nx,&ny,&nz, &cr,&cg,&cb, &id);
        if(ret>0){
            p->writable().push_back( Imath::V3f( px, py, pz) );
            n->writable().push_back( Imath::V3f( nx, ny, nz) );
            c->writable().push_back( Imath::V3f( cr, cg, cb) );
            zr->writable().push_back( r );
            zid->writable().push_back( id );
        }


    }


	// if( const DD::Image::PointList *pl = m_geo->point_list() )
	// {
	// 	p->writable().resize( pl->size() );
	// 	std::transform( pl->begin(), pl->end(), p->writable().begin(), IECore::convert<Imath::V3f, DD::Image::Vector3> );
	// }
    ptc = new IECore::PointsPrimitive( p );
    ptc->variables["N"] =  IECore::PrimitiveVariable( IECore::PrimitiveVariable::Varying, n->copy() );
    ptc->variables["Cs"] =  IECore::PrimitiveVariable( IECore::PrimitiveVariable::Varying, c->copy() );
    ptc->variables["width"] =  IECore::PrimitiveVariable( IECore::PrimitiveVariable::Varying, zr->copy() );
    ptc->variables["id"] =  IECore::PrimitiveVariable( IECore::PrimitiveVariable::Varying, zid->copy() );

    return 0;
}

void
PxrChecker::Finalize(RixContext &ctx)
{
}

RixSCParamInfo const *
PxrChecker::GetParamTable()
{
    static RixSCParamInfo s_ptable[] =
    {
        /* outputs */
        RixSCParamInfo("resultRGB", k_RixSCColor, k_RixSCOutput),
        RixSCParamInfo("resultR", k_RixSCFloat, k_RixSCOutput),
        RixSCParamInfo("resultG", k_RixSCFloat, k_RixSCOutput),
        RixSCParamInfo("resultB", k_RixSCFloat, k_RixSCOutput),
        /* inputs */
        RixSCParamInfo("colorA", k_RixSCColor),
        RixSCParamInfo("colorB", k_RixSCColor),
        RixSCParamInfo("PxrManifold", "manifold", k_RixSCStructBegin),
        RixSCParamInfo("Q", k_RixSCPoint),
        RixSCParamInfo("Qradius", k_RixSCFloat),
        RixSCParamInfo("PxrManifold", "manifold", k_RixSCStructEnd),
        /* end of table */
        RixSCParamInfo()
    };
    return &s_ptable[0];
}

int
PxrChecker::ComputeOutputParams(RixShadingContext const *sCtx,
                                int *nOutputs,
                                OutputSpec **outputs,
                                RtConstPointer dataPtr,
                                RixSCParamInfo const *instanceTable)
{
    using std::fmod;
    using std::fabs;
    using std::min;

    RixSCType type;
    RixSCConnectionInfo cinfo;
    RixSCParamInfo const* paramTable = GetParamTable();
    int numOutputs = -1;
    while (paramTable[++numOutputs].access == k_RixSCOutput) {}

    RixShadingContext::Allocator pool(sCtx);
    OutputSpec *out = *outputs = pool.AllocForPattern<OutputSpec>(numOutputs);
    *nOutputs = numOutputs;

    // looping through the different output ids
    for (int i = 0; i < numOutputs; ++i)
    {
        out[i].paramId = i;
        out[i].detail = k_RixSCInvalidDetail;
        out[i].value = NULL;
        type = paramTable[i].type;    // we know this

        sCtx->GetParamInfo(i, &type, &cinfo);
        if(cinfo == k_RixSCNetworkValue)
        {
            if( type == k_RixSCColor )
            {
                out[i].detail = k_RixSCVarying;
                out[i].value = pool.AllocForPattern<RtColorRGB>(sCtx->numPts);
            }
            else if( type == k_RixSCFloat )
            {
                out[i].detail = k_RixSCVarying;
                out[i].value = pool.AllocForPattern<float>(sCtx->numPts);
            }
        }
    }

    RtColorRGB *resultRGB = (RtColorRGB*) out[k_resultRGB].value;
    // make sure the resultRGB space is allocated because it
    // will store the composite color results.
    if (!resultRGB) resultRGB = pool.AllocForPattern<RtColorRGB>(sCtx->numPts);
    float *resultR = (float*) out[k_resultR].value;
    float *resultG = (float*) out[k_resultG].value;
    float *resultB = (float*) out[k_resultB].value;

    // Allocate space for our remapped s,t
    RtFloat2 *stOut = pool.AllocForPattern<RtFloat2>(sCtx->numPts);
    float const *stRadius;

    // check for manifold input
    sCtx->GetParamInfo(k_manifold, &type, &cinfo);
    if (cinfo != k_RixSCNetworkValue) {
        RtFloat2 const *stIn;
        RtFloat2 const defaultST(0.0f, 0.0f);
        sCtx->GetPrimVar("st", defaultST, &stIn, &stRadius);
        for (int i = 0; i < sCtx->numPts; ++i)
        {
            stOut[i].x = stIn[i].x;
            stOut[i].y = stIn[i].y;
        }
    } else {
        RtPoint3 const *Q;
        sCtx->EvalParam(k_manifoldQ, -1, &Q);
        sCtx->EvalParam(k_manifoldQradius, -1, &stRadius);
        for (int i = 0; i < sCtx->numPts; ++i)
        {
            stOut[i].x = Q[i].x;
            stOut[i].y = Q[i].y;
        }
    }

    RtColorRGB const *colorA, *colorB;
    sCtx->EvalParam(k_colorA, -1, &colorA, &RixConstants::k_OneRGB, true);
    sCtx->EvalParam(k_colorB, -1, &colorB, &RixConstants::k_ZeroRGB, true);

    for (int i = 0; i < sCtx->numPts; ++i)
    {
        float const smod = stOut[i].x - floorf(stOut[i].x);
        float const tmod = stOut[i].y - floorf(stOut[i].y);
        float srad = 0.25f - fabs(fabs(smod - 0.5f) - 0.25f);
        float trad = 0.25f - fabs(fabs(tmod - 0.5f) - 0.25f);
        float rad = min(srad, trad) / stRadius[i];
        float step = RixSmoothStep(-1.0f, 1.0f, rad);
        if ((smod < 0.5f) == (tmod < 0.5f)) {
            resultRGB[i] = RixLerpRGB(colorA[i], colorB[i], step);
        } else {
            resultRGB[i] = RixLerpRGB(colorB[i], colorA[i], step);
        }
        if (resultR) resultR[i] = resultRGB[i].r;
        if (resultG) resultG[i] = resultRGB[i].g;
        if (resultB) resultB[i] = resultRGB[i].b;
    }

    return 0;
}

RIX_PATTERNCREATE
{
    return new PxrChecker();
}

RIX_PATTERNDESTROY
{
    delete static_cast<PxrChecker*>(pattern);
}
