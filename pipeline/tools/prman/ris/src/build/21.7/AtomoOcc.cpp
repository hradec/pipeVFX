/* $Date: 2015/01/08 $  $Revision: #12 $
# ------------------------------------------------------------------------------
#
# Copyright (c) 2015 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include "RixPattern.h"
#include "RixIntegrator.h"

#include <iostream>

/**
 * This utility pattern takes either an input parameter and passes it
 * through unchanged to its result.  As a side effect, it will send the
 * values out into an AOV if when shading a camera-visible primary ray:
 *
 * inputF -----> + -----> resultF      inputRGB -----> + -----> resultRGB
 *               |                                     |
 *               v                -or-                 v
 *           float AOV                             color AOV
 *
 * Note that either inputF and resultF should be connected, or inputRGB and
 * resultRGB, but not both, and the type of the AOV should also match.
 */

class AtomoOCC : public RixPattern
{
public:

    AtomoOCC();
    virtual ~AtomoOCC();
    int nrays;
    RtRayGeometry *rays;
    RtHitPoint *hits;

    virtual int Init(
        RixContext &ctx,
        char const *pluginPath );
    virtual RixSCParamInfo const *GetParamTable();
    virtual void Finalize(
        RixContext &ctx );
    virtual int CreateInstanceData(
        RixContext &ctx,
        char const *handle,
        RixParameterList const *parms,
        InstanceData *instance );
    virtual int ComputeOutputParams(
        RixShadingContext const *sCtx,
        RtInt *nOutputs,
        OutputSpec **outputs,
        RtConstPointer instanceData,
        RixSCParamInfo const * /*instanceTable*/ );

};

AtomoOCC::AtomoOCC()
{
    nrays=16;
    rays = new RtRayGeometry[nrays];
    hits = new RtHitPoint[nrays];

}

AtomoOCC::~AtomoOCC()
{
    delete[] rays;
    delete[] hits;
}

int AtomoOCC::Init( RixContext &ctx, char const *pluginPath )
{
    return 0;
}

enum paramID
{
    k_resultRGB = 0,
    k_resultF,
    k_inputRGB,
    k_inputPassTrough,
    k_inputF,
    k_aov,
    k_numParams
};

RixSCParamInfo const *AtomoOCC::GetParamTable()
{
    static RixSCParamInfo s_table[] =
    {
        // Outputs.
        RixSCParamInfo( "resultRGB", k_RixSCColor, k_RixSCOutput ),
        RixSCParamInfo( "resultF", k_RixSCFloat, k_RixSCOutput ),

        // Inputs.
        RixSCParamInfo( "inputRGB", k_RixSCColor ),
        RixSCParamInfo( "inputPassTrough", k_RixSCColor ),
        RixSCParamInfo( "inputF",  k_RixSCFloat ),
        RixSCParamInfo( "aov",  k_RixSCString ),

        // End of table
        RixSCParamInfo()
    };
    return s_table;
}

void AtomoOCC::Finalize(
    RixContext &ctx )
{
}

int AtomoOCC::CreateInstanceData(
    RixContext &ctx,
    char const *handle,
    RixParameterList const *parms,
    InstanceData *instance )
{

    RixRenderState *state = reinterpret_cast< RixRenderState * >( ctx.GetRixInterface( k_RixRenderState ) );
    RixMessages *msg      =    reinterpret_cast< RixMessages * >( ctx.GetRixInterface( k_RixMessages    ) );

    RixRenderState::FrameInfo frame;
    state->GetFrameInfo( &frame );
    RixIntegratorEnvironment const *env = reinterpret_cast< RixIntegratorEnvironment const * >( frame.integratorEnv );


    RtInt paramId;
    RixSCType typ;
    RixSCConnectionInfo cnx;

    bool hasInputPassTrough = !parms->GetParamId( "inputPassTrough", &paramId );
    if (hasInputPassTrough)
    {
        parms->GetParamInfo(k_inputPassTrough, &typ, &cnx);
        hasInputPassTrough = (cnx == k_RixSCNetworkValue);
    }
    bool hasInputRGB = !parms->GetParamId( "inputRGB", &paramId );
    if (hasInputRGB)
    {
        parms->GetParamInfo(k_inputRGB, &typ, &cnx);
        hasInputRGB = (cnx == k_RixSCNetworkValue);
    }
    bool hasInputF = !parms->GetParamId( "inputF", &paramId );
    if (hasInputF)
    {
        parms->GetParamInfo(k_inputF, &typ, &cnx);
        hasInputF = (cnx == k_RixSCNetworkValue);
    }

    // if ( !( hasInputRGB ^ hasInputF ) )
    // {
    //     msg->Error( "AtomoOCC needs exactly one of inputF or inputRGB (%s).", handle );
    //     return -1;
    // }

    RtConstString aov;
    if ( parms->GetParamId( "aov", &paramId ) )
    {
        msg->Warning( "AtomoOCC was not given an AOV (%s).", handle );
        return -1;
    }
    parms->EvalParam( paramId, 0, &aov );

    for ( int index = 0; index < env->numDisplays; ++index )
    {
        if ( strcmp( env->displays[ index ].channel, aov ) )
            continue;
        bool isSingle =
            env->displays[ index ].type == RixDisplayChannel::k_FloatChannel ||
            env->displays[ index ].type == RixDisplayChannel::k_IdChannel;
        if ( ( hasInputRGB && isSingle ) || ( hasInputF && !isSingle ) )
        {
            msg->Warning( "AtomoOCC has mismatched input and AOV types (%s).", handle );
            return -1;
        }
        instance->datalen = sizeof( RixChannelId );
        instance->data = malloc( instance->datalen );
        instance->freefunc = free;
        *reinterpret_cast< RixChannelId * >( instance->data ) = env->displays[ index ].id;
    }
    if ( !instance->data )
    {
        msg->Warning( "AtomoOCC did not find a display for AOV '%s' (%s).", aov, handle );
        return -1;
    }

    return 0;
}

static RtColorRGB const s_defaultRGB( 0.0f, 0.0f, 0.0f );
static RtFloat const s_defaultF( 0.0f );

int AtomoOCC::ComputeOutputParams(
    RixShadingContext const *sCtx,
    RtInt *nOutputs,
    OutputSpec **outputs,
    RtConstPointer instanceData,
    RixSCParamInfo const * /*instanceTable*/ )
{
    RixSCType type;
    RixSCConnectionInfo cInfo;
    char const *subset=NULL;
    RixDisplayServices *dspySvc = sCtx->GetDisplayServices();
    sCtx->GetParamInfo( k_inputRGB, &type, &cInfo );
    if ( cInfo != k_RixSCDefaultValue )
    {

        RtColorRGB const *input;
        sCtx->EvalParam( k_inputRGB, -1, &input, &s_defaultRGB, true );

        RtColorRGB const *inputPass;
        sCtx->EvalParam( k_inputPassTrough, -1, &inputPass, &s_defaultRGB, true );



        RixShadingContext::Allocator pool( sCtx );
        OutputSpec *spec = pool.AllocForPattern< OutputSpec >( 2 );
        RtColorRGB *result = pool.AllocForPattern< RtColorRGB >( sCtx->numPts );
        spec[ 0 ].paramId = k_resultRGB;
        spec[ 0 ].detail = k_RixSCVarying;
        spec[ 0 ].value = result;
        spec[ 1 ].paramId = k_resultF;
        spec[ 1 ].detail = k_RixSCUniform;
        spec[ 1 ].value = &s_defaultF;
        *nOutputs = 2;
        *outputs = spec;

        // RtColorRGB *resultO = pool.AllocForPattern< RtColorRGB >( sCtx->numPts );
        // sCtx->GetOpacity()->GetOpacity(resultO);

        if ( sCtx->scTraits.primaryHit && instanceData ){



            for ( int index = 0; index < sCtx->numPts; ++index )
            {

                std::cout << "BUMM1\n";
                std::cout.flush();
                RtNormal3 const *Ngn;
                sCtx->GetBuiltinVar(RixShadingContext::k_Ngn, &Ngn);
                for( int n=0; n<nrays; n++ ){
                    rays[n].InitOrigination( sCtx, Ngn, index );
                }

                sCtx->GetNearestHits (nrays, rays, hits, subset, k_SidesBoth);
                std::cout << "BUMM2\n";

                float occ = 0;
                for( int n=0; n<nrays; n++ ){
                    if(hits[n].dist == 0) occ++;
                }
                occ /= float(nrays);
                occ = occ;
                std::cout << "BUMM3\n";



                result[ index ] = inputPass[ index ]*occ;



                dspySvc->Write(
                    *reinterpret_cast< RixChannelId const * >( instanceData ),
                    sCtx->integratorCtxIndex[ index ],
                    input[ index ]*occ  );
            }
        }
        else
            for ( int index = 0; index < sCtx->numPts; ++index )
                result[ index ] = inputPass[ index ];

    }
    else
    {

        RtFloat const *input;
        sCtx->EvalParam( k_inputF, -1, &input, &s_defaultF, true );

        RixShadingContext::Allocator pool( sCtx );
        OutputSpec *spec = pool.AllocForPattern< OutputSpec >( 2 );
        RtFloat *result = pool.AllocForPattern< RtFloat >( sCtx->numPts );
        spec[ 0 ].paramId = k_resultF;
        spec[ 0 ].detail = k_RixSCVarying;
        spec[ 0 ].value = result;
        spec[ 1 ].paramId = k_resultRGB;
        spec[ 1 ].detail = k_RixSCUniform;
        spec[ 1 ].value = &s_defaultRGB;
        *nOutputs = 2;
        *outputs = spec;

        if ( sCtx->scTraits.primaryHit && instanceData )
        {
            RixDisplayServices *dspySvc = sCtx->GetDisplayServices();
            for ( int index = 0; index < sCtx->numPts; ++index )
            {
                result[ index ] = input[ index ];
                dspySvc->Write(
                    *reinterpret_cast< RixChannelId const * >( instanceData ),
                    sCtx->integratorCtxIndex[ index ],
                    input[ index ] );
            }
        }
        else
            for ( int index = 0; index < sCtx->numPts; ++index )
                result[ index ] = input[ index ];

    }

    return 0;
}

RIX_PATTERNCREATE
{
    return new AtomoOCC();
}

RIX_PATTERNDESTROY
{
    delete reinterpret_cast< AtomoOCC * >( pattern );
}
