/* $Date: 2015/01/08 $  $Revision: #12 $
# ------------------------------------------------------------------------------
#
# Copyright (c) 2015 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include "RixPattern.h"
#include "RixIntegrator.h"
#include "RixShading.h"


#if _PRMANAPI_VERSION_MAJOR_ < 22
    #define RtUString(x) x
#else
    #define k_IdChannel k_IntegerChannel
    #define RtConstPointer RtPointer
#endif


/**
 * This utility pattern takes either an input parameter and passes it
 * through unchanged to its result.  As a side effect, it will send the
 * values out into an AOV if when shading a camera-visible primary ray:
 *
 * inputF -----> + -----> resultF      inputRGB -----> + -----> resultRGB
 *               |                                     |
 *               v                -or-                 v
 *           float AOV                             color AOV
 *
 * Note that either inputF and resultF should be connected, or inputRGB and
 * resultRGB, but not both, and the type of the AOV should also match.
 */

class AtomoAOV : public RixPattern
{
public:

    AtomoAOV();
    virtual ~AtomoAOV();

#if _PRMANAPI_VERSION_MAJOR_ < 22
    virtual int Init( RixContext &ctx, char const *pluginPath ){return 0;};
    virtual int CreateInstanceData( RixContext &ctx, char const *handle,
        RixParameterList const *parms, InstanceData *instance );
#else
    virtual int Init( RixContext &ctx, RtUString const pluginPath ){return 0;};
    virtual int CreateInstanceData( RixContext &ctx,  RtUString const handle,
        RixParameterList const *parms, InstanceData *instance );
#endif
    virtual RixSCParamInfo const *GetParamTable();
    virtual void Finalize( RixContext &ctx );
    virtual void Synchronize( RixContext&, RixSCSyncMsg,
        RixParameterList const*) { }
    virtual int ComputeOutputParams( RixShadingContext const *sCtx,
        RtInt *nOutputs, OutputSpec **outputs, RtConstPointer instanceData,
        RixSCParamInfo const * /*instanceTable*/ );

#if _PRMANAPI_VERSION_MAJOR_ > 20
    virtual bool Bake2dOutput(
         RixBakeContext const*,
         Bake2dSpec&,
         RtPointer)
     {
         return false;
     }

     virtual bool Bake3dOutput(
         RixBakeContext const*,
         Bake3dSpec&,
         RtPointer)
     {
         return false;
     }
#endif

};

AtomoAOV::AtomoAOV()
{
}

AtomoAOV::~AtomoAOV()
{
}


enum paramID
{
    k_resultRGB = 0,
    k_resultF,
    k_inputRGB,
    k_inputPassTrough,
    k_inputF,
    k_aov,
    k_numParams
};

RixSCParamInfo const *AtomoAOV::GetParamTable()
{
    static RixSCParamInfo s_table[] =
    {
        // Outputs.
        RixSCParamInfo( RtUString("resultRGB"), k_RixSCColor, k_RixSCOutput ),
        RixSCParamInfo( RtUString("resultF")  , k_RixSCFloat, k_RixSCOutput ),

        // Inputs.
        RixSCParamInfo( RtUString("inputRGB"), k_RixSCColor ),
        RixSCParamInfo( RtUString("inputPassTrough"), k_RixSCColor ),
        RixSCParamInfo( RtUString("inputF"),  k_RixSCFloat ),
        RixSCParamInfo( RtUString("aov"),  k_RixSCString ),

        // End of table
        RixSCParamInfo()
    };
    return s_table;
}

void AtomoAOV::Finalize(
    RixContext &ctx )
{
}

#if _PRMANAPI_VERSION_MAJOR_ < 22
int AtomoAOV::CreateInstanceData(
    RixContext &ctx,
    char const *handle,
    RixParameterList const *parms,
    InstanceData *instance )
#else
int AtomoAOV::CreateInstanceData(
    RixContext &ctx,
    RtUString const handle,
    RixParameterList const *parms,
    InstanceData *instance )
#endif
{

    RixRenderState *state = reinterpret_cast< RixRenderState * >( ctx.GetRixInterface( k_RixRenderState ) );
    RixMessages *msg      =    reinterpret_cast< RixMessages * >( ctx.GetRixInterface( k_RixMessages    ) );

    RixRenderState::FrameInfo frame;
    state->GetFrameInfo( &frame );
    RixIntegratorEnvironment const *env = reinterpret_cast< RixIntegratorEnvironment const * >( frame.integratorEnv );


    RtInt paramId;
    RixSCType typ;
    RixSCConnectionInfo cnx;

    bool hasInputPassTrough = !parms->GetParamId( RtUString("inputPassTrough"), &paramId );
    if (hasInputPassTrough)
    {
        parms->GetParamInfo(k_inputPassTrough, &typ, &cnx);
        hasInputPassTrough = (cnx == k_RixSCNetworkValue);
    }
    bool hasInputRGB = !parms->GetParamId( RtUString("inputRGB"), &paramId );
    if (hasInputRGB)
    {
        parms->GetParamInfo(k_inputRGB, &typ, &cnx);
        hasInputRGB = (cnx == k_RixSCNetworkValue);
    }
    bool hasInputF = !parms->GetParamId( RtUString("inputF"), &paramId );
    if (hasInputF)
    {
        parms->GetParamInfo(k_inputF, &typ, &cnx);
        hasInputF = (cnx == k_RixSCNetworkValue);
    }

    // if ( !( hasInputRGB ^ hasInputF ) )
    // {
    //     msg->Error( "AtomoAOV needs exactly one of inputF or inputRGB (%s).", handle );
    //     return -1;
    // }

    RtConstString aov;
    if ( parms->GetParamId( RtUString("aov"), &paramId ) )
    {
        msg->Warning( "AtomoAOV was not given an AOV (%s).", handle );
        return -1;
    }
#if _PRMANAPI_VERSION_MAJOR_ < 22
        parms->EvalParam( paramId, 0, &aov );
#else
        RtUString _aov = RtUString();
        parms->EvalParam( paramId, 0, &_aov );
        aov = _aov.CStr();
#endif

    for ( int index = 0; index < env->numDisplays; ++index )
    {
#if _PRMANAPI_VERSION_MAJOR_ < 22
        if ( strcmp( env->displays[ index ].channel, aov ) )
            continue;
#else
        if ( env->displays[ index ].channel != _aov )
            continue;
#endif
        bool isSingle =
            env->displays[ index ].type == RixDisplayChannel::k_FloatChannel ||
            env->displays[ index ].type == RixDisplayChannel::k_IdChannel;
        if ( ( hasInputRGB && isSingle ) || ( hasInputF && !isSingle ) )
        {
            msg->Warning( "AtomoAOV has mismatched input and AOV types (%s).", handle );
            return -1;
        }
        instance->datalen = sizeof( RixChannelId );
        instance->data = malloc( instance->datalen );
        instance->freefunc = free;
        *reinterpret_cast< RixChannelId * >( instance->data ) = env->displays[ index ].id;
    }
    if ( !instance->data )
    {
        msg->Warning( "AtomoAOV did not find a display for AOV '%s' (%s).", aov, handle );
        return -1;
    }

    return 0;
}

static RtColorRGB const s_defaultRGB( 0.0f, 0.0f, 0.0f );
static RtFloat const s_defaultF( 0.0f );

int AtomoAOV::ComputeOutputParams(
    RixShadingContext const *sCtx,
    RtInt *nOutputs,
    OutputSpec **outputs,
    RtConstPointer instanceData,
    RixSCParamInfo const * /*instanceTable*/ )
{
    RixSCType type;
    RixSCConnectionInfo cInfo;
    sCtx->GetParamInfo( k_inputRGB, &type, &cInfo );
    if ( cInfo != k_RixSCDefaultValue )
    {

        RtColorRGB const *input;
        sCtx->EvalParam( k_inputRGB, -1, &input, &s_defaultRGB, true );

        RtColorRGB const *inputPass;
        sCtx->EvalParam( k_inputPassTrough, -1, &inputPass, &s_defaultRGB, true );


        RixShadingContext::Allocator pool( sCtx );
        OutputSpec *spec = pool.AllocForPattern< OutputSpec >( 2 );
        RtColorRGB *result = pool.AllocForPattern< RtColorRGB >( sCtx->numPts );
        spec[ 0 ].paramId = k_resultRGB;
        spec[ 0 ].detail = k_RixSCVarying;
        spec[ 0 ].value = result;
        spec[ 1 ].paramId = k_resultF;
        spec[ 1 ].detail = k_RixSCUniform;
        spec[ 1 ].value = &s_defaultF;
        *nOutputs = 2;
        *outputs = spec;

        // RtColorRGB *resultO = pool.AllocForPattern< RtColorRGB >( sCtx->numPts );
        // sCtx->GetOpacity()->GetOpacity(resultO);

        if ( sCtx->scTraits.primaryHit && instanceData )
        {
            RixDisplayServices *dspySvc = sCtx->GetDisplayServices();
            for ( int index = 0; index < sCtx->numPts; ++index )
            {
                result[ index ] = inputPass[ index ];



                dspySvc->Splat(
                    *reinterpret_cast< RixChannelId const * >( instanceData ),
                    sCtx->integratorCtxIndex[ index ],
                    input[ index ]  );
            }
        }
        else
            for ( int index = 0; index < sCtx->numPts; ++index )
                result[ index ] = inputPass[ index ];

    }
    else
    {

        RtFloat const *input;
        sCtx->EvalParam( k_inputF, -1, &input, &s_defaultF, true );

        RixShadingContext::Allocator pool( sCtx );
        OutputSpec *spec = pool.AllocForPattern< OutputSpec >( 2 );
        RtFloat *result = pool.AllocForPattern< RtFloat >( sCtx->numPts );
        spec[ 0 ].paramId = k_resultF;
        spec[ 0 ].detail = k_RixSCVarying;
        spec[ 0 ].value = result;
        spec[ 1 ].paramId = k_resultRGB;
        spec[ 1 ].detail = k_RixSCUniform;
        spec[ 1 ].value = &s_defaultRGB;
        *nOutputs = 2;
        *outputs = spec;

        if ( sCtx->scTraits.primaryHit && instanceData )
        {
            RixDisplayServices *dspySvc = sCtx->GetDisplayServices();
            for ( int index = 0; index < sCtx->numPts; ++index )
            {
                result[ index ] = input[ index ];
                dspySvc->Splat(
                    *reinterpret_cast< RixChannelId const * >( instanceData ),
                    sCtx->integratorCtxIndex[ index ],
                    input[ index ] );
            }
        }
        else
            for ( int index = 0; index < sCtx->numPts; ++index )
                result[ index ] = input[ index ];

    }

    return 0;
}

RIX_PATTERNCREATE
{
    return new AtomoAOV();
}

RIX_PATTERNDESTROY
{
    delete reinterpret_cast< AtomoAOV * >( pattern );
}
