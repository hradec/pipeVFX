/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2016 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/


/*
We need this in the rib to render everything when baking


  Attribute "cull" "hidden" 0   # don't cull hidden surfaces
  Attribute "cull" "backfacing" 0   # don't cull backfacing surfaces
  Attribute "dice" "rasterorient" 0   # view-independent dicing !
*/

/* $Revision: #4 $ */

#include "RixSampleFilter.h"

#include "pointcloud.h"

#include "OpenEXR/ImathVec.h"
#include "IECore.h"
#include "Writer.h"
#include "PointsPrimitive.h"
#include "PointsPrimitiveEvaluator.h"


class PxrBakeSampleFilter : public RixSampleFilter
{

public:
    PxrBakeSampleFilter();
    virtual ~PxrBakeSampleFilter();
    virtual int Init(RixContext &ctx, char const *pluginPath);
    virtual RixSCParamInfo const *GetParamTable();
    virtual void Finalize(RixContext &ctx);

    virtual int CreateInstanceData(RixContext &ctx, char const *handle,
                                   RixParameterList const *parms,
                                   InstanceData *instance);

    virtual void Filter(RixSampleFilterContext &fCtx,
                        RtConstPointer instance);

    struct sampleParams
    {
        RtColorRGB blackPoint;
        RtColorRGB whitePoint;
        RtColorRGB lift;
        RtColorRGB gain;
        RtColorRGB multiply;
        RtColorRGB gamma;
        RtColorRGB offset;
        RtInt clampWhite;
        RtInt clampBlack;
        RtColorRGB mask;
        RixChannelId channelId;
        RixChannelId channelId2;
        RixChannelId channelId3;
    };

    PtcPointCloud outptc = NULL;
    float w2e[16], w2n[16], format[3];
    float point[3], normal[3];
    float radius, *data;
    int datasize, nvars, nv;
    int npoints, _p;
    char **vartypes = NULL, **varnames = NULL, **vt = NULL, **vn = NULL; // arrays of strings
    char *inname, *outname;

    RixMutex       *m_allWorkersMutex;
    RixTransform   *_RixTransform;

    FILE *_f;

    // IECore::PointsPrimitive *__ptc;
    IECore::FloatVectorData *zr;
    IECore::FloatVectorData *zid;
    IECore::V3fVectorData   * p;
    IECore::V3fVectorData   * n;
    IECore::V3fVectorData   * c;
    float r, px, py, pz, nx,ny,nz, cr,cg,cb, id;
    unsigned long nsamples;
    unsigned long nsamples_old;


    // outptc = PtcCreatePointCloudFile(outname, nvars, vartypes, varnames, w2e, w2n, format);
    // PtcPointCloud PtcCreatePointCloudFile (char *filename, int nvars, char **vartypes,
    //                                       char **varnames, float *world2eye, float *world2ndc,
    //                                       float *format);
private:

};

PxrBakeSampleFilter::PxrBakeSampleFilter()
{
}

PxrBakeSampleFilter::~PxrBakeSampleFilter()
{
}

int PxrBakeSampleFilter::Init(RixContext &ctx, char const *pluginPath)
{
    //_rixContext = &ctx;
    _RixTransform = (RixTransform *)ctx.GetRixInterface(RixInterfaceId::k_RixTransform);
    m_allWorkersMutex=0;
    nsamples=0;
    nsamples_old=0;
    return 0;
}

enum paramIds
{
    k_blackPoint,
    k_whitePoint,
    k_lift,
    k_gain,
    k_multiply,
    k_gamma,
    k_offset,
    k_clampWhite,
    k_clampBlack,
    k_mask,
    k_aov,
    k_aov2,
    k_aov3,
    k_numParams
};

RixSCParamInfo const *
PxrBakeSampleFilter::GetParamTable()
{
    static RixSCParamInfo s_ptable[] =
    {
        RixSCParamInfo("blackPoint", k_RixSCColor),
        RixSCParamInfo("whitePoint", k_RixSCColor),
        RixSCParamInfo("lift", k_RixSCColor),
        RixSCParamInfo("gain", k_RixSCColor),
        RixSCParamInfo("multiply", k_RixSCColor),
        RixSCParamInfo("gamma", k_RixSCColor),
        RixSCParamInfo("offset", k_RixSCColor),
        RixSCParamInfo("clampWhite", k_RixSCInteger),
        RixSCParamInfo("clampBlack", k_RixSCInteger),
        RixSCParamInfo("mask", k_RixSCColor),
        RixSCParamInfo("aov", k_RixSCString),
        RixSCParamInfo("aov2", k_RixSCString),
        RixSCParamInfo("aov3", k_RixSCString),
        RixSCParamInfo()
    };
    return &s_ptable[0];
}

void PxrBakeSampleFilter::Finalize(RixContext &ctx)
{
    PtcFinishPointCloudFile(outptc);
    // fprintf(_f, "]\n");
    fclose(_f);
    IECore::PointsPrimitive * __ptc = new IECore::PointsPrimitive( p->copy() );
    __ptc->variables["N"] =  IECore::PrimitiveVariable( IECore::PrimitiveVariable::Varying, n->copy() );
    __ptc->variables["Cs"] =  IECore::PrimitiveVariable( IECore::PrimitiveVariable::Varying, c->copy() );
    __ptc->variables["width"] =  IECore::PrimitiveVariable( IECore::PrimitiveVariable::Varying, zr->copy() );
    __ptc->variables["id"] =  IECore::PrimitiveVariable( IECore::PrimitiveVariable::Varying, zid->copy() );

    IECore::Writer::create( __ptc, "/tmp/ptc.cob")->write();
}

int PxrBakeSampleFilter::CreateInstanceData(RixContext &ctx,
                                   char const *handle,
                                   RixParameterList const *parms,
                                   InstanceData *instance)
{
    instance->datalen = sizeof( sampleParams );
    instance->data = malloc( instance->datalen );
    instance->freefunc = free;
    sampleParams *pp = reinterpret_cast< sampleParams * >( instance->data );

    pp->blackPoint = RtColorRGB(0.0f,0.0f,0.0f);
    pp->whitePoint = RtColorRGB(1.0f,1.0f,1.0f);
    pp->lift = RtColorRGB(0.0f,0.0f,0.0f);
    pp->gain = RtColorRGB(1.0f,1.0f,1.0f);
    pp->multiply = RtColorRGB(1.0f,1.0f,1.0f);
    pp->gamma = RtColorRGB(1.0f,1.0f,1.0f);
    pp->offset = RtColorRGB(0.0f,0.0f,0.0f);
    pp->clampWhite = 0;
    pp->clampBlack = 1;
    pp->mask = RtColorRGB(1.0f,1.0f,1.0f);
    pp->channelId = k_InvalidChannelId;
    RtConstString aov = "Ci";
    RtConstString aov2 = "P";
    RtConstString aov3 = "id";

    parms->EvalParam( k_blackPoint, 0, &pp->blackPoint);
    parms->EvalParam( k_whitePoint, 0, &pp->whitePoint);
    parms->EvalParam( k_lift, 0, &pp->lift);
    parms->EvalParam( k_gain, 0, &pp->gain);
    parms->EvalParam( k_multiply, 0, &pp->multiply);
    parms->EvalParam( k_gamma, 0, &pp->gamma);
    parms->EvalParam( k_offset, 0, &pp->offset);
    parms->EvalParam( k_clampWhite, 0, &pp->clampWhite);
    parms->EvalParam( k_clampBlack, 0, &pp->clampBlack);
    parms->EvalParam( k_mask, 0, &pp->mask);
    parms->EvalParam( k_aov, 0, &aov);

    RixMessages *msg = reinterpret_cast< RixMessages * >(
        ctx.GetRixInterface( k_RixMessages ) );
    RixRenderState *renderState = static_cast<RixRenderState*>(
        ctx.GetRixInterface(k_RixRenderState));
    RixRenderState::FrameInfo frameInfo;
    renderState->GetFrameInfo(&frameInfo);
    RixIntegratorEnvironment const *iEnv = frameInfo.integratorEnv;

    RixDisplayChannel const *channel;
    if (!(channel = iEnv->GetDisplayChannel(aov)))
    {
        msg->Warning( "PxrBakeSampleFilter '%s' did not find a "
                      "display for AOV '%s'", handle, aov );
        return -1;
    }
    pp->channelId = channel->id;

    if (!(channel = iEnv->GetDisplayChannel(aov2)))
    {
        msg->Warning( "PxrBakeSampleFilter '%s' did not find a "
                      "display for AOV '%s'", handle, aov );
        return -1;
    }
    pp->channelId2 = channel->id;

    if (!(channel = iEnv->GetDisplayChannel(aov3)))
    {
        msg->Warning( "PxrBakeSampleFilter '%s' did not find a "
                      "display for AOV '%s'", handle, aov );
        return -1;
    }
    pp->channelId3 = channel->id;


    nvars=1;
    char *_vartypes[1] = {(char *)"color"};
    char *_varnames[1] = {(char *)"RGB"};
    char *f=(char *)"/tmp/xx.ptc";
    for ( int n=0; n<16 ; n++ ){
        w2e[n]=1;
        w2n[n]=1;
    }
    format[0]=1920;
    format[1]=1080;
    format[0]=3;
    std::cout << "\nBUMMMM " << channel->id << std::endl; std::cout.flush();

    outptc = PtcCreatePointCloudFile (f, nvars, _vartypes,
                _varnames, w2e, w2n, format);

    if (!outptc) {
         fprintf(stderr, "Unable to open output file %s.\n", outname);
         exit(1);
       }

    // std::cout << "\nBUMMMM 2\n" << std::endl; std::cout.flush();

    if (RixThreadUtils *threadUtils =
        (RixThreadUtils*) ctx.GetRixInterface(k_RixThreadUtils))
    {
        m_allWorkersMutex = threadUtils->NewMutex();
    }

    _f = fopen("/tmp/zz.ptc","a");
    // fprintf(_f, "[\n");
    fflush(_f);



    zr  = new IECore::FloatVectorData();
    zid = new IECore::FloatVectorData();
    p   = new IECore::V3fVectorData();
    n   = new IECore::V3fVectorData();
    c   = new IECore::V3fVectorData();
    nsamples=0;
    nsamples_old=0;

    return 0;
}

void PxrBakeSampleFilter::Filter(RixSampleFilterContext &fCtx,
                                RtConstPointer instance)
{
    sampleParams const* pp = reinterpret_cast< sampleParams const* >(instance);

    // std::cout << "\nBUMMMM 3\n" << std::endl; std::cout.flush();

    float data[3];
    RtColorRGB result;
    result.r = result.g = result.b = 0;
    long nn=0;
    RtColorRGB closer_result;
    float id=0;
    float oldid=0;
    float anti_alias_pixel = 0;
    closer_result.r = closer_result.g = closer_result.b = 0;
    double lastZ = 9999999999999;
    for (int i=0 ; i < fCtx.numSamples; ++i) {
        RtColorRGB origPixel;
        RtColorRGB Ppixel;
        float _id;
        fCtx.Read(pp->channelId, i, origPixel);
        fCtx.Read(pp->channelId2, i, Ppixel);
        fCtx.Read(pp->channelId3, i, _id);
        if ( Ppixel.b <  lastZ ){
            closer_result = origPixel;
            id = _id;
            lastZ = Ppixel.b;
        }
        if (_id != oldid){
            anti_alias_pixel++;
        }
        oldid = _id;
        result += origPixel;
        nn++;
        fCtx.Write(pp->channelId, i, origPixel);
    }
    result /=nn;

    if ( anti_alias_pixel <= 1){

        if (m_allWorkersMutex){
            m_allWorkersMutex->Lock();
            if ( fCtx.shadeCtxs[0] && fCtx.numGrps > 0){
                // if ( fCtx.shadeCtxs[i]->numPts )
                {
                    // gather stats first

                    const RtFloat3 *P;
                    fCtx.shadeCtxs[0]->GetBuiltinVar(RixShadingContext::k_P, &P);
                    const float *radius;
                    fCtx.shadeCtxs[0]->GetBuiltinVar(RixShadingContext::k_PRadius, &radius);
                    const RtFloat3 *N;
                    fCtx.shadeCtxs[0]->GetBuiltinVar(RixShadingContext::k_Nn, &N);


                    float _P[3]; _P[0] = P->x; _P[1] = P->y; _P[2] = P->z;
                    float _N[3]; _N[0] = N->x; _N[1] = N->y; _N[2] = N->z;
                    data[1] = result.g;
                    data[0] = result.r;
                    data[2] = result.b;

                    // std::cout << _P[0] << ", ";
                    // std::cout << _P[1] << ", ";
                    // std::cout << _P[2] << "\n" << std::endl;
                    // std::cout.flush();

                    // FILE *f = fopen("/tmp/zz.ptc","a");
                    _RixTransform->TransformPoints(const_cast<char*>("camera"), const_cast<char*>("world"), 1, &_P, 0);

                    // std::cout << _P[0] << ", ";
                    // std::cout << _P[1] << ", ";
                    // std::cout << _P[2] << "\n\n\n" << std::endl;
                    // std::cout.flush();

                    if ( result.r + result.g + result.b > 0 ){
                        // std::cout << "\nBUMMMM 4 - " << i << " - " << fCtx.numGrps << " - " << fCtx.shadeCtxs[0] << " - " << fCtx.shadeCtxs[0]->shadingCtxId.IsValid() << "\n" << std::endl; std::cout.flush();
                        // FILE *f = fopen("/tmp/zz.ptc","a");
                        fprintf(_f, "[%g,[%g,%g,%g],[%g,%g,%g,],[%g,%g,%g],%g]\n", radius[0], _P[0], _P[1], _P[2], _N[0], _N[1], _N[2], result.r, result.g, result.b, id );
                        fflush(_f);
                        // fclose(f);

                        PtcWriteDataPoint(outptc, _P, _N, radius[0], data);
                        // std::cout << "\nBUMMMM 5\n" << std::endl; std::cout.flush();


                        p->writable().push_back( Imath::V3f( _P[0], _P[1], _P[2]) );
                        n->writable().push_back( Imath::V3f( _N[0], _N[1], _N[2]) );
                        c->writable().push_back( Imath::V3f( result.r, result.g, result.b) );
                        zr->writable().push_back( radius[0] );
                        zid->writable().push_back( id );


                        nsamples++;
                        if( nsamples/1000 != nsamples_old){
                            IECore::PointsPrimitive * __ptc = new IECore::PointsPrimitive( p->copy() );
                            __ptc->variables["N"] =  IECore::PrimitiveVariable( IECore::PrimitiveVariable::Varying, n->copy() );
                            __ptc->variables["Cs"] =  IECore::PrimitiveVariable( IECore::PrimitiveVariable::Varying, c->copy() );
                            __ptc->variables["width"] =  IECore::PrimitiveVariable( IECore::PrimitiveVariable::Varying, zr->copy() );
                            __ptc->variables["id"] =  IECore::PrimitiveVariable( IECore::PrimitiveVariable::Varying, zid->copy() );

                            IECore::Writer::create( __ptc, "/tmp/ptc.cob")->write();
                            nsamples_old = nsamples/1000;

                        }


                    }
                }
            }
            m_allWorkersMutex->Unlock();
        }

    }

}

RIX_SAMPLEFILTERCREATE
{
    return new PxrBakeSampleFilter();
}

RIX_SAMPLEFILTERDESTROY
{
    delete reinterpret_cast< PxrBakeSampleFilter * >( filter );
}
