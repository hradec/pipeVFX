/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2016 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

/* $Revision: #5 $ */

// PxrValidateBxdf:
//  a simple integrator useful for validating basic bxdf functionality.
//  results are encoding in RGB channels as follows:
//
//  R: is the value of the bxdf for its generated samples.  It must
//     always be <= 1.0f.
//  G: is the value of the bxdf for the sample samples run through
//     the evaluate method.  R and G should be equal.
//  B: contains the evaluation results for a cosine distribution of
//     hemispherical samples.  Again must always be <= 1.0f.
//
//  not covered by this validator (yet):
//
//  * emission
//  * spherical evaluation (thin translucence)
//

#include "RixIntegrator.h"
#include "RixBxdf.h"
#include "RixRNG.h"
#include "RixShadingUtils.h"
#include "PxrGeoAovs.h"
#include <cassert>
#include <string.h>

class ValidateBxdfWorker;

class PxrValidateBxdf : public RixIntegrator
{
public:

    PxrValidateBxdf();
    virtual ~PxrValidateBxdf();

    virtual int Init(RixContext &, char const *pluginpath);
    virtual RixSCParamInfo const *GetParamTable(); // ???
    virtual void Finalize(RixContext &); // ???

    virtual void RenderBegin(RixContext &ctx, RixIntegratorEnvironment &env,
                             RixParameterList const *);
    virtual void RenderEnd(RixContext &ctx);

    virtual void Integrate(RtInt ngrps, RixShadingContext const *shadGrps[],
                          RixIntegratorContext &ictx);

    void ReportStats(RixXmlFile* file);

private:
    RtInt m_numSamples, m_maxShadingCtxSize;
    RixChannelId m_ciChan;

    RixMutex    *m_allWorkersMutex;
    std::vector<ValidateBxdfWorker *> m_allWorkers;

    RtInt *m_geoAovIds;
};

PxrValidateBxdf::PxrValidateBxdf() : 
    m_numSamples(4),
    m_allWorkersMutex(0),
    m_geoAovIds(NULL)
{
}

PxrValidateBxdf::~PxrValidateBxdf()
{
    delete[] m_geoAovIds;
    m_geoAovIds = NULL;
}


int
PxrValidateBxdf::Init(RixContext &ctx, char const *pluginpath)
{
    // Setup any shared resources

    if (RixThreadUtils *threadUtils = 
        (RixThreadUtils*) ctx.GetRixInterface(k_RixThreadUtils))
    {
        m_allWorkersMutex = threadUtils->NewMutex();
    }

    return 0;
}

RixSCParamInfo const *
PxrValidateBxdf::GetParamTable()
{
    static RixSCParamInfo s_ptable[] = 
    {
        RixSCParamInfo("numSamples", k_RixSCInteger),
        RixSCParamInfo() // end of table
    };
    return &s_ptable[0];
}

static void
statsReporter(void *ctx, class RixXmlFile *file)
{
    ((PxrValidateBxdf*)ctx)->ReportStats(file);
}

void
PxrValidateBxdf::ReportStats(RixXmlFile* file)
{
    file->WriteText("\n");
    file->WriteXml("<stats name=\"parameters\" description=\"parameters\" >\n");
    file->WriteStat("numSamples", NULL, m_numSamples);
    file->WriteXml("</stats>\n");
}

void
PxrValidateBxdf::Finalize(RixContext &ctx)
{ 
    if (m_allWorkersMutex)
    {
        delete m_allWorkersMutex;
        m_allWorkersMutex = 0;
    }
}

void
PxrValidateBxdf::RenderBegin(RixContext &ctx, RixIntegratorEnvironment &env,
                             RixParameterList const *plist)
{
    char const *pnm;
    RtInt paramId;

    pnm = "numSamples";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        plist->EvalParam(paramId, 0, &m_numSamples);
    }

    for (int index = 0; index < env.numDisplays; ++index) 
    {
        if (!strcmp("Ci", env.displays[index].channel))
            m_ciChan = env.displays[index].id;
    }

    env.supportedSamplingModes = RixIntegratorEnvironment::SamplingModes(
                                    RixIntegratorEnvironment::k_Fixed |
                                    RixIntegratorEnvironment::k_Incremental);
    m_maxShadingCtxSize = env.maxShadingCtxSize;

    RixStats* stats = (RixStats*) ctx.GetRixInterface(k_RixStats);
    stats->AddReporterCtx(statsReporter, this);

    // Get the list of requested geometric AOVs
    PxrGeoAOV::GetChannelIds(env, m_geoAovIds);
}

class ValidateBxdfWorker 
{
public:
    ValidateBxdfWorker(const RixIntegratorContext &iCtx,
                       RtInt numSamps, RtInt maxSCtxSize,
                       RixChannelId ciChan) :
        m_ciChan(ciChan),        
        m_numSamples(numSamps),
        m_maxSCtxSize(maxSCtxSize)
    {
        m_displaySvc = iCtx.GetDisplayServices();

        m_lobesWanted = new RixBXLobeTraits[maxSCtxSize];
        m_lobesEvaluated = new RixBXLobeTraits[maxSCtxSize];
        m_lobeSampled = new RixBXLobeSampled[maxSCtxSize];
        m_On = new RtVector3[maxSCtxSize];

        for (int i = 0; i < k_RixBXMaxNumDiffuseLobes; i++)
            m_diffuse[i]   = new RtColorRGB[maxSCtxSize];

        for (int i = 0; i < k_RixBXMaxNumSpecularLobes; i++)
            m_specular[i]   = new RtColorRGB[maxSCtxSize];

        for (int i = 0; i < k_RixBXMaxNumUserLobes; i++)
            m_user[i]   = new RtColorRGB[maxSCtxSize];

        m_FPdf = new RtFloat[maxSCtxSize];
        m_RPdf = new RtFloat[maxSCtxSize];
        m_cosTheta = new RtFloat[maxSCtxSize];
        m_rngSamps = new RixRNG::SampleCtx[maxSCtxSize];
        m_rngEvalSamps = new RixRNG::SampleCtx[maxSCtxSize];
    }

    ~ValidateBxdfWorker()
    {
        delete [] m_lobesWanted;
        delete [] m_lobesEvaluated;
        delete [] m_lobeSampled;
        delete [] m_On;

        for (int i = 0; i < k_RixBXMaxNumDiffuseLobes; i++)
            delete[] m_diffuse[i];

        for (int i = 0; i < k_RixBXMaxNumSpecularLobes; i++)
            delete[] m_specular[i];

        for (int i = 0; i < k_RixBXMaxNumUserLobes; i++)
            delete[] m_user[i];

        delete [] m_FPdf;
        delete [] m_RPdf; 
        delete [] m_cosTheta;
        delete [] m_rngSamps;
        delete [] m_rngEvalSamps;
    }

    void Integrate(RtInt ngrps, RixShadingContext const *sgrps[],
                  RixIntegratorContext &ictx);

private:  
    // get a nice contiguous group of rng for calling generate
    // scale numSamples and sampleid by correct number of samples.  
    void InitRNG(RixIntegratorContext &iCtx, 
                 RixShadingContext const &sCtx, bool isGen) 
    {
        assert(sCtx.numPts <= m_maxSCtxSize);
        RtInt domain = isGen ? 17 : 23;
        for(int i = 0; i < sCtx.numPts; i++)  {
            RtInt iCtxIndex = sCtx.integratorCtxIndex[i];
            RixRNG::SampleCtx s = iCtx.rngCtx->GetSampleCtx(iCtxIndex);
            m_rngSamps[i] = s.NewDomain(domain);
            m_rngSamps[i].numsamples *= m_numSamples;
            m_rngSamps[i].sampleid *= m_numSamples;
        }
    }
    void IncRNG(RixShadingContext const &sCtx) {
        // bump the sample in the rng
        for(int i = 0; i < sCtx.numPts; i++)  {
            m_rngSamps[i].sampleid++;
        }
    }

    void InitEvalRNG(RixIntegratorContext &iCtx, 
                     RixShadingContext const &sCtx, bool isGen) 
    {
        assert(sCtx.numPts <= m_maxSCtxSize);
        RtInt domain = isGen ? 17 : 23;
        for(int i = 0; i < sCtx.numPts; i++)  {
            RtInt iCtxIndex = sCtx.integratorCtxIndex[i];
            RixRNG::SampleCtx s = iCtx.rngCtx->GetSampleCtx(iCtxIndex);
            m_rngEvalSamps[i] = s.NewDomain(domain);
            m_rngEvalSamps[i].numsamples *= m_numSamples;
            m_rngEvalSamps[i].sampleid *= m_numSamples;
        }
    }
    void IncEvalRNG(RixShadingContext const &sCtx) {
        // bump the sample in the rng
        for(int i = 0; i < sCtx.numPts; i++)  {
            m_rngEvalSamps[i].sampleid++;
        }
    }

    void SplatCi(RixIntegratorContext &iCtx,
        RixShadingContext const &sCtx,
        int index,
        RtColorRGB val) {
        m_displaySvc->Splat(m_ciChan,sCtx.integratorCtxIndex[index], val);
        m_displaySvc->WriteOpacity(m_ciChan, sCtx.integratorCtxIndex[index], 1.0f);
    }
    RtFloat MIS(RtFloat nG, RtFloat pdfG, RtFloat nE, RtFloat pdfE) {
        return 1; //nG / (nG + nE);
    }

  private:
    RixBXLobeTraits *m_lobesWanted;
    RixBXLobeTraits *m_lobesEvaluated;
    RixBXLobeSampled *m_lobeSampled;
    RtVector3 *m_On;
    RtColorRGB *m_diffuse[k_RixBXMaxNumDiffuseLobes];
    RtColorRGB *m_specular[k_RixBXMaxNumSpecularLobes];
    RtColorRGB *m_user[k_RixBXMaxNumUserLobes];
    RtFloat *m_FPdf, *m_RPdf, *m_cosTheta;

    RixDisplayServices *m_displaySvc;

    RixRNG::SampleCtx *m_rngSamps;
    RixRNG::SampleCtx *m_rngEvalSamps;

    RixChannelId m_ciChan;

    RtInt m_numSamples, m_maxSCtxSize;
};

void
ValidateBxdfWorker::Integrate(RtInt ngrps, RixShadingContext const *shadeGrps[],
                              RixIntegratorContext &iCtx)
{
    RtColorRGB diffuse[k_RixBXMaxNumDiffuseLobes];
    RtColorRGB specular[k_RixBXMaxNumSpecularLobes];
    RtColorRGB user[k_RixBXMaxNumUserLobes];
    RtColorRGB *diffusePtrs[k_RixBXMaxNumDiffuseLobes];
    RtColorRGB *specularPtrs[k_RixBXMaxNumSpecularLobes];
    RtColorRGB *userPtrs[k_RixBXMaxNumUserLobes];
    
    for (int j = 0; j < k_RixBXMaxNumDiffuseLobes; j++)
        diffusePtrs[j] = &diffuse[j];
    for (int j = 0; j < k_RixBXMaxNumSpecularLobes; j++)
        specularPtrs[j] = &specular[j];
    for (int j = 0; j < k_RixBXMaxNumUserLobes; j++)
        userPtrs[j] = &user[j];
    
    for(int g = 0; g < ngrps; g++) 
    {
        RixShadingContext const &sCtx = *shadeGrps[g];
        RixBxdf &bxdf = *(sCtx.GetBxdf());
    
        RixRNG rng(iCtx.rngCtx, m_rngSamps, sCtx.numPts);
        RixRNG evalRng(iCtx.rngCtx, m_rngEvalSamps, sCtx.numPts);

        // setup RNG for n GenerateSamples calls 
        InitRNG(iCtx, sCtx, true);
        InitEvalRNG(iCtx, sCtx, true);

        for (int i = 0; i < sCtx.numPts; i++)
            m_lobesWanted[i].SetAll();

        for(int ls = 0; ls < m_numSamples; ls++) 
        {
            RixBXLobeWeights lw(sCtx.numPts, 
                                k_RixBXMaxNumDiffuseLobes,
                                k_RixBXMaxNumSpecularLobes, 
                                k_RixBXMaxNumUserLobes,
                                m_diffuse, 
                                m_specular,
                                m_user); 

            bxdf.GenerateSample(k_RixBXAnyLighting, 
                                m_lobesWanted, &rng, m_lobeSampled, 
                                m_On, lw, m_FPdf, m_RPdf);
                
            RixBXActiveLobeWeights activeLobes;
            lw.GetActiveLobes(activeLobes);

            for(int i = 0; i < sCtx.numPts; i++) 
            {
                if(!m_lobeSampled[i].GetValid())
                    continue;
                RtColorRGB rho = activeLobes.SumAtIndex(i);
                RtColorRGB rad = rho / m_FPdf[i];
                rad /=  m_numSamples;
                RtFloat lum = .33333f * (rad.r + rad.g + rad.b);
                // Gen results go in to red channel
                SplatCi(iCtx, sCtx, i, RtColorRGB(lum, 0, 0));
                if(m_lobeSampled[i].GetDiscrete())
                    continue;

                // verify each generated sample gives exactly the same
                // results when evaluated 
                RixBXLobeWeights elw(1, 
                                     k_RixBXMaxNumDiffuseLobes,
                                     k_RixBXMaxNumSpecularLobes,
                                     k_RixBXMaxNumUserLobes,
                                     diffusePtrs, 
                                     specularPtrs,
                                     userPtrs);

                RtFloat FPdf, RPdf;
                RixBXLobeTraits lobesEvaluated;
                bxdf.EvaluateSamplesAtIndex(k_RixBXAnyLighting, 
                                            m_lobesWanted[i], 
                                            &evalRng,
                                            i, 1, &lobesEvaluated, m_On + i, 
                                            elw, &FPdf, &RPdf);

                if(!lobesEvaluated.GetValid()) {
                    continue;  
                }
                if(fabs(m_FPdf[i] - FPdf) > 1e-3 * FPdf) 
                {
                    //printf("bad FPdf %f %f\n", m_FPdf[i], FPdf );
                    continue;  // they should have been equal
                }
                if(fabs(m_RPdf[i] - RPdf) > 1e-3 * RPdf) 
                {
                    // printf("bad RPdf %f %f\n", m_RPdf[i], RPdf);
                    continue; //  they should have been equal
                }
                if(!lobesEvaluated.HasAny()) {
                    // there are legit cases for this
                    // example can be a black diffuse material which didnt need any lobes to be sampled
                    // yet needs to be splat.
                    SplatCi(iCtx, sCtx, i, RtColorRGB(0, 0, 0));
                    continue;  
                }

                RixBXActiveLobeWeights evalActiveLobes;
                elw.GetActiveLobes(evalActiveLobes);

                RtColorRGB eRho = evalActiveLobes.SumAtIndex(0);
                RtColorRGB eRad = eRho / FPdf;
                eRad /= m_numSamples;
                RtFloat eLum = .33333f * (eRad.r + eRad.g + eRad.b);
                SplatCi(iCtx, sCtx, i, RtColorRGB(0, eLum, 0));
            } 
            IncRNG(sCtx);
            IncEvalRNG(sCtx);
        }

        RtNormal3 const* Nn;
        RtVector3 const* Tn;
        sCtx.GetBuiltinVar(RixShadingContext::k_Nn, &Nn);
        sCtx.GetBuiltinVar(RixShadingContext::k_Tn, &Tn);

        // setup RNG for n EvaluateBxdfSamples calls 
        InitRNG(iCtx, sCtx, false);
        InitEvalRNG(iCtx, sCtx, false);
        for(int ls = 0; ls < m_numSamples; ls++) 
        {
            // generate cos weighted hemisphere samples
            for(int i = 0; i < sCtx.numPts; i++) 
            {
                RtVector3 TX, TY;
                RixComputeShadingBasis(Nn[i], Tn[i], TX, TY);
                RixCosDirectionalDistribution(rng.DrawSample2D(i),
                                              Nn[i], TX, TY,
                                              m_On[i], m_cosTheta[i]);
            }
             

   
            RixBXLobeWeights lw(sCtx.numPts, 
                                k_RixBXMaxNumDiffuseLobes,
                                k_RixBXMaxNumSpecularLobes, 
                                k_RixBXMaxNumUserLobes,
                                m_diffuse, 
                                m_specular,
                                m_user); 

            bxdf.EvaluateSample(k_RixBXAnyLighting,
                                m_lobesWanted, &evalRng,
                                m_lobesEvaluated, m_On, 
                                lw, m_FPdf, m_RPdf);
                
            RixBXActiveLobeWeights activeLobes;
            lw.GetActiveLobes(activeLobes);

            // process results
            for(int i = 0; i < sCtx.numPts; i++) {
                if(!m_lobesEvaluated[i].HasAny())
                    continue;
                RtColorRGB rho = activeLobes.SumAtIndex(i);
                RtFloat hemiPdf = m_cosTheta[i] * F_INVPI;
                RtColorRGB rad = rho / hemiPdf; 
                rad /=  m_numSamples;
                RtFloat lum = .33333f * (rad.r + rad.g + rad.b);
                // Eval results go into blue channel
                SplatCi(iCtx, sCtx, i, RtColorRGB(0, 0, lum));
            } 
            IncRNG(sCtx);
            IncEvalRNG(sCtx);
        }
    }
}

void
PxrValidateBxdf::RenderEnd(RixContext &)
{
    if (m_allWorkersMutex)
    {
        m_allWorkersMutex->Lock();

        for (int i = 0; i < m_allWorkers.size(); i++)
            delete m_allWorkers[i];

        m_allWorkers.clear();

        m_allWorkersMutex->Unlock();
    }
}

void
PxrValidateBxdf::Integrate(RtInt ngrps, RixShadingContext const *shadeGrps[],
                          RixIntegratorContext &iCtx)
{
    RixStorage *storage = (RixStorage*) iCtx.GetRixInterface(k_RixThreadData);
    ValidateBxdfWorker *worker = ((ValidateBxdfWorker *)
                                    storage->Get("PxrValidateBxdfWorker"));
    if (worker == NULL) {
        worker = new ValidateBxdfWorker(iCtx, m_numSamples, m_maxShadingCtxSize,
                                        m_ciChan);
	storage->Set("PxrValidateBxdfWorker", worker, NULL);

        if (m_allWorkersMutex)
        {
            m_allWorkersMutex->Lock();
            m_allWorkers.push_back(worker);
            m_allWorkersMutex->Unlock();
        }
    }

    worker->Integrate(ngrps, shadeGrps, iCtx);
    if (m_geoAovIds)
    {
        RixDisplayServices *displaySvc = iCtx.GetDisplayServices();
        RtFloat3 *geoAovColor = NULL;
        RtFloat  *geoAovFloat = NULL;
        geoAovColor = new RtFloat3[m_maxShadingCtxSize];
        if (PxrGeoAOV::NeedTempFloat(m_geoAovIds))
            geoAovFloat = new RtFloat[m_maxShadingCtxSize];
        PxrGeoAOV::Splat(ngrps,
            shadeGrps,
            displaySvc, geoAovColor,
            geoAovFloat, m_geoAovIds);
        delete[] geoAovColor;
        delete[] geoAovFloat;
    }
}

RIX_INTEGRATORCREATE
{
    return new PxrValidateBxdf();
}


RIX_INTEGRATORDESTROY
{
    delete ((PxrValidateBxdf*)integrator);
}
