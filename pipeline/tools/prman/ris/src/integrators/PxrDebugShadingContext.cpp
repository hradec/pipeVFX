/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2016 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

/* $Revision: #3 $ */

#include "RixIntegrator.h"
#include "RixShadingUtils.h"
#include "RixBxdf.h"
#include "PxrGeoAovs.h"
#include <cassert>
#include <cstring>

static char const *s_myname =  "PxrDebugShadingContext";

class PxrDebugShadingContext : public RixIntegrator
{
public:

    PxrDebugShadingContext();
    virtual ~PxrDebugShadingContext();

    virtual int Init(RixContext &, char const *pluginpath);
    virtual RixSCParamInfo const *GetParamTable(); // ???
    virtual void Finalize(RixContext &); // ???

    virtual void RenderBegin(RixContext &ctx, RixIntegratorEnvironment &env,
                             RixParameterList const *plist);
    virtual void RenderEnd(RixContext &ctx);

    virtual void Integrate(RtInt ngrps, RixShadingContext const *sgrps[],
                           RixIntegratorContext &ictx);

    void ReportStats(RixXmlFile* file);

private:

    void integrateHelper(RixIntegratorContext &iCtx,
                         RixShadingContext const &vCtx);

    RixMessages *m_msgs;
    enum 
    {
        k_Nn = 0,
        k_Vn,
        k_VLen,
        k_Tn,
        k_InsideOutside,
        k_ST,
        k_dsdu_dtdv,
        k_dsdv_dtdu,
        k_UV,
        k_dudv,
        k_LightLeaks,
        k_P,
        k_dPdu,
        k_dPdv,
        k_dPdtime,
        k_Id,
        k_Ngn,
        k_Po,
        k_Non,
        k_NumChannels
    } m_viewChannel; // Nn, Tn, P, Vn, VLen, ...
    RixChannelId m_ciChan;
    static char const *s_channelNames[k_NumChannels];

    RtInt m_maxShadingCtxSize;
    RtInt *m_geoAovIds;
};

char const *PxrDebugShadingContext::s_channelNames[k_NumChannels] =
{
    "Nn", "Vn", "VLen", "Tn", "InsideOutside", "ST", "dsdu_dtdv", "dsdv_dtdu",
    "UV", "dudv", "LightLeaks", "P", "dPdu", "dPdv", "dPdtime", "id", "Ngn", "Po", "Non"
};

PxrDebugShadingContext::PxrDebugShadingContext()
    : m_geoAovIds(NULL)
{
}

PxrDebugShadingContext::~PxrDebugShadingContext()
{
    delete[] m_geoAovIds;
    m_geoAovIds = NULL;
}

int
PxrDebugShadingContext::Init(RixContext &ctx, char const *pluginpath)
{
    // Setup any shared resources
    m_msgs = (RixMessages*) ctx.GetRixInterface(k_RixMessages);
    m_viewChannel = k_Nn;
    return 0;
}

RixSCParamInfo const *
PxrDebugShadingContext::GetParamTable()
{
    static RixSCParamInfo s_ptable[] = 
    {
        RixSCParamInfo("viewchannel",  k_RixSCString),

        RixSCParamInfo() // end of table
    };
    return &s_ptable[0];
}

static void
statsReporter(void *ctx, class RixXmlFile *file)
{
    ((PxrDebugShadingContext*)ctx)->ReportStats(file);
}

void
PxrDebugShadingContext::ReportStats(RixXmlFile* file)
{
    file->WriteText("\n");
    file->WriteXml("<stats name=\"parameters\" description=\"parameters\" >\n");
    file->WriteStat("viewchannel", NULL, s_channelNames[m_viewChannel]);
    file->WriteXml("</stats>\n");
}

void
PxrDebugShadingContext::Finalize(RixContext &ctx)
{ 
    // m_msgs->Info("%s: Finalize", s_myname);
}

void
PxrDebugShadingContext::RenderBegin(RixContext &ctx, 
                                    RixIntegratorEnvironment &env, 
                                    RixParameterList const *plist)
{
    RtConstString ch = "Nn";
    char const *inm = "PxrDebugShadingContext";
    char const *pnm = "viewchannel";
    RtInt paramId;

    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &ch) != k_RixSCUniform)
        {
            m_msgs->Error("%s: invalid type for %s", inm, pnm);
        }
    }

    if(!strcmp(ch, "Nn"))
        m_viewChannel = k_Nn;
    else
    if(!strcmp(ch, "Vn"))
        m_viewChannel = k_Vn;
    else
    if(!strcmp(ch, "VLen"))
        m_viewChannel = k_VLen;
    else
    if(!strcmp(ch, "Tn"))
        m_viewChannel = k_Tn;
    else
    if(!strcmp(ch, "InsideOutside"))
        m_viewChannel = k_InsideOutside;
    else
    if(!strcmp(ch, "ST") || !strcmp(ch, "st"))
        m_viewChannel = k_ST;
    else
    if(!strcmp(ch, "dsdu_dtdv"))
        m_viewChannel = k_dsdu_dtdv;
    else
    if(!strcmp(ch, "dsdv_dtdu"))
        m_viewChannel = k_dsdv_dtdu;
    else
    if(!strcmp(ch, "UV") || !strcmp(ch, "uv"))
        m_viewChannel = k_UV;
    else
    if(!strcmp(ch, "dudv") || !strcmp(ch, "dUdV"))
        m_viewChannel = k_dudv;
    else
    if(!strcmp(ch, "LightLeaks"))
        m_viewChannel = k_LightLeaks;
    else
    if(!strcmp(ch, "P"))
        m_viewChannel = k_P;
    else
    if(!strcmp(ch, "Po"))
        m_viewChannel = k_Po;
    else
    if(!strcmp(ch, "dPdu"))
        m_viewChannel = k_dPdu;
    else
    if(!strcmp(ch, "dPdv"))
        m_viewChannel = k_dPdv;
    else
    if(!strcmp(ch, "dPdtime"))
        m_viewChannel = k_dPdtime;
    else
    if(!strcmp(ch, "Id") || !strcmp(ch, "id"))
        m_viewChannel = k_Id;
    else
    if(!strcmp(ch, "Ngn"))
        m_viewChannel = k_Ngn;
    else
    if(!strcmp(ch, "Non"))
        m_viewChannel = k_Non;
    else
    {
        m_msgs->Error("%s: unknown viewchannel %s", s_myname, ch);
        m_viewChannel = k_Nn;
    }

    for (int index = 0; index < env.numDisplays; ++index) 
    {
        if (!strcmp("Ci", env.displays[index].channel))
            m_ciChan = env.displays[index].id;
    }

    RixStats* stats = (RixStats*) ctx.GetRixInterface(k_RixStats);
    stats->AddReporterCtx(statsReporter, this);

    m_maxShadingCtxSize = env.maxShadingCtxSize;
    // Get the list of requested geometric AOVs
    PxrGeoAOV::GetChannelIds(env, m_geoAovIds);
}

void
PxrDebugShadingContext::RenderEnd(RixContext &ctx)
{
    // m_msgs->Info("%s: RenderEnd", s_myname);
}

void
PxrDebugShadingContext::integrateHelper(RixIntegratorContext &iCtx,
    RixShadingContext const &sCtx) 
{
    assert(sCtx.scTraits.shadingMode == k_RixSCScatterQuery);
    RtColorRGB result;
    int numPts = sCtx.numPts;

    RtPoint3 const*  P;
    RtPoint3 const*  Po;
    RtNormal3 const* Ngn;
    RtNormal3 const* Non;
    RtNormal3 const* Nn;
    RtVector3 const* Vn;
    RtVector3 const* Tn;
    RtFloat const* VLen;
    RtFloat const* u; 
    RtFloat const* du; 
    RtFloat const * v;
    RtFloat const * dv;
    sCtx.GetBuiltinVar(RixShadingContext::k_P,  &P);
    sCtx.GetBuiltinVar(RixShadingContext::k_Po, &Po);
    sCtx.GetBuiltinVar(RixShadingContext::k_Ngn, &Ngn);
    sCtx.GetBuiltinVar(RixShadingContext::k_Non, &Non);
    sCtx.GetBuiltinVar(RixShadingContext::k_Nn, &Nn);
    sCtx.GetBuiltinVar(RixShadingContext::k_Tn, &Tn);
    sCtx.GetBuiltinVar(RixShadingContext::k_Vn, &Vn);
    sCtx.GetBuiltinVar(RixShadingContext::k_VLen, &VLen);
    sCtx.GetBuiltinVar(RixShadingContext::k_u, &u);
    sCtx.GetBuiltinVar(RixShadingContext::k_v, &v);
    sCtx.GetBuiltinVar(RixShadingContext::k_du, &du);
    sCtx.GetBuiltinVar(RixShadingContext::k_dv, &dv);

    RixDisplayServices *displaySvc = iCtx.GetDisplayServices();

    switch(m_viewChannel)
    {
        case k_Nn:
            for(int i = 0; i < numPts; i++)
            {
                int did = sCtx.integratorCtxIndex[i];
                result = RtColorRGB(Nn[i], true);
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_Vn:
            for(int i = 0; i < numPts; i++) 
            {
                int did = sCtx.integratorCtxIndex[i];
                result = RtColorRGB(Vn[i], true);
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_VLen:
            for(int i = 0; i < numPts; i++) 
            {
                int did = sCtx.integratorCtxIndex[i];
                result = RtColorRGB(VLen[i]);
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_Tn:
            for(int i = 0; i < numPts; i++) 
            {
                int did = sCtx.integratorCtxIndex[i];
                result = RtColorRGB(Tn[i], true);
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_InsideOutside:
            for(int i = 0; i < numPts; i++) 
            {
                RtFloat costheta = Vn[i].Dot(Nn[i]);
                if (costheta < 0.0f)
                    result = RtColorRGB(-costheta,0,0);
                else
                    result = RtColorRGB(0,costheta,0);
                int did = sCtx.integratorCtxIndex[i];
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_LightLeaks:
            for(int i = 0; i < numPts; i++) 
            {
                RtFloat VdNn = Vn[i].Dot(Nn[i]);
                RtFloat VdNg = Vn[i].Dot(Ngn[i]);
                RtFloat dot = fabs(VdNn);
                if ( RixSignum(VdNn) != RixSignum(VdNg) )
                    result = RtColorRGB(1, 0, 0);
                else
                    result = RtColorRGB(0, .5*dot, 0);

                int did = sCtx.integratorCtxIndex[i];
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_ST:
        {
            RtFloat2 const* st, defaultST(0.0f, 0.0f);
            RtFloat const* stRadius;
            sCtx.GetPrimVar("st", defaultST, &st, &stRadius);
            for(int i = 0; i < numPts; i++)
            {
                result = RtColorRGB(st[i].x,st[i].y,0);
                int did = sCtx.integratorCtxIndex[i];
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        }
        case k_dsdu_dtdv:
        {
            const char *paramSpace = "st";
            RtFloat2 const* stIn;
            RtFloat const *dsdu;
            RtFloat const *dtdu;
            RtFloat const *dsdv;
            RtFloat const *dtdv;
            sCtx.GetPrimVar(paramSpace, &stIn,
                            &dsdu, &dtdu, &dsdv, &dtdv);
            for(int i = 0; i < numPts; i++)
            {
                result = RtColorRGB((5.f * dsdu[i])+.5f,     
                                    (5.f * dtdv[i])+.5f, 0.f);
                int did = sCtx.integratorCtxIndex[i];
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        }
        case k_dsdv_dtdu:
        {
            const char *paramSpace = "st";
            RtFloat2 const* stIn;
            RtFloat const *dsdu;
            RtFloat const *dtdu;
            RtFloat const *dsdv;
            RtFloat const *dtdv;
            sCtx.GetPrimVar(paramSpace, &stIn,
                            &dsdu, &dtdu, &dsdv, &dtdv);
            for(int i = 0; i < numPts; i++)
            {
                result = RtColorRGB((5.f * dsdv[i])+.5f,     
                                    (5.f * dtdu[i])+.5f, 0.f);
                int did = sCtx.integratorCtxIndex[i];
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        }
        case k_UV:
        {
            for(int i = 0; i < numPts; i++)
            {
                result = RtColorRGB(u[i], v[i], 0);
                int did = sCtx.integratorCtxIndex[i];
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        }
        case k_dudv:
        {
            for(int i = 0; i < numPts; i++)
            {
                result = RtColorRGB(du[i], dv[i], 0);
                int did = sCtx.integratorCtxIndex[i];
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        }
        case k_P:
            for(int i = 0; i < numPts; i++)
            {
                int did = sCtx.integratorCtxIndex[i];
                result = RtColorRGB(P[i], true);
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_Po:
            for(int i = 0; i < numPts; i++)
            {
                int did = sCtx.integratorCtxIndex[i];
                result = RtColorRGB(Po[i], true);
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_dPdu:
            RtVector3 const* dPdu;
            sCtx.GetBuiltinVar(RixShadingContext::k_dPdu, &dPdu);
            for(int i = 0; i < numPts; i++)
            {
                int did = sCtx.integratorCtxIndex[i];
                result = RtColorRGB(dPdu[i], true);
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_dPdv:
            RtVector3 const* dPdv;
            sCtx.GetBuiltinVar(RixShadingContext::k_dPdv, &dPdv);
            for(int i = 0; i < numPts; i++)
            {
                int did = sCtx.integratorCtxIndex[i];
                result = RtColorRGB(dPdv[i], true);
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_dPdtime:
            RtVector3 const* dPdtime;
            sCtx.GetBuiltinVar(RixShadingContext::k_dPdtime, &dPdtime);
            for(int i = 0; i < numPts; i++)
            {
                int did = sCtx.integratorCtxIndex[i];
                result = RtColorRGB(dPdtime[i], true);
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_Id:
            RtInt const* id;
            sCtx.GetBuiltinVar(RixShadingContext::k_Id, &id);
            for(int i = 0; i < numPts; i++)
            {
                int did = sCtx.integratorCtxIndex[i];
                result = RtColorRGB(id[i]);
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_Ngn:
            for(int i = 0; i < numPts; i++)
            {
                int did = sCtx.integratorCtxIndex[i];
                result = RtColorRGB(Ngn[i], true);
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        case k_Non:
            for(int i = 0; i < numPts; i++)
            {
                int did = sCtx.integratorCtxIndex[i];
                result = RtColorRGB(Non[i], true);
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
        default:
            result = RtColorRGB(0.f, 0.f, 0.f);
            for(int i = 0; i < numPts; i++) 
            {
                int did = sCtx.integratorCtxIndex[i];
                displaySvc->Splat(m_ciChan, did, result * sCtx.transmission[i]);
            }
            break;
    }

    for(int i = 0; i < numPts; i++) 
    {
        int did = sCtx.integratorCtxIndex[i];
        displaySvc->WriteOpacity(m_ciChan, did, 1.0f);
    }
}

void
PxrDebugShadingContext::Integrate(RtInt ngrps, 
                                  RixShadingContext const *shadeGrps[],
                                  RixIntegratorContext &iCtx)
{
    for(int g = 0; g < ngrps; g++) 
    {
        RixShadingContext const &sCtx = *shadeGrps[g];
        if (sCtx.HasHits())
            integrateHelper(iCtx, sCtx);
    }

    if (m_geoAovIds)
    {
        RixDisplayServices *displaySvc = iCtx.GetDisplayServices();
        RtFloat3 *geoAovColor = NULL;
        RtFloat  *geoAovFloat = NULL;
        geoAovColor = new RtFloat3[m_maxShadingCtxSize];
        if (PxrGeoAOV::NeedTempFloat(m_geoAovIds))
            geoAovFloat = new RtFloat[m_maxShadingCtxSize];
        PxrGeoAOV::Splat(ngrps,
            shadeGrps,
            displaySvc, geoAovColor,
            geoAovFloat, m_geoAovIds);
        delete[] geoAovColor;
        delete[] geoAovFloat;
    }
}

RIX_INTEGRATORCREATE
{
    return new PxrDebugShadingContext();
}

RIX_INTEGRATORDESTROY
{
    delete ((PxrDebugShadingContext*)integrator);
}
