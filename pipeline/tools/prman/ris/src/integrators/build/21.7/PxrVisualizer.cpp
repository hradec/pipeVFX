/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2016 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

/* $Revision: #9 $ */

#include "RixIntegrator.h"
#include "RixBxdf.h"
#include "RixShadingUtils.h"
#include "PxrGeoAovs.h"
#include "RixRNG.h"
#include <cassert>
#include <cstring>



static PRMAN_INLINE void
pxrsRGBLinearize(int nch, float *inout)
{
    while (nch--)
    {
        if (*inout < .04045f)
            *inout = *inout * .07739938f;
        else
            *inout = powf((*inout+.055f)*0.947867299f, 2.4f);
        inout++;
    }
}


class PxrVisualizer : public RixIntegrator
{
public:

    PxrVisualizer();
    virtual ~PxrVisualizer();

    virtual int Init(RixContext &, char const *pluginpath);
    virtual RixSCParamInfo const *GetParamTable();
    virtual void Finalize(RixContext &);

    virtual void RenderBegin(RixContext &ctx, RixIntegratorEnvironment &env,
                             RixParameterList const *);
    virtual void RenderEnd(RixContext &ctx);

    virtual void Integrate(RtInt ngrps, RixShadingContext const *shadeGrps[],
                           RixIntegratorContext &ictx);

    enum
    {
        k_bxdf=0,
        k_shaded,
        k_flat,
        k_normals,
        k_st,
        k_matcap
    } m_style;
    RtConstString m_matCapFile;
    RtInt m_wireframe;
    RtColorRGB m_wireColor;
    RtFloat m_wireOpacity;
    RtFloat m_wireWidth;
    RtInt m_normalCheck;
    RtInt *m_geoAovIds;

private:
    class Worker
    {
    public:
        Worker(PxrVisualizer const &master);
        ~Worker();
        virtual void Integrate(int numGrps,
                               RixShadingContext const *shadeCtxs[],
                               RixIntegratorContext &ictx);
    private:
        PxrVisualizer const &m_master;
        RixRNG::SampleCtx *m_smpCtx;
        RixBXLobeTraits *m_lobesWanted;
        RixBXLobeTraits *m_lobesEvaluated;
        RtColorRGB *m_diffusePtrs[k_RixBXMaxNumDiffuseLobes];
        RtColorRGB *m_specularPtrs[k_RixBXMaxNumSpecularLobes];
        RtColorRGB *m_userPtrs[k_RixBXMaxNumUserLobes];
        RtVector3 *m_On;
        float *m_FPdf;
        float *m_RPdf;
        RtFloat3 *m_geoAovColor;
        float *m_geoAovFloat;
    };

    RixMessages *m_msgs;
    RixTexture *m_tex;
    RixShadeFunctions *m_sFuncs;
    RixChannelId m_ciChan;
    RtInt m_maxShadingCtxSize;
    bool m_interactive;
    std::vector<Worker*> m_allWorkers;
    RixMutex *m_allWorkersMutex;

};

PxrVisualizer::PxrVisualizer()
    :
    m_style(k_shaded)
    , m_matCapFile(NULL)
    , m_wireframe(1)
    , m_wireColor(0.f, 0.f, 0.f)
    , m_wireOpacity(0.5f)
    , m_wireWidth(1.0f)
    , m_normalCheck(0)
    , m_geoAovIds(NULL)
    , m_msgs(NULL)
    , m_tex(NULL)
    , m_sFuncs(NULL)
    , m_maxShadingCtxSize(1024)
    , m_interactive(false)
    , m_allWorkersMutex(NULL)
{
}

PxrVisualizer::~PxrVisualizer()
{
    delete[] m_geoAovIds;
    m_geoAovIds = NULL;
}

int
PxrVisualizer::Init(RixContext &ctx, char const *pluginpath)
{
    // Setup any shared resources. These are global pointers that can be shared
    // across threads.
    m_msgs = (RixMessages*) ctx.GetRixInterface(k_RixMessages);
    m_sFuncs = (RixShadeFunctions*)ctx.GetRixInterface(k_RixShadeFunctions);
    m_tex = (RixTexture*)ctx.GetRixInterface(k_RixTexture);
    if (RixThreadUtils *threadUtils =
        (RixThreadUtils*) ctx.GetRixInterface(k_RixThreadUtils))
    {
        m_allWorkersMutex = threadUtils->NewMutex();
    }

    // detect an interactive rendering session, as we need to do more work
    // in matcap style.
    RixRenderState *rstate =
                    (RixRenderState *) ctx.GetRixInterface(k_RixRenderState);
    if (rstate)
    {
        RixRenderState::FrameInfo finfo;
        rstate->GetFrameInfo(&finfo);
        m_interactive = finfo.rerendering;
    }

    return 0;
}

RixSCParamInfo const *
PxrVisualizer::GetParamTable()
{
    static RixSCParamInfo s_ptable[] =
    {
        // currently no inputs
        RixSCParamInfo("wireframe", k_RixSCInteger),
        RixSCParamInfo("style", k_RixSCString),
        RixSCParamInfo("normalCheck", k_RixSCInteger),
        RixSCParamInfo("matCap", k_RixSCString),
        RixSCParamInfo("wireframeColor", k_RixSCColor),
        RixSCParamInfo("wireframeOpacity", k_RixSCFloat),
        RixSCParamInfo("wireframeWidth", k_RixSCFloat),

        RixSCParamInfo() // end of table
    };
    return &s_ptable[0];
}

void
PxrVisualizer::Finalize(RixContext &ctx)
{
}

void
PxrVisualizer::RenderBegin(RixContext &ctx, RixIntegratorEnvironment &env,
                        RixParameterList const *plist)
{
    // no parameters expected/supported...
    RtInt paramId;
    char const *inm = "PxrVisualizer";
    char const *pnm;
    pnm = "wireframe";
    if (0 == plist->GetParamId(pnm, &paramId))
    {
        if (plist->EvalParam(paramId, 0, &m_wireframe) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "normalCheck";
    if (0 == plist->GetParamId(pnm, &paramId))
    {
        if (plist->EvalParam(paramId, 0, &m_normalCheck) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    RtConstString style = "bxdf";
    pnm = "style";
    if (0 == plist->GetParamId(pnm, &paramId))
    {
        if (plist->EvalParam(paramId, 0, &style) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);

        if (!strcmp(style,"bxdf"))
            m_style = k_bxdf;
        else if (!strcmp(style,"shaded"))
            m_style = k_shaded;
        else if (!strcmp(style,"normals"))
            m_style = k_normals;
        else if (!strcmp(style,"st"))
            m_style = k_st;
        else if (!strcmp(style,"flat"))
            m_style = k_flat;
        else
            m_style = k_matcap;
    }

    pnm = "matCap";
    if (0 == plist->GetParamId(pnm, &paramId))
    {
        if (plist->EvalParam(paramId, 0, &m_matCapFile) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "wireframeColor";
    if (0 == plist->GetParamId(pnm, &paramId))
    {
        if (plist->EvalParam(paramId, 0, &m_wireColor) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "wireframeOpacity";
    if (0 == plist->GetParamId(pnm, &paramId))
    {
        if (plist->EvalParam(paramId, 0, &m_wireOpacity) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "wireframeWidth";
    if (0 == plist->GetParamId(pnm, &paramId))
    {
        if (plist->EvalParam(paramId, 0, &m_wireWidth) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    for (int index = 0; index < env.numDisplays; ++index)
    {
        if (!strcmp("Ci", env.displays[index].channel))
            m_ciChan = env.displays[index].id;
    }

    m_maxShadingCtxSize = env.maxShadingCtxSize;

    // Get the list of requested geometric AOVs
    if (!PxrGeoAOV::disableIntegratorAOVs(ctx, m_geoAovIds))
    {
        PxrGeoAOV::GetChannelIds(env, m_geoAovIds);
    }
}

void
PxrVisualizer::RenderEnd(RixContext &ctx)
{
}

void
PxrVisualizer::Integrate(RtInt nGroups, RixShadingContext const *shadeGrps[],
                      RixIntegratorContext &iCtx)
{
    // Get or create per-thread worker for integration
    static const char k_workerKey[] = "PxrVisualizerWorker";
    RixStorage *storage = static_cast<RixStorage*>(iCtx.GetRixInterface(k_RixThreadData));
    Worker *worker = (static_cast<Worker*>(storage->Get(k_workerKey)));
    if (worker == NULL)
    {
        worker = new Worker(*this);
        storage->Set(k_workerKey, worker, NULL);
        if (m_allWorkersMutex)
        {
            m_allWorkersMutex->Lock();
            m_allWorkers.push_back(worker);
            m_allWorkersMutex->Unlock();
        }
    }
    worker->Integrate(nGroups, shadeGrps, iCtx);
}

PxrVisualizer::Worker::Worker(PxrVisualizer const &master):
    m_master(master)
    , m_lobesWanted(NULL)
    , m_lobesEvaluated(NULL)
    , m_On(NULL)
    , m_FPdf(NULL)
    , m_RPdf(NULL)
    , m_geoAovColor(NULL)
    , m_geoAovFloat(NULL)
{
    m_smpCtx = new RixRNG::SampleCtx[m_master.m_maxShadingCtxSize];

    m_lobesWanted = new RixBXLobeTraits[m_master.m_maxShadingCtxSize];
    for (int i = 0; i < m_master.m_maxShadingCtxSize; ++i)
        m_lobesWanted[i] = k_RixBXTraitsAllReflect;
    m_lobesEvaluated = new RixBXLobeTraits[m_master.m_maxShadingCtxSize];

    for (int i = 0; i < k_RixBXMaxNumDiffuseLobes; ++i)
        m_diffusePtrs[i] = new RtColorRGB[m_master.m_maxShadingCtxSize];
    for (int i = 0; i < k_RixBXMaxNumSpecularLobes; ++i)
        m_specularPtrs[i] = new RtColorRGB[m_master.m_maxShadingCtxSize];
    for (int i = 0; i < k_RixBXMaxNumUserLobes; ++i)
        m_userPtrs[i] = new RtColorRGB[m_master.m_maxShadingCtxSize];

    m_On = new RtVector3[m_master.m_maxShadingCtxSize];
    m_FPdf = new float[m_master.m_maxShadingCtxSize];
    m_RPdf = new float[m_master.m_maxShadingCtxSize];

    if (m_master.m_geoAovIds)
    {
        m_geoAovColor = new RtFloat3[m_master.m_maxShadingCtxSize];
        if (PxrGeoAOV::NeedTempFloat(m_master.m_geoAovIds))
            m_geoAovFloat = new float[m_master.m_maxShadingCtxSize];
    }
}

PxrVisualizer::Worker::~Worker()
{
    delete[] m_smpCtx;
    delete[] m_lobesWanted;
    delete[] m_lobesEvaluated;
    for (int i = 0; i < k_RixBXMaxNumDiffuseLobes; ++i)
        delete[] m_diffusePtrs[i];
    for (int i = 0; i < k_RixBXMaxNumSpecularLobes; ++i)
        delete[] m_specularPtrs[i];
    for (int i = 0; i < k_RixBXMaxNumUserLobes; ++i)
        delete[] m_userPtrs[i];
    delete[] m_On;
    delete[] m_FPdf;
    delete[] m_RPdf;
    delete[] m_geoAovColor;
    delete[] m_geoAovFloat;
}

void
PxrVisualizer::Worker::Integrate(
    int nGroups,
    RixShadingContext const *shadeGrps[],
    RixIntegratorContext &iCtx)
{
    RixDisplayServices *displaySvc = iCtx.GetDisplayServices();

    // initialize random number generator. We only shoot one sample per point,
    // ie. path splitting factor 1.
    static const unsigned k_rngDomain = 0xf88bce9;
    RixRNG rng(iCtx.rngCtx, m_smpCtx, k_rngDomain, 1); // no split, no distrib

    for (int g = 0; g < nGroups; g++)
    {
        RixShadingContext const &sCtx = *shadeGrps[g];
        RixBxdf &bxdf = *(sCtx.GetBxdf());
        RtVector3 const* Vn;
        sCtx.GetBuiltinVar(RixShadingContext::k_Vn, &Vn);

        RtFloat const *u;
        RtFloat const *v;
        RtFloat const *du;
        RtFloat const *dv;
        if (m_master.m_wireframe)
        {
            RixSCDetail result = sCtx.GetPrimVar("u", 0.f, &u);
            if (result == k_RixSCInvalidDetail)
            {
                sCtx.GetBuiltinVar(RixShadingContext::k_u, &u);
            }
            result = sCtx.GetPrimVar("v", 0.f, &v);
            if (result == k_RixSCInvalidDetail)
            {
                sCtx.GetBuiltinVar(RixShadingContext::k_v, &v);
            }
            result = sCtx.GetPrimVar("du", 0.f, &du);
            if (result == k_RixSCInvalidDetail)
            {
                sCtx.GetBuiltinVar(RixShadingContext::k_du, &du);
            }
            result = sCtx.GetPrimVar("dv", 0.f, &dv);
            if (result == k_RixSCInvalidDetail)
            {
                sCtx.GetBuiltinVar(RixShadingContext::k_dv, &dv);
            }
        }

        RixShadingContext::Allocator m(&sCtx);
        RtNormal3 const *Nn;
        RtNormal3 *Nno;
        if (m_master.m_style == k_shaded ||
            m_master.m_style == k_normals ||
            m_master.m_style == k_matcap ||
            m_master.m_normalCheck != 0 )
        {
            sCtx.GetBuiltinVar(RixShadingContext::k_Nn, &Nn);
            if (m_master.m_style == k_normals)
            {
                Nno = m.Allocate<RtNormal3>(sCtx.numPts);
                for (int i=0; i<sCtx.numPts; i++)
                    Nno[i] = Nn[i];
                sCtx.Transform(RixShadingContext::k_AsNormals,
                               "current", "object", const_cast<RtFloat3*>(Nno));
            }
        }

        RtInt const *id;
        RtColorRGB flatColor(0.5f);
        if (m_master.m_style == k_flat)
        {
            sCtx.GetBuiltinVar(RixShadingContext::k_Id, &id);
            if (m_master.m_sFuncs)
                flatColor = (RtColorRGB)m_master.m_sFuncs->CellNoise3(
                                RtFloat3(id[0], id[0]+7.0f, id[0]+13.0f));
            // make sure color is not too dark
            RtFloat lum = flatColor.Luminance();
            if (lum < 0.25f)
            {
                if (lum <= 0.f)
                    flatColor = RtColorRGB(0.25f);
                else
                    flatColor *= 0.25f / lum;
            }
        }

        RtFloat2 const* st;
        if (m_master.m_style == k_st)
        {
            RtFloat2 defaultST(0.0f, 0.0f);
            sCtx.GetPrimVar("st", defaultST, &st);
        }

        // PxrConstant only returns values from EmitLocal()
        RtColorRGB *emit;
        RixBXActiveLobeWeights activeLobes;
        if (m_master.m_style == k_bxdf)
        {
            emit = m.Allocate<RtColorRGB>(sCtx.numPts);
            for (int i=0; i<sCtx.numPts; i++)
                emit[i] = RtColorRGB(0.f, 0.f, 0.f);
            bxdf.EmitLocal(emit);

            for (int i = 0; i < sCtx.numPts; i++)
                m_lobesWanted[i] = k_RixBXTraitsAllReflect;

            // set Light direction to be viewing dir
            for(int i = 0; i < sCtx.numPts; i++)
                m_On[i] = Vn[i];

            RixBXLobeWeights lw(sCtx.numPts,
                                k_RixBXMaxNumDiffuseLobes,
                                k_RixBXMaxNumSpecularLobes,
                                k_RixBXMaxNumUserLobes,
                                m_diffusePtrs,
                                m_specularPtrs,
                                m_userPtrs);

            bxdf.EvaluateSample(k_RixBXDirectLighting,
                                m_lobesWanted,
                                &rng,
                                m_lobesEvaluated,
                                m_On, lw, m_FPdf, m_RPdf);

            lw.GetActiveLobes(activeLobes);
        }

        RtColorRGB *matCapTex;
        if (m_master.m_style == k_matcap)
        {
            RtFloat2 *stOut;
            stOut = m.Allocate<RtFloat2>(sCtx.numPts);
            if (m_master.m_interactive)
            {
                // As named transforms are not updated in interactive mode,
                // we need to recompute N relative to the camera.
                // This not exact, but good enough for interactive.
                //
                RtFloat3 *N0 = m.Allocate<RtFloat3>(sCtx.numPts);

                for (int i=0; i<sCtx.numPts; i++)
                {
                    N0[i] = RtFloat3(0.f, 1.f, 0.f);
                }
                sCtx.Transform(RixShadingContext::k_AsVectors,
                               "world", "current", N0);

                for (int i=0; i<sCtx.numPts; i++)
                {
                    RtFloat3 up = NormalizeCopy(N0[i]);
                    RtFloat3 left = Vn[i].Cross(up);
                    up = Vn[i].Cross(left);
                    RtFloat3 n = NormalizeCopy(Nn[i]);
                    RtFloat nx = n.Dot(up);
                    RtFloat ny = n.Dot(left);
                    stOut[i].x = (1.0f+ny)*0.5f;
                    stOut[i].y = (1.0f+nx)*0.5f;
                }
            }
            else
            {
                RtFloat3 n;
                for (int i=0; i<sCtx.numPts; i++)
                {
                    n = NormalizeCopy(Nn[i]);
                    stOut[i].x = (1.0f+n.x)*0.5f;
                    stOut[i].y = 1.0f-((1.0f+n.y)*0.5f);
                }
            }

            // setup texture lookup
            RixTexture::TxProperties txProps;
            int err = m_master.m_tex->AcquireTexture(m_master.m_matCapFile, 
                                                     txProps);
            if (err)
            {
                matCapTex = NULL;
                m_master.m_msgs->Warning("PxrVisualizer: Failed to open "
                                         "MatCap texture: %s\n", 
                                         m_master.m_matCapFile);
            }
            else
            {
                matCapTex = m.Allocate<RtColorRGB>(sCtx.numPts);
                if (0)
                {
                    // debug: visualize mapping coordinates
                    for (int i=0; i<sCtx.numPts; i++)
                    {
                        matCapTex[i] = RtColorRGB(stOut[i].x, stOut[i].y,
                                                  stOut[i].x * stOut[i].y);
                    }
                }
                else
                {
                    RixTexture::TxParams txParams;

                    // Texture filtering
                    // We basically point sample, but still keep a box filter
                    // to make texel magnification less ugly.
                    //
                    RtFloat *zero = m.Allocate<RtFloat>(sCtx.numPts);
                    for (int i=0; i<sCtx.numPts; i++)
                    {
                        zero[i] = 1e-6f;
                    }
                    txParams.filter = RixTexture::TxParams::Box;
                    txParams.lerp = 0;

                    // handle color and monochrome files.
                    //
                    RtFloat* r = (RtFloat*)matCapTex;
                    txParams.firstchannel = 0;
                    if (txProps.nchannels >= 3)
                    {
                        r = (RtFloat*)matCapTex;
                        txParams.nchannels = 3;
                    }
                    else
                    {
                        r = (RtFloat*) m.Allocate<RtFloat>(sCtx.numPts);
                        txParams.nchannels = 1;
                    }

                    // texture lookup
                    //
                    m_master.m_tex->Texture(txProps, txParams, sCtx.numPts, 
                                            stOut, zero, r, NULL);

                    // linearise texture lookup
                    // We assume people use gamma-encoded images.
                    //
                    for (int j=0; j<sCtx.numPts; j++)
                    {
                        pxrsRGBLinearize(txParams.nchannels, r);
                        r += txParams.nchannels;
                    }
                }
            }
        }

        for (int i = 0; i < sCtx.numPts; i++)
        {
            int ctxIdx = sCtx.integratorCtxIndex[i];
            RixRNG::SampleCtx &sampleCtx = iCtx.rngCtx->GetSampleCtx(ctxIdx);
            m_smpCtx[i] = sampleCtx.NewDomain(k_rngDomain);

            RtColorRGB val(0.f);

            // set Ldir to be viewing dir
            RtVector3 const &lDir = Vn[i];

            if (m_master.m_style == k_bxdf)
            {
                val = emit[i];
                if (m_lobesEvaluated[i].HasAny())
                {
                    val += F_PI * activeLobes.SumAtIndex(i);
                }
            }
            else if (m_master.m_style == k_shaded)
            {
                val = RtColorRGB(RixMax(0.f, 
                                        fabsf(Dot(lDir, Nn[i])) * 0.7f + 0.025f));
            }
            else if (m_master.m_style == k_normals)
            {
                val = RtColorRGB( RixMax(0.f, Nno[i].x),
                                  RixMax(0.f, Nno[i].y),
                                  RixMax(0.f, Nno[i].z) );
            }
            else if (m_master.m_style == k_st)
            {
                val = RtColorRGB( RixFractional(st[i].x),
                                  RixFractional(st[i].y),
                                  0.f );
            }
            else if (m_master.m_style == k_flat)
            {
                val = flatColor;
            }
            else
            {
                if (matCapTex)
                {
                    val = matCapTex[i];
                }
            }

            if (m_master.m_normalCheck)
            {
                if (Dot(lDir, Nn[i]) < 0.f)
                    val = RtColorRGB( .8f, .3f, 0.f);
            }

            if (m_master.m_wireframe)
            {
                // by default, wire width is 1 pixel.
                #define LW 2.0f
                RtFloat wire = RixMax(
                                   RixBoxStep(u[i]<0.5f? u[i]:1.0f-u[i], 
                                              du[i]*LW*m_master.m_wireWidth),
                                   RixBoxStep(v[i]<0.5f? v[i]:1.0f-v[i], 
                                              dv[i]*LW*m_master.m_wireWidth)
                               );
                val = RixMix(val, m_master.m_wireColor, 
                             wire*m_master.m_wireOpacity);
            }

            displaySvc->Splat(m_master.m_ciChan, sCtx.integratorCtxIndex[i], val);
            displaySvc->WriteOpacity(m_master.m_ciChan, sCtx.integratorCtxIndex[i], 1.0f);
        }
    }

    if (m_master.m_geoAovIds)
    {
        PxrGeoAOV::Splat(nGroups, shadeGrps, displaySvc,
                         m_geoAovColor, m_geoAovFloat, m_master.m_geoAovIds);
    }
}

RIX_INTEGRATORCREATE
{
    return new PxrVisualizer();
}

RIX_INTEGRATORDESTROY
{
    delete ((PxrVisualizer*)integrator);
}
