/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2016 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include "RixIntegrator.h"
#include "RixLighting.h"
#include "RixBxdf.h"
#include "RixVolume.h"
#include <cstdio>

#ifndef PxrVolumeAggregate_H
#define PxrVolumeAggregate_H

class PxrVolumeAggregate
{
public:
    PxrVolumeAggregate(RtConstString name,
                       RixIntegratorContext& iCtx,
                       RixVolumeIntegrator::IntegratorDelegate* delegate,
                       int maxSampleCount)
        : m_name(name),
          m_integratorContext(iCtx),
          m_volumeServices(iCtx.GetVolumeServices()),
          m_maxSampleCount(maxSampleCount),
          m_shadingContexts(0),
          m_minTransmission(0.0f),
          m_deltaTracking(false)
    {
    }

    ~PxrVolumeAggregate()
    {
        delete[] m_shadingContexts;
    }

    void MultiScatter(int numRays, RtRayGeometry const* rays,
        RixRNG* rng, int *numShadingContexts,
        RixShadingContext const ** shadingContexts,
        int* newNumRays, RtRayGeometry* newRays)
    {
        int i, j;
        
        // Make a copy of the rays and shoot them to probe the
        // distance
        RtRayGeometry* localRays = new RtRayGeometry[numRays];
        RtHitPoint* hits = new RtHitPoint[numRays];
        memcpy(localRays, rays, numRays * sizeof(RtRayGeometry));
        m_integratorContext.GetNearestHits(numRays, localRays, hits);

        // Adjust the distance of the rays to match the hits.
        // Renumber the rayids of the localRays passed to the volume
        // aggregate.
        for (i = 0; i < numRays; ++i)
        {
            if (hits[i].dist != 0.0f)
            {
                localRays[i].maxDist = hits[i].dist;
            }
            localRays[i].rayId = i;
        }
        delete[] hits;
        
        RixVolumeAggregate* aggregate = m_volumeServices->GetAggregate(m_name, numRays, localRays);
        if (!aggregate)
        {
            delete[] localRays;
            *newNumRays = numRays;
            memcpy(newRays, rays, numRays * sizeof(RtRayGeometry));
            return;
        }

        bool allfinished = false;
        int* nsteps = new int[numRays];
        RixVolumeAggregateIterator** iterators =
            new RixVolumeAggregateIterator *[numRays];
        bool* scattered = new bool[numRays];
        float* densities = new float[numRays];

        for (i = 0; i < numRays; ++i)
        {
            nsteps[i] = 0;
            iterators[i] = aggregate->CreateIterator(i);
            scattered[i] = false;
        }

        while (!allfinished)
        {
            allfinished = true;

            for (i = 0; i < numRays; ++i)
            {
                RixVolumeAggregateIterator* it = iterators[i];
                if (it->finished) continue;

                bool advanced;
                do
                {
                    // Woodcock track
                    float maxDensity = std::max(0.0f, it->GetMaxDensity());
                    float distance = 0.0f;
                    if (maxDensity == 0.0f)
                        distance = 1e30f;
                    else
                    {
                        RixRNG::SampleCtx drng = rng->NewDomain(i, 
                            0xed426c5c + nsteps[i]);
                        float xi = rng->GenerateSample1D(i, drng);
                        distance = -logf(1.0f - xi) / maxDensity;
                    }
                    nsteps[i]++;

                    do
                    {
                        advanced = it->Advance(distance);
                        if (!it->finished)
                        {
                            if (!advanced)
                            {
                                maxDensity = std::max(0.0f, it->GetMaxDensity());
                                if (maxDensity == 0.0f)
                                {
                                    distance = 1e30f;
                                }
                                else
                                {
                                    allfinished = false;
                                }
                            }
                            else
                            {
                                allfinished = false;
                            }
                        }
                    } while (!it->finished && maxDensity == 0.0f);
                }
                while (!it->finished && !advanced);
            }

            if (!allfinished)
            {
                aggregate->ComputeDensity(iterators, densities);
                for (i = 0; i < numRays; ++i)
                {
                    RixVolumeAggregateIterator* it = iterators[i];
                    if (it->finished) continue;

                    float maxDensity = std::max(0.0f, it->GetMaxDensity());
                    bool terminates = false;
                    if (maxDensity != 0.0f && densities[i] > 0.0f)
                    {
                        RixRNG::SampleCtx drng = rng->NewDomain(i,
                            0x889c14d4 + nsteps[i]);
                        float xi = rng->GenerateSample1D(i, drng);
                        float fDensity = densities[i] / maxDensity;
                        fDensity = std::min(fDensity, 1.0f);
                        terminates = (fDensity > xi);

                        // Upon first termination of the sample,
                        // get a scatter location
                        if (terminates)
                        {
                            scattered[i] = true;
                            it->finished = true;
                        }
                    }
                }
            }
        }

        // We're done with the iterators. Go back and mark the ones
        // that scattered as being not finished in order to get the
        // right points back from CreateScatterContexts
        for (i = 0; i < numRays; ++i)
        {
            iterators[i]->finished = !scattered[i];
        }

        int nShadingContexts = 0;
        if (!m_shadingContexts)
            m_shadingContexts = new RixShadingContext*[m_maxSampleCount];
        aggregate->CreateScatterContexts(iterators,
            &nShadingContexts, m_shadingContexts);

        if (nShadingContexts == 0)
        {
            *newNumRays = numRays;
            memcpy(newRays, rays, numRays * sizeof(RtRayGeometry));
        }
        else if (nShadingContexts == 1)
        {
            // Simpler case: there's no possibility of any volume overlap.
            RtInt* membership = new RtInt[m_shadingContexts[0]->numPts];
            bool* rayhit = new bool[numRays];
            memset(rayhit, 0, sizeof(bool) * numRays);
            RtFloat const *u, *v, *w;
            RixShadingContext* vCtx = m_shadingContexts[0];
            RixVolumeIntegrator* volInt = vCtx->scTraits.volume;
            RixSCDetail detail;   
            void const * property;
            bool useColor = false;
            vCtx->GetBuiltinVar(RixShadingContext::k_u, &u);
            vCtx->GetBuiltinVar(RixShadingContext::k_v, &v);
            vCtx->GetBuiltinVar(RixShadingContext::k_w, &w);
            detail = volInt->GetProperty(RixVolumeIntegrator::k_DensityType, &property);
            if (detail != k_RixSCInvalidDetail)
            {
                useColor =
                    (*(int const *) property) == RixVolumeIntegrator::k_DensityColor;
            }
            if (useColor)
            {
                detail = volInt->GetProperty(RixVolumeIntegrator::k_DensityColor,
                    &property);
                if (detail != k_RixSCInvalidDetail)
                {
                    RtColorRGB const *densityColor =
                        (RtColorRGB const *) property;
                    if (detail == k_RixSCUniform)
                    {
                        RtColorRGB density = clampToZero(densityColor[0]);
                        float fDensity = density.ChannelAvg();
                        for (j = 0; j < vCtx->numPts; ++j)
                        {
                            if (u[j] < 0.0f || u[j] > 1.0f ||
                                v[j] < 0.0f || v[j] > 1.0f ||
                                w[j] < 0.0f || w[j] > 1.0f ||
                                fDensity <= 0.0f)
                            {
                                membership[j] = false;
                            }
                            else 
                            {
                                membership[j] = true;
                                rayhit[vCtx->rayId[j]] = true;
                            }
                        }
                    }
                    else
                    {
                        for (j = 0; j < vCtx->numPts; ++j)
                        {
                            if (u[j] < 0.0f || u[j] > 1.0f ||
                                v[j] < 0.0f || v[j] > 1.0f ||
                                w[j] < 0.0f || w[j] > 1.0f)
                            {
                                membership[j] = false;
                            }
                            else
                            {
                                float fDensity = clampToZero(densityColor[j]).ChannelAvg();
                                if (fDensity <= 0.0f)
                                {
                                    membership[j] = false;
                                }
                                else 
                                {
                                    membership[j] = true;
                                    rayhit[vCtx->rayId[j]] = true;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                detail = volInt->GetProperty(RixVolumeIntegrator::k_DensityFloat,
                    &property);
                if (detail != k_RixSCInvalidDetail)
                {
                    RtFloat const *densityFloat =
                        (RtFloat const *) property;
                    if (detail == k_RixSCUniform)
                    {
                        float density = std::max(densityFloat[0], 0.0f);
                        for (j = 0; j < vCtx->numPts; ++j)
                        {
                            if (u[j] < 0.0f || u[j] > 1.0f ||
                                v[j] < 0.0f || v[j] > 1.0f ||
                                w[j] < 0.0f || w[j] > 1.0f ||
                                density <= 0.0f)
                            {
                                membership[j] = false;
                            }
                            else
                            {
                                membership[j] = true;
                                rayhit[vCtx->rayId[j]] = true;
                            }
                        }
                    }
                    else
                    {
                        for (j = 0; j < vCtx->numPts; ++j)
                        {
                            if (u[j] < 0.0f || u[j] > 1.0f ||
                                v[j] < 0.0f || v[j] > 1.0f ||
                                w[j] < 0.0f || w[j] > 1.0f)
                            {
                                membership[j] = false;
                            }
                            else
                            {
                                float density = std::max(densityFloat[j], 0.0f);
                                if (density <= 0.0f)
                                {
                                    membership[j] = false;
                                }
                                else 
                                {
                                    membership[j] = true;
                                    rayhit[vCtx->rayId[j]] = true;
                                }
                            }
                        }
                    }
                }
            }
            for (j = 0; j < vCtx->numPts; ++j)
            {
                vCtx->pointWeight[j] = 1.0f;
                // Make sure the rayId we pass out match the rays
                // that were passed in
                vCtx->rayId[j] = rays[vCtx->rayId[j]].rayId;
            }
            aggregate->ReleaseScatterContexts(nShadingContexts,
                m_shadingContexts,
                &k_RixBXTraitsAllLobe, &membership,
                numShadingContexts,
                shadingContexts);
            *newNumRays = 0;
            for (i = 0; i < numRays; ++i)
            {
                if (!rayhit[i])
                {
                    newRays[*newNumRays] = rays[i];
                    *newNumRays = *newNumRays + 1;
                }
            }
            delete[] membership;
            delete[] rayhit;
        }
        else if (nShadingContexts > 1)
        {
            RtInt** membership = new RtInt*[nShadingContexts];
            float* densitySum = new float[numRays];
            memset(densitySum, 0, numRays * sizeof(float));
            float* cdfs = new float[numRays * nShadingContexts];
            memset(cdfs, 0, numRays * nShadingContexts * sizeof(float));
                
            for (i = 0; i < nShadingContexts; ++i)
            {
                RtFloat const *u, *v, *w;
                RixShadingContext* vCtx = m_shadingContexts[i];
                RixVolumeIntegrator* volInt = vCtx->scTraits.volume;
                RixSCDetail detail;   
                void const * property;
                bool useColor = false;
                membership[i] = new RtInt[vCtx->numPts];
                vCtx->GetBuiltinVar(RixShadingContext::k_u, &u);
                vCtx->GetBuiltinVar(RixShadingContext::k_v, &v);
                vCtx->GetBuiltinVar(RixShadingContext::k_w, &w);
                detail = volInt->GetProperty(RixVolumeIntegrator::k_DensityType, &property);
                if (detail != k_RixSCInvalidDetail)
                {
                    useColor =
                        (*(int const *) property) == RixVolumeIntegrator::k_DensityColor;
                }
                if (useColor)
                {
                    detail = volInt->GetProperty(RixVolumeIntegrator::k_DensityColor,
                        &property);
                    if (detail != k_RixSCInvalidDetail)
                    {
                        RtColorRGB const *densityColor =
                            (RtColorRGB const *) property;
                        if (detail == k_RixSCUniform)
                        {
                            RtColorRGB density = clampToZero(densityColor[0]);
                            float fDensity = density.ChannelAvg();
                            for (j = 0; j < vCtx->numPts; ++j)
                            {
                                if (u[j] < 0.0f || u[j] > 1.0f ||
                                    v[j] < 0.0f || v[j] > 1.0f ||
                                    w[j] < 0.0f || w[j] > 1.0f) continue;
                                int rayId = vCtx->rayId[j];
                                densitySum[rayId] += fDensity;
                                cdfs[rayId * nShadingContexts + i] = fDensity;
                            }
                        }
                        else
                        {
                            for (j = 0; j < vCtx->numPts; ++j)
                            {
                                if (u[j] < 0.0f || u[j] > 1.0f ||
                                    v[j] < 0.0f || v[j] > 1.0f ||
                                    w[j] < 0.0f || w[j] > 1.0f) continue;
                                float fDensity = clampToZero(densityColor[j]).ChannelAvg();
                                int rayId = vCtx->rayId[j];
                                densitySum[rayId] += fDensity;
                                cdfs[rayId * nShadingContexts + i] = fDensity;
                            }
                        }
                    }
                }
                else
                {
                    detail = volInt->GetProperty(RixVolumeIntegrator::k_DensityFloat,
                        &property);
                    if (detail != k_RixSCInvalidDetail)
                    {
                        RtFloat const *densityFloat =
                            (RtFloat const *) property;
                        if (detail == k_RixSCUniform)
                        {
                            float density = std::max(densityFloat[0], 0.0f);
                            for (j = 0; j < vCtx->numPts; ++j)
                            {
                                if (u[j] < 0.0f || u[j] > 1.0f ||
                                    v[j] < 0.0f || v[j] > 1.0f ||
                                    w[j] < 0.0f || w[j] > 1.0f) continue;
                                int rayId = vCtx->rayId[j];
                                densitySum[rayId] += density;
                                cdfs[rayId * nShadingContexts + i] = density;
                            }
                        }
                        else
                        {
                            for (j = 0; j < vCtx->numPts; ++j)
                            {
                                if (u[j] < 0.0f || u[j] > 1.0f ||
                                    v[j] < 0.0f || v[j] > 1.0f ||
                                    w[j] < 0.0f || w[j] > 1.0f) continue;
                                float density = std::max(densityFloat[j], 0.0f);
                                int rayId = vCtx->rayId[j];
                                densitySum[rayId] += density;
                                cdfs[rayId * nShadingContexts + i] = density;
                            }
                        }
                    }
                }
            }
            int* densityPick = (int *) densitySum;
            for (i = 0; i < numRays; ++i)
            {
                if (densitySum[i] <= 0.0f)
                {
                    densityPick[i] = -1;
                    continue;
                }
                float* cdf = &cdfs[i * nShadingContexts];
                float total = 0.0f;
                for (j = 0; j < nShadingContexts - 1; ++j)
                {
                    total += cdf[j];
                    cdf[j] = total / densitySum[i];
                }
                cdf[nShadingContexts - 1] = 1e30f;
                RixRNG::SampleCtx drng = rng->NewDomain(i, 0xba6b5d84);
                float xi = rng->GenerateSample1D(i, drng);
                for (j = 0; j < nShadingContexts; ++j)
                {
                    if (cdf[j] > xi)
                    {
                        densityPick[i] = j;
                        break;
                    }
                }
            }
            for (i = 0; i < nShadingContexts; ++i)
            {
                RixShadingContext* vCtx = m_shadingContexts[i];
                for (j = 0; j < vCtx->numPts; ++j)
                {
                    vCtx->pointWeight[j] = 1.0f;
                    if (densityPick[vCtx->rayId[j]] == i)
                    {
                        membership[i][j] = true;
                    }
                    else
                    {
                        membership[i][j] = false;
                    }
                    // Make sure the rayId we pass out match the rays
                    // that were passed in
                    vCtx->rayId[j] = rays[vCtx->rayId[j]].rayId;
                }
            }
            aggregate->ReleaseScatterContexts(nShadingContexts,
                m_shadingContexts,
                &k_RixBXTraitsAllLobe, membership,
                numShadingContexts,
                shadingContexts);
            *newNumRays = 0;
            for (i = 0; i < numRays; ++i)
            {
                if (densityPick[i] < 0)
                {
                    densityPick[i] = -1;
                    newRays[*newNumRays] = rays[i];
                    *newNumRays = *newNumRays + 1;
                }
            }
            for (i = 0; i < nShadingContexts; ++i)
            {
                delete[] membership[i];
            }
            delete[] membership;
            delete[] cdfs;
            delete[] densitySum;
        }
        for (i = 0; i < numRays; ++i)
        {
            delete iterators[i];
        }
        delete aggregate;
        delete[] scattered;
        delete[] nsteps;
        delete[] iterators;
        delete[] densities;
        delete[] localRays;
    }
    
    void GetTransmission(int numRays, RtRayGeometry const *rays,
                         RixRNG* rng, RtColorRGB* trans)
    {
        RixVolumeAggregate* aggregate = m_volumeServices->GetAggregate(m_name, numRays, rays);
        if (!aggregate)
        {
            return;
        }

        if (!m_shadingContexts)
            m_shadingContexts = new RixShadingContext* [m_maxSampleCount];

        bool allfinished = false;

        int* nsteps = new int[numRays];
        float* accumTrans = new float[numRays];
        RixVolumeAggregateIterator** densityIterators = new RixVolumeAggregateIterator *[numRays];
        float* densities = new float[numRays];
        int i;

        for (i = 0; i < numRays; ++i)
        {
            nsteps[i] = 0;
            accumTrans[i] = 1.0f;
            densityIterators[i] = aggregate->CreateIterator(i);
        }

        while (!allfinished)
        {
            allfinished = true;

            for (i = 0; i < numRays; ++i)
            {
                RixVolumeAggregateIterator* it = densityIterators[i];
                if (it->finished) continue;

                bool advanced;
                do
                {
                    // Woodcock track
                    float maxDensity = std::max(0.0f, it->GetMaxDensity());
                    float distance = 0.0f;
                    if (maxDensity == 0.0f)
                        distance = 1e30f;
                    else
                    {
                        float xi;
                        RixRNG::SampleCtx drng = rng->NewDomain(rays[i].rayId, 
                            0x981ee2f0 + nsteps[i]);
                        if (nsteps[i] == 0)
                        {
                            xi = rng->GenerateSample1D(rays[i].rayId, drng);
                        }
                        else
                        {
                            xi = RixRNGUtils::HashToRandom(drng.sampleid, drng.patternid * 0xdfbe7a3f);
                        }
                        distance = -logf(1.0f - xi) / maxDensity;
                    }
                    nsteps[i]++;

                    do
                    {
                        advanced = it->Advance(distance);
                        if (!it->finished)
                        {
                            if (!advanced)
                            {
                                maxDensity = std::max(0.0f, it->GetMaxDensity());
                                if (maxDensity == 0.0f)
                                {
                                    distance = 1e30f;
                                }
                                else
                                {
                                    allfinished = false;
                                }
                            }
                            else
                            {
                                allfinished = false;
                            }
                        }
                    } while (!it->finished && maxDensity == 0.0f);
                }
                while (!it->finished && !advanced);
            }

            if (!allfinished)
            {
                aggregate->ComputeDensity(densityIterators, densities);
                for (i = 0; i < numRays; ++i)
                {
                    RixVolumeAggregateIterator* it = densityIterators[i];
                    if (it->finished) continue;

                    float maxDensity = std::max(0.0f, it->GetMaxDensity());
                    bool terminates = false;
                    if (maxDensity != 0.0f)
                    {
                        float xi;
                        RixRNG::SampleCtx drng = rng->NewDomain(rays[i].rayId,
                            0x0dd26c21 + nsteps[i]);
                        if (nsteps[i] == 0)
                        {
                            xi = rng->GenerateSample1D(rays[i].rayId, drng);
                        }
                        else
                        {
                            xi = RixRNGUtils::HashToRandom(drng.sampleid, drng.patternid * 0xdfbe7a3f);
                        }
                        float fDensity = densities[i] / maxDensity;
                        fDensity = std::min(fDensity, 1.0f);
                        terminates = (fDensity > xi);
                        if (m_deltaTracking)
                        {
                            if (terminates)
                            {
                                accumTrans[i] = 0.0f;
                                it->finished = true;
                            }
                        }
                        else
                        {
                            // Residual ratio tracking
                            accumTrans[i] *= (1.0f - fDensity);
                            if (accumTrans[i] <= m_minTransmission)
                                it->finished = true;
                        }
                    }
                }
            }
        }

        for (i = 0; i < numRays; ++i)
        {
            trans[i] *= accumTrans[i];
            delete densityIterators[i];
        }

        delete aggregate;
        delete[] nsteps;
        delete[] accumTrans;
        delete[] densityIterators;
        delete[] densities;
    }
    
private:
    RtColorRGB clampToZero( const RtColorRGB &c )
    {
        return RtColorRGB( std::max( c.r, 0.f ),
            std::max( c.g, 0.f ),
            std::max( c.b, 0.f ) );
    }
    RtConstString m_name;    
    RixIntegratorContext& m_integratorContext;
    RixVolumeServices* m_volumeServices;
    int const m_maxSampleCount;
    RixShadingContext** m_shadingContexts;
    float const m_minTransmission;
    bool const m_deltaTracking;
};

#endif // PxrVolumeAggregate_H
