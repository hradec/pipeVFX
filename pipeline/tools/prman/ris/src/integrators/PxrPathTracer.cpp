/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2017 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

/* $Revision: #85 $ */

#include "RixIntegrator.h"
#include "RixLighting.h"
#include "RixVolume.h"
#include "RixLPE.h"
#include "RixRNG.h"
#include "RixShadingUtils.h"
#include "PxrGeoAovs.h"
#include "PxrVolumeAggregate.h"
#include <string.h>
#include <stdlib.h>

using namespace RixConstants;

enum SampleMode
{
    k_modeManual = 0, // user manually controls the number of samples per lobe
    k_modeBxdf,       // let the bxdf decide the proportion of samples per lobe
    k_modeNumTypes,   // the number of different types of sample modes
};

enum DepthReduceMode
{
    k_depthReduceDepth = 0,       // Control sample counts by depth
    k_depthReduceThruputMax,      // Use max thruput to control sample counts
    k_depthReduceThruputAvg,      // Use avg thruput to control sample counts
    k_depthReduceThruputGAvg,     // Use geometric avg thruput to control
    k_depthReduceNone,            // Do no reduction down the tree
    k_depthReduceDepthThruputAvg, // Use depth and avg thruput to control 
};

enum TraceDepthMode
{
    k_traceDepthModeCombined = 0, // Indirect rays are tracked/counted as having
                                  // potentially both diffuse and specular parts
    k_traceDepthModeSeparate,     // Indirect rays are tracked/counted as either
                                  // diffuse or specular (but not both)
};

#define MAX_PDF                1e30f // the max allowed pdf
#define MIN_PDF                1e-8f // the min allowed pdf

#define MAX_LIGHT_SAMPLES      1024  // the max allowed number of lgt samples
#define MAX_BXDF_SAMPLES       1024  // the max allowed number of bxdf samples
#define MAX_IND_SAMPLES        64    // the max allowed number of indirect samps
#define MAX_DIFF_SAMPLES       64    // the max allowed number of diffuse samps
#define MAX_SPEC_SAMPLES       64    // the max allowed number of specular samps
#define MAX_SSS_SAMPLES        64    // the max allowed number of sss samps
#define MAX_REFR_SAMPLES       64    // the max allowed number of refract samps
#define MAX_DEPTH              99999 // the max allowed ray depth

#define DEF_LIGHT_SAMPLES      1     // default number of light samples
#define DEF_BXDF_SAMPLES       1     // default number of bxdf samples


#define DEF_REDUCE_DIRECT_SAMPLES k_depthReduceDepthThruputAvg

                                     // default reduce light samples at depth

#define DEF_IND_SAMPLES        1     // default number of indirect samples
#define DEF_DIFF_SAMPLES       1     // default number of diffuse samples
#define DEF_SPEC_SAMPLES       1     // default number of specular samples
#define DEF_SSS_SAMPLES        1     // default number of subsurface samples
#define DEF_REFR_SAMPLES       1     // default number of refraction samples
#define DEF_ROULETTE_DEPTH     4     // do russian roulette at this ray depth
#define DEF_ROULETTE_THRESHOLD 0.2f  // do russian roulette below this 
                                     // weightedThruput
#define DEF_CLAMP_DEPTH        2     // by default clamp at/beyond this depth
#define DEF_CLAMP_LUMINANCE    10.0f // by default clamp the luminance to this
#define DEF_ALLOW_CAUSTICS     0     // by default caustics not allowed
#define DEF_SAMPLE_MODE        k_modeBxdf // bxdf controls samples per lobe


enum SampleType
{
    k_sampleBxdfGen = 0,
    k_sampleBxdfEval,
    k_sampleLight,
    k_sampleIndirect,
    k_sampleDiffuse,
    k_sampleSpecular,
    k_sampleSubsurface,
    k_sampleRefraction,
    k_sampleLobes,
    k_sampleNumTypes,
};

static const RtInt k_rngSamplePattern[] = 
{
    0x2d96c92b, // bxdf generate
    0x3917fe2e, // bxdf evaluate
    0xdeb189cf, // light
    0x39f4910f, // indirect
    0x71323fe1, // diffuse
    0x58124ec5, // specular
    0x8dca1357, // subsurface
    0x90bb2141, // refraction
    0xae987651, // lobes
    0x492502dd, // all
};

static const RtInt k_rngRoulettePattern[] = 
{
    0x5fa21247, // bxdf generate (unused)
    0x21945daf, // bxdf evaluate (unused)
    0x958c2e13, // light (unused)
    0xfc401391, // indirect
    0x7034d237, // diffuse
    0x0a5c314b, // specular
    0x82049251, // subsurface
    0xabf4560d, // refraction
    0x75397135, // lobes
    0x4098175f, // all
};

static const RtInt k_defaultMaxPathLength = 9;
static const RtInt k_defaultMaxContinuationLength = -1;

static RtConstString k_holdoutLightGroupSuffix = "__illumholdout";
static RtConstString k_imagePlaneSubsetDefault = "rman__imageplane";
static RtConstString k_volumeAggregateDefault = NULL;

// Trace at most k_maxRaysPerBatch rays at once.
const int k_maxRaysPerBatch = 32768;

// Some utility routines.

static inline RtPoint3
bias(const RtPoint3 &org, const RtNormal3 &N, const RtVector3 &dir, 
     RtFloat biasAmt) 
{
    // Currently we bias in the ray direction, but in some cases we might want
    // to bias along the surface normal (which is also provided as an input to
    // this routine).

    return org + biasAmt * dir;
}

template<typename T>
static T
clamp(T val, T least, T most)
{
    return (val < least) ? least : (val > most) ? most : val;
}

template<typename T>
static void
swap(T &a, T &b)
{
    T tmp = b;
    b = a;
    a = tmp;
}

static float
hashToRandom(unsigned int const value,
             unsigned int const scramble)
{
    unsigned int result = value;
    result ^= scramble;
    result ^= result >> 17;
    result ^= result >> 10;  result *= 0xb36534e5;
    result ^= result >> 12;
    result ^= result >> 21;  result *= 0x93fc4795;
    result ^= 0xdf6e307f;
    result ^= result >> 17;  result *= 1 | scramble >> 18;
    return result * ( 1.0f / 4298115584.0f );
}

class ptWorker;

class PxrPathTracer : public RixIntegrator
{
  public:

    PxrPathTracer();
    virtual ~PxrPathTracer();

    virtual int Init(RixContext &, char const *pluginpath);
    virtual RixSCParamInfo const *GetParamTable(); 
    virtual void Finalize(RixContext &); 
    virtual void RenderBegin(RixContext &ctx, RixIntegratorEnvironment &env,
                             RixParameterList const *plist);
    virtual void RenderEnd(RixContext &ctx);
    virtual void IntegrateRays(RixBXLobeTraits const& lobesWanted,
                               int* numShadingCtxs,
                               RixShadingContext const** shadingCtxs,
                               RixIntegratorContext& ictx);
    virtual void Integrate(RtInt ngrps, RixShadingContext const *sgrps[],
                           RixIntegratorContext &ictx);
    virtual void GetTransmission(int numRays, RtRayGeometry const* rays,
                                 RtColorRGB* trans, char const* subset,
                                 RixIntegratorContext& ictx);
    virtual void Synchronize(RixContext &rctx, RixSCSyncMsg m,
                             RixParameterList const *plist);

    virtual bool GetProperty(RixIntegratorContext& ictx,
                             const int* rayId,
                             int numRays,
                             RayProperty property,
                             void const* result);

    void GetOptions(RixContext &ctx, RtInt &traceDepthMode);
    void ReportStats(RixXmlFile* file);

  private:
    ptWorker* getWorker(RixIntegratorContext& iCtx);

    RtInt           m_numLightSamples;
    RtInt           m_numBxdfSamples;
    DepthReduceMode m_reduceDirectSamples;

    RtInt           m_numIndirectSamples;
    RtInt           m_numDiffuseSamples;
    RtInt           m_numSpecularSamples;
    RtInt           m_numSubsurfaceSamples;
    RtInt           m_numRefractionSamples;
    SampleMode      m_sampleMode;
    RtInt           m_maxSamples;
    RtInt           m_maxIndSamples;
    RtInt           m_rouletteDepth;
    RtFloat         m_rouletteThreshold;
    RtInt           m_clampDepth;
    RtFloat         m_clampLuminance;
    RtInt           m_allowCaustics;
    RtInt           m_maxPathLength;
    RtInt           m_maxContinuationLength;
    RtInt           m_maxShadingCtxSize;
    RtConstString   m_imagePlaneSubset;
    RtInt           m_traceDepthMode;
    RtInt           m_accumOpacity;
    RtConstString   m_volumeAggregate;
    RixMessages    *m_msgs;
    RixTimer       *m_timer;
    RtColorRGB      m_opacityThreshold;

    RixMutex       *m_allWorkersMutex;
    std::vector<ptWorker *> m_allWorkers;

    RtInt          *m_geoAovIds;
    RtFloat         m_statsBufferMemory;
    RtFloat         m_statsAovMemory;
    std::vector<RtUInt64> m_statsDepthTimers;
    std::vector<RtUInt64> m_statsRayCounts;
};

PxrPathTracer::PxrPathTracer() 
    : 
    m_numLightSamples(DEF_LIGHT_SAMPLES), 
    m_numBxdfSamples(DEF_BXDF_SAMPLES), 
    m_reduceDirectSamples(DEF_REDUCE_DIRECT_SAMPLES), 
    m_numIndirectSamples(DEF_IND_SAMPLES),
    m_numDiffuseSamples(DEF_DIFF_SAMPLES),
    m_numSpecularSamples(DEF_SPEC_SAMPLES),
    m_numSubsurfaceSamples(DEF_SSS_SAMPLES),
    m_numRefractionSamples(DEF_REFR_SAMPLES),
    m_sampleMode(DEF_SAMPLE_MODE), 
    m_maxSamples(0),
    m_maxIndSamples(0),
    m_rouletteDepth(DEF_ROULETTE_DEPTH),
    m_rouletteThreshold(DEF_ROULETTE_THRESHOLD), 
    m_clampDepth(DEF_CLAMP_DEPTH), 
    m_clampLuminance(DEF_CLAMP_LUMINANCE),
    m_allowCaustics(DEF_ALLOW_CAUSTICS),
    m_maxPathLength(k_defaultMaxPathLength),
    m_maxContinuationLength(k_defaultMaxContinuationLength),
    m_maxShadingCtxSize(0), // see RenderBegin
    m_imagePlaneSubset(k_imagePlaneSubsetDefault),
    m_accumOpacity(0),
    m_volumeAggregate(k_volumeAggregateDefault),
    m_msgs(0),
    m_timer(0),
    m_allWorkersMutex(0),
    m_geoAovIds(0), 
    m_statsBufferMemory(0.0f), 
    m_statsAovMemory(0.0f)
{
}

PxrPathTracer::~PxrPathTracer()
{
    if (m_geoAovIds)
    {
        delete[] m_geoAovIds;
        m_geoAovIds = NULL;
    }
}

int
PxrPathTracer::Init(RixContext &ctx, char const *pluginpath)
{
    // Setup any shared resources
    m_msgs = (RixMessages *) ctx.GetRixInterface(k_RixMessages);
    m_timer = (RixTimer *) ctx.GetRixInterface(k_RixTimer);

    if (RixThreadUtils *threadUtils = 
        (RixThreadUtils*) ctx.GetRixInterface(k_RixThreadUtils))
    {
        m_allWorkersMutex = threadUtils->NewMutex();
    }

    RixRenderState &state = *reinterpret_cast< RixRenderState * >
        (ctx.GetRixInterface(k_RixRenderState));

    RixRenderState::Type otype;
    RtInt ocount;
    if (state.GetOption("limits:othreshold", &m_opacityThreshold, sizeof(RtColorRGB),
            &otype, &ocount) == 0 &&
        otype == RixRenderState::k_Color && ocount == 3)
    {
        // Successfully got value
    }
    else
        m_opacityThreshold = RixConstants::k_OneRGB;

    return 0;
}

RixSCParamInfo const *
PxrPathTracer::GetParamTable()
{
    // Specify the parameters.
    static RixSCParamInfo s_ptable[] = 
    {
        RixSCParamInfo("numLightSamples", k_RixSCInteger),
        RixSCParamInfo("numBxdfSamples", k_RixSCInteger),
        RixSCParamInfo("reduceDirectSamples", k_RixSCString),
        RixSCParamInfo("numIndirectSamples", k_RixSCInteger),
        RixSCParamInfo("numDiffuseSamples", k_RixSCInteger),
        RixSCParamInfo("numSpecularSamples", k_RixSCInteger),
        RixSCParamInfo("numSubsurfaceSamples", k_RixSCInteger),
        RixSCParamInfo("numRefractionSamples", k_RixSCInteger),
        RixSCParamInfo("sampleMode", k_RixSCString),
        RixSCParamInfo("rouletteDepth", k_RixSCInteger),
        RixSCParamInfo("rouletteThreshold", k_RixSCFloat),
        RixSCParamInfo("clampDepth", k_RixSCInteger),
        RixSCParamInfo("clampLuminance", k_RixSCFloat),
        RixSCParamInfo("allowCaustics", k_RixSCInteger),
        RixSCParamInfo("maxPathLength", k_RixSCInteger),
        RixSCParamInfo("maxContinuationLength", k_RixSCInteger),
        RixSCParamInfo("imagePlaneSubset", k_RixSCString),
        RixSCParamInfo("accumOpacity", k_RixSCInteger),
        RixSCParamInfo("volumeAggregate", k_RixSCString),
        
        RixSCParamInfo() // end of table
    };
    return &s_ptable[0];
}

static void
statsReporter(void *ctx, class RixXmlFile *file)
{
    ((PxrPathTracer*)ctx)->ReportStats(file);
}

void
PxrPathTracer::RenderBegin(RixContext &ctx, RixIntegratorEnvironment &env,
                           RixParameterList const *plist)
{
    // Fetch the options.
    printf("\n\nBUMMMMMMMMMMMMM\n\n");
    GetOptions(ctx, m_traceDepthMode);

    RtConstString sampleModeStr = 0;
    RtConstString depthReduceModeStr = 0;
    RtInt paramId;
    char const *inm = "PxrPathTracer";
    char const *pnm;

    pnm = "numLightSamples";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_numLightSamples) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "numBxdfSamples";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_numBxdfSamples) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "reduceDirectSamples";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &depthReduceModeStr) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "numIndirectSamples";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_numIndirectSamples)!= k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "numDiffuseSamples";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_numDiffuseSamples) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "numSpecularSamples";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_numSpecularSamples)!=k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "numSubsurfaceSamples";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0,&m_numSubsurfaceSamples)!=k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "numRefractionSamples";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0,&m_numRefractionSamples)!=k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "sampleMode";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &sampleModeStr) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "rouletteDepth";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_rouletteDepth) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "rouletteThreshold";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_rouletteThreshold) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "clampDepth";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_clampDepth) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "clampLuminance";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_clampLuminance) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "allowCaustics";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_allowCaustics) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "maxPathLength";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_maxPathLength) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
        else
        {
            // This parameter includes camera rays in the ray depth
            // count. However, our m_maxPathLength variable here
            // subtracts one; this makes things consistent in the code
            // w.r.t. the trace:maxdiffusedepth and
            // trace:maxspeculardepth attributes, since camera rays
            // are *not* included in the trace:maxdiffusedepth and
            // trace:maxspeculardepth attributes' ray depth count.
            --m_maxPathLength;
        }
    }

    pnm = "maxContinuationLength";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_maxContinuationLength) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }
    if (m_maxContinuationLength < 0)
    {
        m_maxContinuationLength = std::max(2 * (m_maxPathLength + 2), 256);
    }

    pnm = "imagePlaneSubset";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_imagePlaneSubset) != k_RixSCUniform)
        {
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
        }
    }

    pnm = "accumOpacity";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_accumOpacity) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }

    pnm = "volumeAggregate";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_volumeAggregate) != k_RixSCUniform)
            m_msgs->Error("%s: invalid parameter %s", inm, pnm);
    }
    
    // Here we check all three conditions before allocating memory and ask the intergrator
    // to actually do the compTrans works because if there are no indirect samples, compTrans is
    // not going to return anything different than directLightContext. There is no need to do this 
    // extra work. Same goes for max path length
    if (m_accumOpacity)
    {
        if (m_numIndirectSamples < 1) 
        {
            m_accumOpacity = false;
            pnm = "numIndirectSamples";
            m_msgs->Error("%s: accumOpacity requires numIndirectSamples to be at least 1. "
                "Ignoring accumOpacity\n", inm, pnm);
        }
        if (m_maxPathLength < 1)
        {
            // m_maxPathLength == 1 means one additional bounce after the camera ray.
            // this is the minimum requirement for compTrans to work, although in reality
            // max path length should be set sufficiently high so that paths can reach 'end of scene'
            m_accumOpacity = false;
            pnm = "maxPathLength";
            m_msgs->Error("%s: accumOpacity requires maxPathLength to be at least 2. "
                "Ignoring accumOpacity\n", inm, pnm);
        }
    }

    if (sampleModeStr)
    {
        if (!strcmp(sampleModeStr, "manual"))
            m_sampleMode = k_modeManual;
        else if (!strcmp(sampleModeStr, "bxdf"))
            m_sampleMode = k_modeBxdf;
        else
        {
            m_msgs->Error("%s: unknown value for sampleMode "
                          "parameter: \"%s\"\n", inm, sampleModeStr);
        }
    }

    if (depthReduceModeStr)
    {
        if (!strcmp(depthReduceModeStr, "depth"))
            m_reduceDirectSamples = k_depthReduceDepth;
        else if (!strcmp(depthReduceModeStr, "throughputmax"))
            m_reduceDirectSamples = k_depthReduceThruputMax;
        else if (!strcmp(depthReduceModeStr, "throughputavg"))
            m_reduceDirectSamples = k_depthReduceThruputAvg;
        else if (!strcmp(depthReduceModeStr, "throughputgeoavg"))
            m_reduceDirectSamples = k_depthReduceThruputGAvg;
        else if (!strcmp(depthReduceModeStr, "throughput"))
            m_reduceDirectSamples = k_depthReduceThruputGAvg;
        else if (!strcmp(depthReduceModeStr, "none"))
            m_reduceDirectSamples = k_depthReduceNone;
        else if (!strcmp(depthReduceModeStr, "depththroughputavg"))
            m_reduceDirectSamples = k_depthReduceDepthThruputAvg;
        else
        {
            m_msgs->Error("%s: unknown value for "
                          "reduceDirectSamples parameter: \"%s\"\n", 
                          inm, depthReduceModeStr);
        }
    }

    // Bounds-check the parameters.
    m_numLightSamples        = clamp(m_numLightSamples, 0, MAX_LIGHT_SAMPLES);
    m_numBxdfSamples         = clamp(m_numBxdfSamples, 0, MAX_BXDF_SAMPLES);
    m_numIndirectSamples     = clamp(m_numIndirectSamples, 0, MAX_IND_SAMPLES);
    m_numDiffuseSamples      = clamp(m_numDiffuseSamples, 0, MAX_DIFF_SAMPLES);
    m_numSpecularSamples     = clamp(m_numSpecularSamples, 0, MAX_SPEC_SAMPLES);
    m_numSubsurfaceSamples   = clamp(m_numSubsurfaceSamples, 0, 
                                     MAX_SSS_SAMPLES);
    m_numRefractionSamples   = clamp(m_numRefractionSamples, 0, 
                                     MAX_REFR_SAMPLES);
    m_rouletteDepth          = clamp(m_rouletteDepth, -1, MAX_DEPTH);
    m_rouletteThreshold      = clamp(m_rouletteThreshold, 0.0f, 1.0f);
    m_clampDepth             = clamp(m_clampDepth, -1, MAX_DEPTH);
    m_clampLuminance         = clamp(m_clampLuminance, 0.0f, 1e30f);
    m_allowCaustics          = clamp(m_allowCaustics, 0, 1);

    RixStats* stats = (RixStats*) ctx.GetRixInterface(k_RixStats);
    stats->AddReporterCtx(statsReporter, this);

    m_maxIndSamples = ((m_sampleMode == k_modeBxdf) 
                       ? m_numIndirectSamples 
                       : (m_numDiffuseSamples    + m_numSpecularSamples +
                          m_numSubsurfaceSamples + m_numRefractionSamples));
    
    m_maxSamples = std::max(std::max(m_numLightSamples, m_numBxdfSamples),
                            m_maxIndSamples);

    if (m_maxSamples > 16)
    {
        // If lots of samples, then make sure that we don't use too much memory
        // (that is, request a smaller maxShadingCtxSize if appropriate).
        double memoryDivisor = m_maxSamples / 16.0f;
        int newCtxSize = (int) ceil(env.maxShadingCtxSize / memoryDivisor);
        env.maxShadingCtxSize = newCtxSize;
    }

    m_maxShadingCtxSize      = env.maxShadingCtxSize;

    // Communicate the requirements for this integrator.
    env.lightingRequirements = 
                        RixIntegratorEnvironment::k_UnidirectionalLighting;
    env.supportedSamplingModes = RixIntegratorEnvironment::SamplingModes(
                                     RixIntegratorEnvironment::k_Fixed |
                                     RixIntegratorEnvironment::k_Adaptive |
                                     RixIntegratorEnvironment::k_Incremental);
    // We only need the GetTransmission method to be called when we
    // have the volume aggregate to worry about
    env.wantsTransmission = (m_volumeAggregate != NULL);

    // Get the list of requested geometric AOVs
    if (!PxrGeoAOV::disableIntegratorAOVs(ctx, m_geoAovIds))
    {
    PxrGeoAOV::GetChannelIds(env, m_geoAovIds);
    }

    // Prepare per-depth stats
    m_statsDepthTimers.resize(m_maxPathLength+1, 0);
    m_statsRayCounts.resize(m_maxPathLength+1, 0);
}

// holds scratch arrays for doing the work
class ptWorker : public RixVolumeIntegrator::IntegratorDelegate
{
  public:

    struct RayInfo
    {
        RtColorRGB         weightedThruput; // includes 1/N
        RtColorRGB         thruput;         // does not include 1/N
        RtColorRGB         thruputToScatter;
        RtInt              depth;           // counts the scattering bounces
        RtInt              diffusedepth;    // counts the diffuse bounces
        RtInt              speculardepth;   // counts the specular bounces
        RtInt              truedepth;       // counts all bounces 
                                            // (incl continuation)
        RtInt              sctxIdx;         // index of the shading context
        RtInt              dspIdx;          // index for display services
        RixShadingContext const *sctx;      // to get bxdf volume
        RixRNG::SampleCtx  rngSamp;         // per-ray random number context
        unsigned char      onlyDiffuse;     // generate/evaluate only diffuse
        SampleType         sampleType;      // the originating type of samples
        bool               isCollector;     // originating ray is collector
        bool               distanceWritten; // we have written the ray's 
                                            // distance
        bool               isHoldout;       // light path is holdout
        bool               primaryIsHoldout; // this is a path spawned by a holdout object
                                            // this is needed because we do not want
                                            // compTrans to affect holdout opacity at all
                                            // at the first encounter of a holdout object
                                            // this value will be set to true and will 
                                            // always be true onwards
        bool               scattered;       // whether or not the previous event was a scattering
                                            // event
        RixLPEState       *lpeState;        // state for LPE AOVs
    };

    struct DepthInfo
    {
        int totalDepth;
        int maxDiffuseDepth;
        int maxSpecularDepth;
        RixLPEToken lpeGrpId;
        bool isCollector;
        RtToken reflectSubset;
        RtToken transmitSubset;
        RtToken reflectExcludeSubset;
        RtToken transmitExcludeSubset;
    };

    class ShadeInfo
    {
      public:
        ShadeInfo(int sz)
            : size(sz)
        {
            rayInfo = new RayInfo[sz];
            sctxs = new RixShadingContext const*[sz];
            // There is a 1-1 correspondence from sctx to incidentSctxIsMatte
            // the reason we need this is that in directLightContext, when computing
            // opacity for a shade point, we need to know if the previous hit is matte.
            // The values of this array are filled in traceRays where both the previous
            // shading context and the current (newly created) one are valid
            incidentSctxIsMatte = new bool[sz];
            numSctxs = 0;
            depthInfo = new DepthInfo[sz];
        }

        ~ShadeInfo()
        {
            delete[] rayInfo;
            delete[] sctxs;
            delete[] incidentSctxIsMatte;
            delete[] depthInfo;
        }

        RayInfo            *rayInfo;
        RixShadingContext const**sctxs; 
        bool               *incidentSctxIsMatte;
        RtInt               numSctxs;
        DepthInfo          *depthInfo;// uniform ray depths per shading context
        int		    size;
    };

    ptWorker(RixIntegratorContext &iCtx,
             RixRefCntPtr<RixLPE> rixLpe, 
             RtInt numLight, RtInt numBxdf, 
             DepthReduceMode depthReduceDirect,
             RtInt numIndirect, 
             RtInt numDiffuse, RtInt numSpecular, 
             RtInt numSubsurface, RtInt numRefraction, 
             SampleMode sampleMode, RtInt maxSamples, RtInt maxIndSamples, 
             RtInt rouletteDepth, RtFloat rouletteThreshold, 
             RtInt clampDepth, RtFloat clampLuminance, 
             RtInt allowCaustics, RtInt maxPathLength,
             RtInt maxContinuationLength,
             RtInt maxShadingCtxSize,
             RtConstString imagePlaneSubset,
             RtInt *aovIdList,
             RtInt traceDepthMode,
             RtInt accumOpacity,
             RtConstString volumeAggregate)
        : 
        m_rixLpe(rixLpe), 
        m_numPotentialDiffuseLobes(k_RixBXMaxNumDiffuseLobes),
        m_numPotentialSpecularLobes(k_RixBXMaxNumSpecularLobes),
        m_numPotentialUserLobes(k_RixBXMaxNumUserLobes),
        m_bufferMemory(0),
        m_numLightSamples(numLight), 
        m_numBxdfSamples(numBxdf),
        m_reduceDirectSamples(depthReduceDirect), 
        m_numIndirectSamples(numIndirect), 
        m_numDiffuseSamples(numDiffuse),
        m_numSpecularSamples(numSpecular),
        m_numSubsurfaceSamples(numSubsurface),
        m_numRefractionSamples(numRefraction),
        m_sampleMode(sampleMode),
        m_maxSamples(maxSamples),
        m_maxIndSamples(maxIndSamples),
        m_rouletteDepth(rouletteDepth),
        m_rouletteThreshold(rouletteThreshold),
        m_clampDepth(clampDepth),
        m_clampLuminance(clampLuminance),
        m_allowCaustics(allowCaustics),
        m_maxPathLength(maxPathLength),
        m_maxContinuationLength(maxContinuationLength),
        m_imagePlaneSubset(imagePlaneSubset),
        m_geoAovIds(aovIdList),
        m_traceDepthMode(traceDepthMode),
        m_accumOpacity(accumOpacity),
        m_volumeAggregate(volumeAggregate)
    {
        RixLightingServices *lightingSvc = iCtx.GetLightingServices();
        int numFixedSamples = lightingSvc->GetTotalFixedSamples();
        m_maxSamples += numFixedSamples;

        m_numLightGroups = std::max(1, lightingSvc->GetNumLightGroups());

        // Initilize holdout light group list
        // Holdout light groups are those that do NOT end with the holdout suffix
        m_lightGroupIsHoldout = new bool[m_numLightGroups];
        for (int i=0; i<m_numLightGroups; ++i)
        {
            m_lightGroupIsHoldout[i] = true;
            const char* name = lightingSvc->GetLightGroupName(i);
            if (name) {
                int offset = strlen(name) - strlen(k_holdoutLightGroupSuffix);
                m_lightGroupIsHoldout[i] = (offset < 0 ||
                    0 != strcmp(name+offset, k_holdoutLightGroupSuffix));
            }
        }

        m_maxPathCount = maxShadingCtxSize;
        m_displaySvc = iCtx.GetDisplayServices();

        for (int i = 0; i < k_RixBXMaxNumDiffuseLobes; i++)
        {
            m_ClDiffuse[i] = 0;
            m_diffuse[i] = 0;
        }
        for (int i = 0; i < k_RixBXMaxNumSpecularLobes; i++)
        {
            m_ClSpecular[i] = 0;
            m_specular[i] = 0;
        }
        for (int i = 0; i < k_RixBXMaxNumUserLobes; i++)
        {
            m_ClUser[i] = 0;
            m_user[i] = 0;
        }

        // Set the per-event Russian Roulette acceptance probability.
        // To avoid very low acceptance probabilities that can spike 
        // the variance, ensure that the minimum cumulative 
        // acceptance probability (across all Roulette termination 
        // events) never goes below a reasonable threshold.
        if (m_rouletteDepth >= 0 &&
            m_maxPathLength + 1 > m_rouletteDepth)
        {
            const RtFloat minCumulativeProb = 0.1f;
            int maxRouletteEvents = (m_maxPathLength + 1) - m_rouletteDepth;
            m_rouletteProb = powf(minCumulativeProb, 1.0f / maxRouletteEvents);
        }
        else
        {
            m_rouletteProb = 1.0f;
        }
        m_rouletteProbInv = 1.0f / m_rouletteProb;

        // allocate space:
        
        int sz = m_maxSamples * m_maxPathCount;

        m_rngSamps         = new RixRNG::SampleCtx[sz];
        m_chooseSamps      = new RixRNG::SampleCtx[sz];
        m_chooseXi         = new RtFloat[m_maxPathCount];
        m_emitLight        = new RtColorRGB[sz];
        m_emitLocal        = new RtColorRGB[sz];
        m_lobesWanted      = new RixBXLobeTraits[sz];
        m_lobesEvaluated   = new RixBXLobeTraits[sz];
        m_lobeSampled      = new RixBXLobeSampled[sz];
        m_PtoL             = new RtVector3[sz];
        m_dist             = new RtFloat[sz];
        m_lightTrans       = new RtColorRGB[sz];
        m_lightGroupIds    = new RtInt[sz];
        m_lightLpeTokens   = new RixLPEToken[sz];
        m_lPdfIllum        = new RtFloat[sz];
        m_thruput          = new RtColorRGB[sz];
        m_thruputToScatter = new RtColorRGB[sz];
        m_On               = new RtVector3[sz];
        m_FPdf             = new RtFloat[sz];
        m_RPdf             = new RtFloat[sz];
        
        m_rays             = new RtRayGeometry[sz];
        m_backgroundColor  = new RtColorRGB[sz];

        m_perRayRngCtx     = new RixRNG::SampleCtx[k_maxRaysPerBatch];
        m_perRayRngCtxAll  = new RixRNG::SampleCtx[k_maxRaysPerBatch];
        m_perRayRngCtxSss  = new RixRNG::SampleCtx[k_maxRaysPerBatch];
        m_perRayRngCtxDiff = new RixRNG::SampleCtx[k_maxRaysPerBatch];
        m_raysAll          = new RtRayGeometry[k_maxRaysPerBatch];
        m_raysSss          = new RtRayGeometry[k_maxRaysPerBatch];
        m_raysDiff         = new RtRayGeometry[k_maxRaysPerBatch];

        // We allocate two complete arrays of LPE states, one for use
        // prior to any branching or splitting factor on indirect rays,
        // and another for use after branching/splitting for indirect rays.
        // The pre-split array is of size equal to the maximum possible number 
        // of camera hits in a batch, whereas the post-split array is that
        // times the branching/splitting factor. 
        int indSize = m_maxIndSamples * m_maxPathCount;
        m_preSplitLpeState  = m_rixLpe->AllocateStates(m_maxPathCount);
        m_postSplitLpeState = m_rixLpe->AllocateStates(indSize);

        // Use ping-pong buffers to store the path weightedThruput, ray depth, 
        // and shading context information.
        m_shadeInfoPing    = new ShadeInfo(sz);
        m_shadeInfoPong    = new ShadeInfo(sz);
        m_usingPing        = true; // start with ping

        // Delegate and camera ray ids
        m_cameraRayIds = new RtInt[sz];
        m_delegateRayIds = new RtInt[sz];
        m_useDelegateRayIds = false;
        ResizeArrays(iCtx);

        // Note as is, if the rib file says only "rgb" is wanted (as opposed to "rgba")
        // PxrPathTracer still computes alpha and writes into a framebuffer. Its just not written out.
        // Future work: we should opt out of this memory allocation and the extra computation required
        // to accumulate opacity if alpha is not asked for.
        if (m_accumOpacity) m_compTrans = new RtColorRGB[sz];
        else m_compTrans = NULL;

        // Keep track of the memory usage for the buffers allocated above.
        m_bufferMemory += 
            sz * 
            (1 * sizeof(RixRNG::SampleCtx) + 
             6 * sizeof(RtColorRGB) +
             2 * sizeof(RixBXLobeTraits) +
             1 * sizeof(RixBXLobeSampled) +
             2 * sizeof(RtVector3) +
             4 * sizeof(RtFloat) +
             1 * sizeof(RtInt) +
             1 * sizeof(RtRayGeometry) +
             2 * sizeof(ShadeInfo) +
             2 * sizeof(RayInfo) +
             2 * sizeof(RixShadingContext const*)) +
            m_numLightGroups * sizeof(bool) +
            m_maxPathCount * sizeof(RixLPEState) +
            indSize * sizeof(RixLPEState) +
            k_maxRaysPerBatch *
            (3 * sizeof(RixRNG::SampleCtx) +
             2 * sizeof(RtRayGeometry)) +
            (m_maxPathLength+1)*sizeof(RtInt64);

        m_geoAovColor = NULL;
        m_geoAovFloat = NULL;
        m_aovMemory = 0.0;
        if (m_geoAovIds)
        {
            m_geoAovColor = new RtFloat3[maxShadingCtxSize];
            if (PxrGeoAOV::NeedTempFloat(m_geoAovIds))
                m_geoAovFloat = new RtFloat[maxShadingCtxSize];

            m_aovMemory =
                1 * (sizeof(RtInt)*PxrGeoAOV::k_numGeoAovs) +
                1 * (sizeof(RtFloat3)*maxShadingCtxSize)  +
                (m_geoAovFloat!=NULL) * (sizeof(RtFloat)*maxShadingCtxSize);
        }

        // Todo: what if during interactive rendering we modify m_maxPathLength?
        //       Is it even allowed? If it does we need to reallocate.
        m_depthTimers = new RtInt64[m_maxPathLength+1];
        for (int i=0; i<=m_maxPathLength; ++i)
            m_depthTimers[i] = 0;
        m_rayCounts = new RtInt64[m_maxPathLength+1];
        for (int i=0; i<=m_maxPathLength; ++i)
            m_rayCounts[i] = 0;
    }

    ~ptWorker()
    {
        delete[] m_rngSamps;
        delete[] m_chooseSamps;
        delete[] m_chooseXi;
        delete[] m_emitLight;
        delete[] m_emitLocal;
        delete[] m_lobesWanted;
        delete[] m_lobesEvaluated;
        delete[] m_lobeSampled;
        delete[] m_PtoL;
        delete[] m_dist;
        delete[] m_lightTrans;
        delete[] m_lightGroupIds;
        delete[] m_lightLpeTokens;
        delete[] m_lightGroupIsHoldout;
        delete[] m_lPdfIllum;
        delete[] m_thruput;
        delete[] m_thruputToScatter;
        delete[] m_On;
        delete[] m_FPdf;
        delete[] m_RPdf;
        
        delete[] m_rays;
        delete[] m_backgroundColor;

        delete[] m_perRayRngCtx;
        delete[] m_perRayRngCtxAll;
        delete[] m_perRayRngCtxSss;
        delete[] m_perRayRngCtxDiff;
        delete[] m_raysAll;
        delete[] m_raysSss;
        delete[] m_raysDiff;

        delete[] m_geoAovColor;
        delete[] m_geoAovFloat;

        if (m_compTrans) delete[] m_compTrans;

        int indSize = m_maxIndSamples * m_maxPathCount;
        m_rixLpe->FreeStates(m_maxPathCount, m_preSplitLpeState);
        m_rixLpe->FreeStates(indSize, m_postSplitLpeState);

        delete m_shadeInfoPing;
        delete m_shadeInfoPong;

        delete[] m_cameraRayIds;
        delete[] m_delegateRayIds;

        int sz = m_maxSamples * m_maxPathCount;

        // Free the old buffers.
        for (int i = 0; i < k_RixBXMaxNumDiffuseLobes; i++)
        {
            if (m_ClDiffuse[i])
            {
                m_bufferMemory -= sz * sizeof(RtColorRGB);
                delete[] m_ClDiffuse[i];
                m_ClDiffuse[i] = 0;
            }
            if (m_diffuse[i])
            {
                m_bufferMemory -= sz * sizeof(RtColorRGB);
                delete[] m_diffuse[i];
                m_diffuse[i] = 0;
            }
        }
        for (int i = 0; i < k_RixBXMaxNumSpecularLobes; i++)
        {
            if (m_ClSpecular[i])
            {
                m_bufferMemory -= sz * sizeof(RtColorRGB);
                delete[] m_ClSpecular[i];
                m_ClSpecular[i] = 0;
            }
            if (m_specular[i])
            {
                m_bufferMemory -= sz * sizeof(RtColorRGB);
                delete[] m_specular[i];
                m_specular[i] = 0;
            }
        }
        for (int i = 0; i < k_RixBXMaxNumUserLobes; i++)
        {
            if (m_ClUser[i])
            {
                m_bufferMemory -= sz * sizeof(RtColorRGB);
                delete[] m_ClUser[i];
                m_ClUser[i] = 0;
            }
            if (m_user[i])
            {
                m_bufferMemory -= sz * sizeof(RtColorRGB);
                delete[] m_user[i];
                m_user[i] = 0;
            }
        }

        // Keep track of the memory usage for the buffers allocated above.

        m_bufferMemory -= 
            sz * 
            (1 * sizeof(RixRNG::SampleCtx) + 
             6 * sizeof(RtColorRGB) +
             2 * sizeof(RixBXLobeTraits) +
             1 * sizeof(RixBXLobeSampled) +
             2 * sizeof(RtVector3) +
             4 * sizeof(RtFloat) +
             1 * sizeof(RtInt) +
             1 * sizeof(RtRayGeometry) +
             2 * sizeof(ShadeInfo) +
             2 * sizeof(RayInfo) +
             2 * sizeof(RixShadingContext const*)) +
            m_numLightGroups * sizeof(bool) +
            m_maxPathCount * sizeof(RixLPEState) +
            indSize * sizeof(RixLPEState) +
            k_maxRaysPerBatch *
            (3 * sizeof(RixRNG::SampleCtx) +
             2 * sizeof(RtRayGeometry)) +
             (m_maxPathLength+1)*sizeof(RtInt64);

        delete[] m_depthTimers;
        delete[] m_rayCounts;
    }

    void IntegrateRays(RixIntegratorContext& ictx,
                       RixBXLobeTraits const& lobesWanted,
                       int* numShadingCtxs,
                       RixShadingContext const** shadingCtxs,
                       RixTimer *timer);
    
    void Integrate(RixIntegratorContext &iCtx,
                   RtInt ngrps, RixShadingContext const *sgrps[],
                   RixTimer* timer);

    void GetTransmission(RixIntegratorContext& iCtx,
                         int numRays, RtRayGeometry const* rays,
                         RtColorRGB* trans, char const* subset);

    bool UpdateLPEs(RixIntegratorContext &iCtx);

    // Required implementation for IntegratorDelegate
    virtual void PerformDirectLighting(RixShadingContext const &,
                                       RixBXLobeTraits const *lobesWanted,
                                       int step);
    
    void ResizeArrays(RixContext &ctx);

    RtInt64 GetBufferMemory() const { return m_bufferMemory; }
    RtInt64 GetAOVMemory() const {return m_aovMemory; }

    void GetRayDepth(const int* rayId, 
                     int numPts, 
                     void const *result) const;

  private:

    void splitRaysIntoShadingCtxs(RixIntegratorContext &iCtx,
                                  int nRays, RtRayGeometry *rays,
                                  RixBXLobeTraits const &lobesWanted,
                                  RixRNG::SampleCtx *perRayRngCtx,
                                  RtInt *delegateRayIds,
                                  RixShadingContext const *firstSctx,
                                  RtToken reflectSubset,
                                  RtToken reflectExcludeSubset,
                                  bool isPrimary,
                                  bool isIncident,
                                  int &nSctxsBatch, // out
                                  RixShadingContext const **&sctxsTmp); // out

    void getBackgroundImageColor(RixIntegratorContext &iCtx, 
                                 RixShadingContext const &sCtx,
                                 ShadeInfo *shadeInfoPing,
                                 bool isCollector, 
                                 RtColorRGB *backgroundColor,
                                 RtInt *rayId);

    void directLighting(RixIntegratorContext &iCtx,
                        ShadeInfo *shadeInfoPing, 
                        ShadeInfo *shadeInfoPong);

    void directLightContext(RixIntegratorContext &iCtx, 
                            int totalDepth, int maxDiff, int maxSpec,
                            RixLPEToken lpeGrpId, bool isCollector, 
                            int lgtSamp, int srfSamp,
                            RtFloat invLgtSamp, RtFloat invSrfSamp,
                            RixShadingContext const &sCtx,
                            bool incidentIsMatte,
                            ShadeInfo *shadeInfoPing,
                            ShadeInfo *shadeInfoPong,
                            RixBXLobeTraits const *lobesWanted,
                            int step,
                            bool writeAlpha,
                            bool hasVol,
                            bool isDelegate = false);
    
    void emitLocal(RixIntegratorContext &iCtx,
                   ShadeInfo *shadeInfoPing);

    void emitLocalContext(RixIntegratorContext &iCtx,
                          RixShadingContext const &sCtx,
                          RixLPEToken lpeGrpId, 
                          bool isCollector, 
                          ShadeInfo *shadeInfoPing,
                          RixBXLobeTraits const *lobesWanted,
                          bool writeAlpha = true,
                          bool isDelegate = false);

    void updateHoldout(ShadeInfo *shadeInfoPing);

    void updateThroughputs(RixIntegratorContext &iCtx,
                           ShadeInfo *shadeInfoPing);

    void createRays(RixIntegratorContext &iCtx, int &rayIdx, bool cameraHits,
                    ShadeInfo *shadeInfoPing, ShadeInfo *shadeInfoPong);

    void createRaysHelper(RixIntegratorContext &iCtx, 
                          SampleType sampleType, int &rayIdx, 
                          ShadeInfo *shadeInfoPing, ShadeInfo *shadeInfoPong);

    void traceRays(RixIntegratorContext &iCtx, 
                   int nRays, RtRayGeometry *rays,
                   ShadeInfo *shadeInfoPing,
                   ShadeInfo *shadeInfoPong);

    int  computeSampleCount(int depth, int numSamp, DepthReduceMode depthReduce,
                            float maxThruput, bool direct,
                            bool subsurface = false,
                            bool continuation = false);
        
    void computeClampDirect(int depth, 
                            RtColorRGB const &lgtTrans, 
                            RixBXActiveLobeWeights &activeLobes,
                            int weightIndex, 
                            RtColorRGB const &thruput, 
                            float invNumSamp,
                            bool &isFinite, RtFloat &clampAmt);

    void computeClampEmissive(int depth, 
                              RtColorRGB const &emission,
                              RtColorRGB const &thruput, 
                              bool &isFinite, RtFloat &clampAmt);

    SampleType findSampleType(SampleType srcSampleType, 
                              RixBXLobeSampled lobeSampled, int depth);

    void getDirectState(RixShadingContext const &sCtx,
                        RtInt &maxDiffDepth, RtInt &maxSpecDepth,
                        RixLPEToken &lpeGrpId, bool &isCollector);

    void getIndirectState(RixShadingContext const &sCtx,
                          RtInt &autoBias, RtFloat &bias,
                          RtToken &reflectSubset, RtToken &transmitSubset,
                          RtToken &reflectExcludeSubset, RtToken &transmitExcludeSubset);

    RixLPEToken resolveLPEToken(RixShadingContext const& sCtx,
                                bool &isCollector) const;

    // get a nice contiguous group of rng for calling generate
    // scale numSamples and sampleid by correct number of samples.  
    void initRNG(int numPts, int pattern, bool doRngSplit,
                 int numSamp, RayInfo *rayInfo, RtInt *rayId) 
    {
        // Spawn a new random number domain using the immediate parent's 
        // rng ctx instead of the rng ctx of the primary rays in order to 
        // avoid repeats in the random numbers; for non-volume camera hits, 
        // use the 2-argument NewDomain() overload for improved 
        // stratification (when numSamp >= 2), and in all other cases use 
        // the 3-argument NewDomain() overload (no splits).
        for (int i = 0; i < numPts; i++)  
        {
            RtInt id = rayId[i];
            if (id < 0) continue;
            m_rngSamps[i] = doRngSplit ? 
                rayInfo[id].rngSamp.NewDomain(pattern, numSamp) : 
                rayInfo[id].rngSamp.NewDomain(pattern, 0, numSamp);
        }
    }

    void initRNG(RixIntegratorContext &iCtx, 
                 int pattern, bool doRngSplit,
                 int numSamp, int numRays,
                 RtRayGeometry const *rays) 
    {
        // Spawn a new random number domain using the rng ctx of the
        // primary rays.
        for (int i = 0; i < numRays; i++)  
        {
            RtInt id = rays[i].rayId;
            if (id < 0) continue;
            int iCtxIdx = rays[i].integratorCtxIndex;
            m_rngSamps[i] = doRngSplit ?
                iCtx.rngCtx->GetSampleCtx(iCtxIdx).NewDomain(pattern, numSamp) : 
                iCtx.rngCtx->GetSampleCtx(iCtxIdx).NewDomain(pattern, 0, numSamp);
        }
    }

    void incRNG(RixShadingContext const &sCtx) 
    {
        // bump the sample in the rng
        for (int i = 0; i < sCtx.numPts; i++)  
        {
            m_rngSamps[i].sampleid++;
        }
    }

    void initChooseRNG(int numPts, bool doRngSplit,
                       int numSamp, RayInfo *rayInfo, RtInt *rayId)
    {
        // Spawn a new random number domain using the immediate parent's 
        // rng ctx instead of the rng ctx of the primary rays in order to 
        // avoid repeats in the random numbers; for non-volume camera hits, 
        // use the 2-argument NewDomain() overload for improved 
        // stratification (when numSamp >= 2), and in all other cases use 
        // the 3-argument NewDomain() overload (no splits).
        int pattern = k_rngSamplePattern[k_sampleLobes];
        for (int i = 0; i < numPts; i++)  
        {
            RtInt id = rayId[i];
            if (id < 0) continue;
            m_chooseSamps[i] = doRngSplit ? 
                rayInfo[id].rngSamp.NewDomain(pattern, numSamp) : 
                rayInfo[id].rngSamp.NewDomain(pattern, 0, numSamp);
        }
    }

    void incChooseRNG(RixShadingContext const &sCtx)
    {
        // bump the sample in the rng
        for (int i = 0; i < sCtx.numPts; i++)  
        {
            m_chooseSamps[i].sampleid++;
        }
    }

    // Veach's MIS power heuristic with exponent 2
    RtFloat misWeight(RtFloat nG, RtFloat pdfG, RtFloat nE, RtFloat pdfE) 
    {
        if (nG != 0.0f && nE != 0.0f && (pdfG != 0.0f || pdfE != 0.0f))
        {
            float g = nG*pdfG;
            float e = nE*pdfE;
            return (g*g) / (g*g + e*e);
        }
        else
        {
            return 1.0f;
        }
    }

    bool badSamp(const RixBXLobeSampled &lobeSampled,
                 RtFloat spdf, RtFloat lpdf, bool isLight) const
    {
        RtFloat leastSpdf = isLight ? 0.0f : MIN_PDF;
        RtFloat leastLpdf = isLight ? MIN_PDF : 0.0f;

        return (!lobeSampled.GetValid() || 
                spdf < leastSpdf ||
                spdf > MAX_PDF ||
                lpdf < leastLpdf ||
                lpdf > MAX_PDF);
    }

    bool badSamp(const RixBXLobeTraits &lobeTraits,
                 RtFloat spdf, RtFloat lpdf, bool isLight) const
    {
        RtFloat leastSpdf = isLight ? 0.0f : MIN_PDF;
        RtFloat leastLpdf = isLight ? MIN_PDF : 0.0f;

        return (!lobeTraits.HasAnyDiffSpec() ||
                spdf < leastSpdf ||
                spdf > MAX_PDF ||
                lpdf < leastLpdf ||
                lpdf > MAX_PDF);
    }

    void setDelegateRayIds(RtInt numRays, RtRayGeometry const *rays, RtInt *rayIds)
    {
        // Clear all ray ids to -1 in order to mark shading context
        // points that are not associated with a ray
        int numIds = m_maxSamples * m_maxPathCount;
        for (int i = 0; i < numIds; i++)
        {
            rayIds[i] = -1;
        }
        for (int i = 0; i < numRays; i++)
        {
            int sCtxIndex = rays[i].shadingCtxIndex;
            rayIds[sCtxIndex] = rays[i].rayId;
        }
    }
            
    void volumeAggregateMultiScatter(RixIntegratorContext &iCtx,
        int numRays, RtRayGeometry const * rays, bool isCamera,
        ShadeInfo *shadeInfoPing,
        int* numShadingContexts, RixShadingContext const ** shadingContexts,
        int* newNumRays, RtRayGeometry* newRays);

    void getNearestHits(RixIntegratorContext &iCtx,
        int numRays, RtRayGeometry const* rays,
        RixBXLobeTraits const& lobesWanted,
        int* numShadingCtxs,
        RixShadingContext const** shadingCtxs,
        char const* subset,
        char const* excludeSubset,
        bool isPrimary);
    
    // per shading point
    RixRNG::SampleCtx *m_rngSamps;
    RixRNG::SampleCtx *m_chooseSamps;
    RtFloat           *m_chooseXi;

    // per sample
    RtColorRGB *m_emitLight;
    RtColorRGB *m_emitLocal;
    RixBXLobeTraits *m_lobesWanted;
    RixBXLobeTraits *m_lobesEvaluated;
    RixBXLobeSampled *m_lobeSampled;
    RtVector3 *m_PtoL;
    RtFloat   *m_dist;
    RtColorRGB *m_lightTrans;
    RtColorRGB *m_ClDiffuse[k_RixBXMaxNumDiffuseLobes];
    RtColorRGB *m_ClSpecular[k_RixBXMaxNumSpecularLobes];
    RtColorRGB *m_ClUser[k_RixBXMaxNumUserLobes];
    RtColorRGB *m_diffuse[k_RixBXMaxNumDiffuseLobes];
    RtColorRGB *m_specular[k_RixBXMaxNumSpecularLobes];
    RtColorRGB *m_user[k_RixBXMaxNumUserLobes];
    RtColorRGB *m_thruput;
    RtColorRGB *m_thruputToScatter;
    RtInt *m_lightGroupIds;
    RixLPEToken *m_lightLpeTokens;
    bool *m_lightGroupIsHoldout;
    RtFloat *m_lPdfIllum;

    RtVector3 *m_On;

    RtFloat *m_FPdf;
    RtFloat *m_RPdf;
    RtColorRGB *m_compTrans;

    RtRayGeometry *m_rays;
    RtColorRGB *m_backgroundColor;

    // Arrays used by traceRays
    RixRNG::Generator const *m_rngImpl;
    RixRNG::SampleCtx *m_perRayRngCtx;
    RixRNG::SampleCtx *m_perRayRngCtxAll;
    RixRNG::SampleCtx *m_perRayRngCtxSss;
    RixRNG::SampleCtx *m_perRayRngCtxDiff;
    RtRayGeometry *m_raysAll;
    RtRayGeometry *m_raysSss;
    RtRayGeometry *m_raysDiff;

    RixLPEState *m_preSplitLpeState;
    RixLPEState *m_postSplitLpeState;

    ShadeInfo *m_shadeInfoPing;
    ShadeInfo *m_shadeInfoPong;
    bool m_usingPing;

    RtInt *m_cameraRayIds;
    RtInt *m_delegateRayIds;
    bool m_useDelegateRayIds;

    RtFloat m_rouletteProb;
    RtFloat m_rouletteProbInv;

    RixDisplayServices *m_displaySvc;
    RixRefCntPtr<RixLPE> m_rixLpe;

    RtInt      m_numPotentialDiffuseLobes;
    RtInt      m_numPotentialSpecularLobes;
    RtInt      m_numPotentialUserLobes;

    RtInt64    m_bufferMemory;
    RtInt64    m_aovMemory;
    RtFloat3   *m_geoAovColor;
    RtFloat    *m_geoAovFloat;

    // parameters
    RtInt      m_maxPathCount;
    RtInt      m_numLightSamples;
    RtInt      m_numBxdfSamples;
    DepthReduceMode m_reduceDirectSamples;
    RtInt      m_numIndirectSamples;
    RtInt      m_numDiffuseSamples;
    RtInt      m_numSpecularSamples;
    RtInt      m_numSubsurfaceSamples;
    RtInt      m_numRefractionSamples;
    SampleMode m_sampleMode;
    RtInt      m_maxSamples;
    RtInt      m_maxIndSamples;
    RtInt      m_rouletteDepth;
    RtFloat    m_rouletteThreshold;
    RtInt      m_clampDepth;
    RtFloat    m_clampLuminance;
    RtInt      m_allowCaustics;
    RtInt      m_maxPathLength;
    RtInt      m_maxContinuationLength;
    RtInt      m_numLightGroups; 
    RtConstString m_imagePlaneSubset;
    RtInt     *m_geoAovIds;
    RtInt      m_traceDepthMode;
    RtInt      m_accumOpacity;
    RtConstString m_volumeAggregate;
    RtInt64   *m_depthTimers;
    RtInt64   *m_rayCounts;

    struct
    {
        RixIntegratorContext *iCtx;
        int               totalDepth, maxDiffuseDepth, maxSpecularDepth;
        int               lgtSamp;
        int               srfSamp;
        RtFloat           invLgtSamp;
        RtFloat           invSrfSamp;
        ShadeInfo         *shadeInfoPing;
        ShadeInfo         *shadeInfoPong;
    } m_delegateState;

    friend class PxrPathTracer;
};

void 
ptWorker::GetRayDepth(const int* rayId,
                      int numPts, 
                      void const *result) const
{
    ShadeInfo* s = m_usingPing ? m_shadeInfoPing : m_shadeInfoPong;
    int* depths = (int*)(result);
    const int* ids = m_useDelegateRayIds ? m_delegateRayIds : rayId;
    for (int i = 0; i < numPts; ++i)
    {
        if (ids[i] < 0) continue;
        assert(ids[i] < s->size);
        depths[i] = s->rayInfo[ids[i]].depth;
    }
}

void
ptWorker::ResizeArrays(RixContext &ctx)
{
    // Free the old buffers.
    int sz = m_maxSamples * m_maxPathCount;
    for (int i = 0; i < k_RixBXMaxNumDiffuseLobes; i++)
    {
        if (m_ClDiffuse[i])
        {
            m_bufferMemory -= sz * sizeof(RtColorRGB);
            delete[] m_ClDiffuse[i];
            m_ClDiffuse[i] = 0;
        }
        if (m_diffuse[i])
        {
            m_bufferMemory -= sz * sizeof(RtColorRGB);
            delete[] m_diffuse[i];
            m_diffuse[i] = 0;
        }
    }
    for (int i = 0; i < k_RixBXMaxNumSpecularLobes; i++)
    {
        if (m_ClSpecular[i])
        {
            m_bufferMemory -= sz * sizeof(RtColorRGB);
            delete[] m_ClSpecular[i];
            m_ClSpecular[i] = 0;
        }
        if (m_specular[i])
        {
            m_bufferMemory -= sz * sizeof(RtColorRGB);
            delete[] m_specular[i];
            m_specular[i] = 0;
        }
    }
    for (int i = 0; i < k_RixBXMaxNumUserLobes; i++)
    {
        if (m_ClUser[i])
        {
            m_bufferMemory -= sz * sizeof(RtColorRGB);
            delete[] m_ClUser[i];
            m_ClUser[i] = 0;
        }
        if (m_user[i])
        {
            m_bufferMemory -= sz * sizeof(RtColorRGB);
            delete[] m_user[i];
            m_user[i] = 0;
        }
    }

    // Determine the number of potential diffuse vs. specular vs. user lobes.
    if (RixLPEInfo *lpeInfo = (RixLPEInfo *) ctx.GetRixInterface(k_RixLPEInfo))
    {
        m_numPotentialDiffuseLobes = lpeInfo->GetNumPotentialDiffuseLobes();
        m_numPotentialSpecularLobes = lpeInfo->GetNumPotentialSpecularLobes();
        m_numPotentialUserLobes = lpeInfo->GetNumPotentialUserLobes();
    }
    
    // Allocate the new buffers.
    for (int i = 0; i < m_numPotentialDiffuseLobes; i++)
    {
        m_ClDiffuse[i] = new RtColorRGB[sz];
        m_diffuse[i]   = new RtColorRGB[sz];

        m_bufferMemory += sz * 2 * sizeof(RtColorRGB);
    }
    
    for (int i = 0; i < m_numPotentialSpecularLobes; i++)
    {
        m_ClSpecular[i] = new RtColorRGB[sz];
        m_specular[i]   = new RtColorRGB[sz];

        m_bufferMemory += sz * 2 * sizeof(RtColorRGB);
    }

    for (int i = 0; i < m_numPotentialUserLobes; i++)
    {
        m_ClUser[i] = new RtColorRGB[sz];
        m_user[i]   = new RtColorRGB[sz];

        m_bufferMemory += sz * 2 * sizeof(RtColorRGB);
    }
}

void
ptWorker::updateHoldout(ShadeInfo *shadeInfoPing)
{
    for (RtInt g = 0; g < shadeInfoPing->numSctxs; ++g)
    {
        const RixShadingContext* sCtx = shadeInfoPing->sctxs[g];
        bool isHoldout = (RixIsHoldout(*sCtx) > 0);
        for (RtInt p = 0; p < sCtx->numPts; ++p)
        {
            RayInfo &src = shadeInfoPing->rayInfo[sCtx->rayId[p]];
            // False if there is a single non-holdout interaction
            if (src.depth > 0 && !src.scattered) continue;
            if (src.depth == 0 || src.isHoldout) src.isHoldout = isHoldout;
            if (src.depth > 0 && src.isHoldout) src.primaryIsHoldout = true;
            else if (src.depth == 0) src.primaryIsHoldout = src.isHoldout;
        }
    }
}

bool
ptWorker::UpdateLPEs(RixIntegratorContext &iCtx)
{
    bool anyUpdates = false;

    if (RixRefCntPtr<RixLPE> rixLpe = iCtx.GetRixLPE())
    {
        if (m_rixLpe != rixLpe)
        {
            int indSize = m_maxIndSamples * m_maxPathCount;
            
            rixLpe->FreeStates(m_maxPathCount, m_preSplitLpeState);
            rixLpe->FreeStates(indSize, m_postSplitLpeState);
            
            m_preSplitLpeState = rixLpe->AllocateStates(m_maxPathCount);
            m_postSplitLpeState = rixLpe->AllocateStates(indSize);
            
            anyUpdates = true;

            m_rixLpe = rixLpe;
        }
    }

    return anyUpdates;
}

void
ptWorker::IntegrateRays(RixIntegratorContext& ictx,
                        RixBXLobeTraits const& lobesWanted,
                        int* numShadingCtxs,
                        RixShadingContext const** shadingCtxs,
                        RixTimer *timer)
{
    int offset = 0;
    int batchSize;
    int nShdCtxs = 0;
    *numShadingCtxs = 0;

    while (offset < ictx.numActiveRays)
    {
        batchSize = std::min(ictx.numActiveRays - offset, m_maxPathCount);
    
        // Initialize the ray info on the ping buffer
        for (int i = 0; i < batchSize; ++i)
        {
            RtInt iCtxIdx = ictx.primaryRays[i + offset].integratorCtxIndex;
            m_shadeInfoPing->rayInfo[i].weightedThruput  = k_OneRGB;
            m_shadeInfoPing->rayInfo[i].thruput          = k_OneRGB;
            m_shadeInfoPing->rayInfo[i].thruputToScatter = k_OneRGB;
            m_shadeInfoPing->rayInfo[i].depth = 0;
            m_shadeInfoPing->rayInfo[i].diffusedepth = 0;
            m_shadeInfoPing->rayInfo[i].speculardepth = 0;
            m_shadeInfoPing->rayInfo[i].truedepth = 0;
            m_shadeInfoPing->rayInfo[i].sctxIdx = 0;
            m_shadeInfoPing->rayInfo[i].dspIdx = iCtxIdx;
            m_shadeInfoPing->rayInfo[i].sctx = 0;
            m_shadeInfoPing->rayInfo[i].onlyDiffuse = false;
            m_shadeInfoPing->rayInfo[i].sampleType = k_sampleNumTypes;
            m_shadeInfoPing->rayInfo[i].isCollector = false;
            m_shadeInfoPing->rayInfo[i].distanceWritten = false;
            m_shadeInfoPing->rayInfo[i].isHoldout = true;
            m_shadeInfoPing->rayInfo[i].scattered = true;
            m_shadeInfoPing->rayInfo[i].primaryIsHoldout = false;
            m_shadeInfoPing->rayInfo[i].rngSamp = 
                ictx.rngCtx->GetSampleCtx(iCtxIdx);
            if (m_rixLpe->AnyLPEs())
            {
                m_shadeInfoPing->rayInfo[i].lpeState = &m_preSplitLpeState[i];
            }

            // Also initialize our own idea of the rayId on the rays, used
            // to ensure a proper indexing into rayInfo buffers during the
            // subsequent Integrate. All subsequent accesses to the
            // rayInfo should be via the rayId field on the shading ctx.
            ictx.primaryRays[i + offset].rayId = i;
        }

        m_shadeInfoPong->numSctxs = 0;  // for proper init of incidentIsMatte

        RtUInt64 timerStart = timer->SampleTime();

        if (m_volumeAggregate != NULL)
        {
            int nAggregateShadingCtxs = 0;
            int nNewRays = 0;
            volumeAggregateMultiScatter(ictx, batchSize, ictx.primaryRays + offset,
                true, m_shadeInfoPing, &nAggregateShadingCtxs, shadingCtxs,
                &nNewRays, m_rays);
            nShdCtxs = 0;
            ictx.GetNearestHits(nNewRays,
                m_rays,
                lobesWanted,
                false,
                &nShdCtxs,
                shadingCtxs + nAggregateShadingCtxs,
                NULL, /*subset*/
                NULL, /*excludeSubset*/
                false /*isLightPath*/,
                k_SidesFront,
                true  /* primary */
                );
            nShdCtxs += nAggregateShadingCtxs;
        }
        else
        {
            nShdCtxs = 0;
            ictx.GetNearestHits(batchSize,
                ictx.primaryRays + offset,
                lobesWanted,
                false,
                &nShdCtxs,
                shadingCtxs,
                NULL, /*subset*/
                NULL, /*excludeSubset*/
                false /*isLightPath*/,
                k_SidesFront,
                true  /* primary */
                );
        }
        RtUInt64 timerStop = timer->SampleTime();
        m_depthTimers[0] += timerStop - timerStart;
        m_rayCounts[0] += batchSize;
        Integrate(ictx, nShdCtxs, shadingCtxs, timer);
        *numShadingCtxs += nShdCtxs;
        shadingCtxs += nShdCtxs;
        offset += batchSize;
    }
}

void
ptWorker::Integrate(RixIntegratorContext &iCtx,
                    RtInt ngrps, RixShadingContext const *allGrps[],
                    RixTimer* timer)
{
    RixShadingContext const **sctxsBuffer = m_shadeInfoPing->sctxs;
    int firstGrp = 0, npts=0;

    m_rngImpl = iCtx.rngCtx->impl;
    for (int g = 0; g < ngrps; g++)
    {
        RtUInt64 timerStart = timer->SampleTime();

        // Currently renderer only guarantees a max on the size
        // of a single shade context but not on the number of shade
        // contexts.  Here, we operate on that subset of incoming 
        // grps that produces fewer than our configurable maximum.
        RixShadingContext const *sc = allGrps[g];
        npts += sc->numPts;

        if (g == ngrps - 1 || npts + allGrps[g+1]->numPts > m_maxPathCount)
        {
            // Now we're ready to do the integration work for this bunch;
            // Initialize our custom ids and path weightedThruputs / thruputs.
            ShadeInfo *shadeInfoPing = m_shadeInfoPing;
            ShadeInfo *shadeInfoPong = m_shadeInfoPong;
            m_usingPing = true;

            // Store the number of camera hits in this group and temporarily
            // override the shading context pointer to be the camera hits.
            shadeInfoPing->numSctxs = g - firstGrp + 1;
            shadeInfoPing->sctxs = allGrps + firstGrp;

            // Initialize per-context ray depth to be zero.
            // Copy ray ids to m_cameraRayIds, because the primary
            // shading contexts will get deleted.
            for (int i = 0, id = 0; i < shadeInfoPing->numSctxs; i++)
            {
                shadeInfoPing->depthInfo[i].totalDepth = 0;
                RixShadingContext const &sCtx = *shadeInfoPing->sctxs[i];
                for (int j = 0; j < sCtx.numPts; j++, id++)
                {
                    int rayId = sCtx.rayId[j];
                    assert(rayId >= 0 && rayId < m_maxPathCount);
                    m_preSplitLpeState[rayId].MoveCamera(&sCtx, j);
                    m_cameraRayIds[id] = rayId;
                }
            }

            // Loop over the number of indirect bounces (we'll terminate the
            // loop in the code below when there are no further indirect rays,
            // based on the maximum ray depth-related options/attributes).
            int maxRayIdx = 0, rayDepth=0;
            bool cameraHits = true;
            while (true)
            {
                // Update the per light path holdout state
                updateHoldout(shadeInfoPing);

                // Accumulate the throughput and calculate the direct
                // lighting for this bounce.
                directLighting(iCtx, shadeInfoPing, shadeInfoPong);

                // Add in the local emission.
                emitLocal(iCtx, shadeInfoPing);

                // Update the path throughputs by multiplying in the 
                // transmission field of the shading context; the throughputs 
                // are updated only after directLighting() and emitLocal() are 
                // invoked.
                updateThroughputs(iCtx, shadeInfoPing);

                // output standard geometric AOVs
                // make sure we only execute this on camera hits when at least
                // one of the AOVs has been requested, except, for volumes,
                // 'camera hits' should be the real scattering points as opposed to 
                // the volume envelope. 
                if (m_geoAovIds)
                {
                    PxrGeoAOV::Splat(shadeInfoPing->numSctxs, 
                                     shadeInfoPing->sctxs,
                                     m_displaySvc, m_geoAovColor, 
                                     m_geoAovFloat, m_geoAovIds);
                }

                // Fill in the next wave of indirect rays based on mtl samples.
                int rayIdx = 0;
                createRays(iCtx, rayIdx, cameraHits,
                    shadeInfoPing, shadeInfoPong);

                if (rayIdx > 0)
                {
                    // Trace these rays next (rayIdx was computed in
                    // createRays)
                    m_rayCounts[rayDepth] += rayIdx;
                    m_usingPing = !m_usingPing;
                    traceRays(iCtx, rayIdx, m_rays, shadeInfoPing,
                              shadeInfoPong);

                    if (maxRayIdx < rayIdx)
                    {
                        maxRayIdx = rayIdx;
                        assert(maxRayIdx <= m_maxIndSamples * m_maxPathCount);
                    }
                }
                    
                // The core renderer frees shading contexts for camera hits.
                if (!cameraHits)
                {
                    iCtx.ReleaseShadingContexts(shadeInfoPing->numSctxs, 
                                                shadeInfoPing->sctxs);
                }
                else
                {
                    // Reset the shading context pointer back to our buffer;
                    // otherwise, the next time around we'll be operating on 
                    // the wrong set of shading contexts.
                    shadeInfoPing->sctxs = sctxsBuffer;
                }

                // This is the time spent at rayDepth.
                RtUInt64 timerStop = timer->SampleTime();
                m_depthTimers[rayDepth] += timerStop - timerStart;
                timerStart = timerStop;
             
                // If no indirect rays were created then stop.
                if (rayIdx == 0)
                    break;

                // Swap the ping/pong buffer.
                swap(shadeInfoPing, shadeInfoPong);

                cameraHits = false;
                rayDepth += (rayDepth < m_maxPathLength);  //< don't want to exceed max path length in stats timers.
                                                           //  Ray continuation will accumulate to max path length timer.
            }

            // Flush / clear the AOVs.
            if (m_rixLpe->AnyLPEs())
            {
                for (int i = 0; i < npts; i++)
                    m_preSplitLpeState[m_cameraRayIds[i]].Reset();

                // Note: We may or may not have made use of some or all
                // of the LPE states within the m_postSplitLpeState array
                // depending on whether 'doSplit' is ever true in 
                // createRaysHelper. Here, we just call Reset() on all of
                // the LPE states that could have even potentially been
                // used in the loop above (given that the cost is neglible).
                for (int i = 0; i < maxRayIdx; i++)
                    m_postSplitLpeState[i].Reset();
            }

            // now prepare for next iteration
            firstGrp = g + 1; 
            npts = 0;
        }  // end of integration block
    } // end of per-group loop
}

void
ptWorker::GetTransmission(RixIntegratorContext& iCtx,
                          int numRays, RtRayGeometry const* rays,
                          RtColorRGB* trans, char const* subset)
{
    PxrVolumeAggregate volumeAggregate(m_volumeAggregate, iCtx, this, m_maxSamples * m_maxPathCount);
    RtInt* rayId = (RtInt *) alloca(numRays * sizeof(RtInt));
    for (int i = 0; i < numRays; ++i)
        rayId[i] = rays[i].rayId;
    initRNG(numRays, 0x5d43c6f8, false, 1, m_shadeInfoPing->rayInfo, rayId);
    RixRNG rng(iCtx.rngCtx, m_rngSamps, numRays);        
    volumeAggregate.GetTransmission(numRays, rays, &rng, trans);
}

void
ptWorker::PerformDirectLighting(RixShadingContext const &sCtx,
                                RixBXLobeTraits const *lobesWanted,
                                int step)
{
    RixShadingContext const *sctxs = &sCtx;
    if (m_geoAovIds)
    {
        PxrGeoAOV::Splat(1,
            &sctxs,
            m_displaySvc, m_geoAovColor,
            m_geoAovFloat, m_geoAovIds,
            lobesWanted);
    }

    directLightContext(*m_delegateState.iCtx,
                       m_delegateState.totalDepth,
                       m_delegateState.maxDiffuseDepth,
                       m_delegateState.maxSpecularDepth,
                       RixLPE::k_NONE, 
                       false, 
                       m_delegateState.lgtSamp,
                       m_delegateState.srfSamp,
                       m_delegateState.invLgtSamp,
                       m_delegateState.invSrfSamp,
                       sCtx,
                       false,
                       m_delegateState.shadeInfoPing,
                       m_delegateState.shadeInfoPong,
                       lobesWanted,
                       step, false, true, true);
    emitLocalContext(*m_delegateState.iCtx,
                     sCtx, 
                     RixLPE::k_NONE,
                     false, 
                     m_delegateState.shadeInfoPing,
                     lobesWanted, false, true);
}

void
ptWorker::getBackgroundImageColor(RixIntegratorContext &iCtx, 
                                  RixShadingContext const &sCtx,
                                  ShadeInfo *shadeInfoPing,
                                  bool isCollector, 
                                  RtColorRGB *backgroundColor,
                                  RtInt *rayId)
{
    int npoints = sCtx.numPts;
    memset(backgroundColor, 0, sizeof(RtColorRGB) * npoints);

    bool anyCollectors = false;
    for (int i = 0; i < npoints; ++i)
    {
        if (rayId[i] < 0) continue;
        RayInfo const &src = shadeInfoPing->rayInfo[rayId[i]];
        if (src.depth == 0 && isCollector) {
            anyCollectors = true;
            break;
        }
    }

    if (!anyCollectors)
        return;

    RtPoint3 const *P;
    RtNormal3 const *Ngn;
    RtFloat const *curvature; 
    RtFloat const *iradius; 
    RtFloat const *ispread; 
    RtFloat const *biasR;
    RtFloat const *biasT;
    
    sCtx.GetBuiltinVar(RixShadingContext::k_P, &P);
    sCtx.GetBuiltinVar(RixShadingContext::k_Ngn, &Ngn);
    sCtx.GetBuiltinVar(RixShadingContext::k_curvature, &curvature);
    sCtx.GetBuiltinVar(RixShadingContext::k_incidentRaySpread, &ispread);
    sCtx.GetBuiltinVar(RixShadingContext::k_incidentRayRadius, &iradius);
    sCtx.GetBuiltinVar(RixShadingContext::k_biasR, &biasR);
    sCtx.GetBuiltinVar(RixShadingContext::k_biasT, &biasT);
    
    // Fetch the attributes for the hit points in this shading context.
    RtInt autoBias; 
    RtFloat biasVal;
    RtToken reflectSubset, transmitSubset;
    RtToken reflectExcludeSubset, transmitExcludeSubset;
    getIndirectState(sCtx, autoBias, biasVal, 
                     reflectSubset, transmitSubset,
                     reflectExcludeSubset, transmitExcludeSubset); 
    
    int numRays = 0;
    
    for (int i = 0; i < npoints; ++i)
    {
        int ctxIdx = sCtx.integratorCtxIndex[i];
        RayInfo const &src = shadeInfoPing->rayInfo[sCtx.rayId[i]];
        if (src.depth == 0 && isCollector)
        {
            RtRayGeometry &ray = m_rays[numRays];
            RtVector3 dir = (P[i] - iCtx.primaryRays[ctxIdx].origin);
            dir.Normalize();
            
            if (autoBias) 
            { 
                // automatically compute good bias value
                ray.origin = RixApplyTraceBias(P[i], Ngn[i], dir,
                                               biasR[i], biasT[i]);
            } 
            else // use explicitly set Attribute trace bias value
                ray.origin = bias(P[i], Ngn[i], dir, biasVal);
            
            ray.direction = dir;
            ray.maxDist = 1e20f;
            ray.rayId = i;
            ray.originRadius = iradius[i];
            ray.lobeSampled = RixBXLobeSampled();
            ray.wavelength = 0;
            // Compute ray spread for the lobe
            ray.SetRaySpread(RixBXLobeSampled(), 
                             iradius[i],
                             ispread[i],
                             curvature[i],
                             0.0f);
            ray.InitOrigination(&sCtx, Ngn, i);
            ray.lpeState = NULL;
            
            numRays++;
        }
    }
    
    if (numRays > 0)
    {
        RixBXLobeTraits lobes = k_RixBXTraitsAllLobe;
        bool isPrimary = true;
        int nsctxs = 0;
        
        RixShadingContext const** shadeGrps = 
            new RixShadingContext const*[numRays];
        iCtx.GetNearestHits(numRays, m_rays, 
                            lobes,
                            false/* no misses */, &nsctxs, 
                            shadeGrps,
                            m_imagePlaneSubset, NULL, false,
                            isPrimary ? k_SidesFront : k_SidesBoth,
                            isPrimary);
        
        for (int j = 0; j < nsctxs; j++)
        {
            RixShadingContext const *sctx = shadeGrps[j];
            if (!sctx) 
                continue;
            
            RixBxdf *bxdf = sctx->GetBxdf();
            if (!bxdf)
                continue;
            
            bool anyLocalEmission = bxdf->EmitLocal(m_emitLocal);
            if (anyLocalEmission)
            {
                for (int i = 0; i < sctx->numPts; i++)
                {
                    backgroundColor[sctx->rayId[i]] = m_emitLocal[i];
                }
            }
        }
        
        iCtx.ReleaseShadingContexts(nsctxs, shadeGrps);
        delete[] shadeGrps;
    }
}

void
ptWorker::directLightContext(RixIntegratorContext &iCtx, 
                     int totalDepth, int maxDiffuseDepth, int maxSpecularDepth,
                     RixLPEToken lpeGrpId, bool isCollector, 
                     int lgtSamp, int srfSamp, RtFloat invLgtSamp,
                     RtFloat invSrfSamp, RixShadingContext const &sCtx,
                     bool incidentIsMatte,
                     ShadeInfo *shadeInfoPing,
                     ShadeInfo *shadeInfoPong,
                     RixBXLobeTraits const *lobesWanted,
                     int step,
                     bool writeAlpha,
                     bool hasVol,
                     bool isDelegate)
{
    RtInt* rayId = isDelegate? m_delegateRayIds : sCtx.rayId;
    assert(isDelegate == m_useDelegateRayIds);

    RixShadingContext::Allocator memPool(&sCtx);

    // First, ensure we have a valid LPE token and mine one off the shading
    // context if we do not.
    if( lpeGrpId == RixLPE::k_NONE )
        lpeGrpId = resolveLPEToken(sCtx, isCollector);

    // Use the direct lighting optimization. Apply multiple importance
    // sampling: first generate samples on the light and evaluate the
    // bxdf at those locations, then generate directions using the
    // bxdf and evaluate the lights at those directions; combine using
    // the power heuristic.
    RixLightingServices *lightingSvc = iCtx.GetLightingServices();
    RixBxdf &bxdf = *(sCtx.GetBxdf());
    RixBXEvaluateDomain evalDomain = bxdf.GetEvaluateDomain();
    int npoints = sCtx.numPts;
    bool isFinite;
    RtFloat clampAmt;
    RtInt matte = RixIsMatte(sCtx);

    if (step > 0 || !bxdf.GetAllLobeTraits().GetContinuation())
    {
        RtPoint3 const *P;
        sCtx.GetBuiltinVar(RixShadingContext::k_P, &P);
        for (int i = 0; i < npoints; ++i)
        {
            if (rayId[i] < 0) continue;
            int ctxIdx = sCtx.integratorCtxIndex[i];
            RayInfo &src = shadeInfoPing->rayInfo[rayId[i]];
            if (src.depth == 0 && (!lobesWanted || lobesWanted[i].HasAny()))
            {
                // Don't overwrite the distance if a comp trans
                // event has already written it
                if (src.distanceWritten)
                    src.dspIdx = m_displaySvc->AddSample(src.dspIdx);
                float dist = (iCtx.primaryRays[ctxIdx].origin - P[i]).Length();
                m_displaySvc->WriteDistance(
                    src.dspIdx, dist,
                    hasVol && sCtx.scTraits.shadingMode == k_RixSCVolumeScatterQuery );
                src.distanceWritten = true;
            }
        }
    }

    if ( matte )
        for (int i = 0; i < npoints; ++i)
        {
            if (rayId[i] < 0) continue;
            RayInfo &src = shadeInfoPing->rayInfo[rayId[i]];
            if (!src.depth)
                m_displaySvc->FlagAsMatte(src.dspIdx);
        }

    RixLightingServices::Mode lsvcMode = 
        RixLightingServices::k_RespectFixedSampleCount;
    if (m_reduceDirectSamples != k_depthReduceNone) 
    {
        if (totalDepth != 0)
            lsvcMode = RixLightingServices::k_ReducedFixedSampleCount;
    }

    // Pass thruput to lighting; multiply in transmission.
    for (int i = 0; i < npoints; i++) 
    {
        if (rayId[i] < 0) continue;
        RayInfo const &src = shadeInfoPing->rayInfo[rayId[i]];

        m_thruput[i] = src.thruput * sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
        if (!bxdf.GetAllLobeTraits().GetContinuation())
            m_thruputToScatter[i] = k_ZeroRGB;
        else
            m_thruputToScatter[i] = src.thruputToScatter
                * sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
    }
    
    // NB We're only checking for > 0 light samples here, so it's
    // okay to ask lighting services for the total fixed sample
    // count, even if we're in 'reduced' mode, since in that
    // mode it will be non-zero if the total is non-zero
    if ((lgtSamp + lightingSvc->GetTotalFixedSamples() + srfSamp == 0) ||
        evalDomain == k_RixBXEmptyDomain)
    {
        // If there are no light or surface samples, then write alpha and exit.
        if (writeAlpha)
        {
            for (int i = 0; i < npoints; i++) 
            {
                if (rayId[i] < 0) continue;
                RayInfo const &src = shadeInfoPing->rayInfo[rayId[i]];

                bool camVisMatte = (src.depth == 0) && (matte > 0);
                bool camVisHoldout = (src.depth == 0) && (src.isHoldout);
                RtColorRGB eyeTrans;

                if (!writeAlpha)
                    eyeTrans = k_OneRGB;
                else if (incidentIsMatte && camVisMatte) // matte objects before this matte object
                    eyeTrans = k_OneRGB;
                else if (camVisMatte) // no matte objects before this matte object
                    eyeTrans = src.thruputToScatter
                        * sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
                else if (incidentIsMatte) // there is matte objects before this non-matte object
                    eyeTrans = k_OneRGB
                        - src.thruputToScatter
                        * sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
                else if (camVisHoldout)
                    eyeTrans = sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
                else if (src.depth == 0)
                    eyeTrans = m_thruputToScatter[i];
                else
                    eyeTrans = k_OneRGB;

                // If compTrans is turned on, it will be responsible to compute opacity
                // along camera and indirect paths. SplatHelper should not write opacity
                bool writeOpacity = !m_compTrans || (camVisMatte || camVisHoldout);
                RixLPE::SplatHelper aovs(m_displaySvc, src.dspIdx, *m_rixLpe, 
                                         *src.lpeState, 
                                         src.depth,             // depth
                                         -1,                    // lgtGrpId
                                         lpeGrpId,              // lpeGrpId
                                         true,                  // isReflect
                                         eyeTrans,              // eyeTrans
                                         k_OneRGB,              // lgtTrans
                                         &sCtx,                 // shadingCtx
                                         i,                     // shadingCtxIdx
                                         writeOpacity);         // writeOpacity           

                aovs.SplatValue(k_ZeroRGB, k_ZeroRGB, true);
            }
        }
        return;
    }

    // Obtain the background image color for collector objects.
    getBackgroundImageColor(iCtx, sCtx, shadeInfoPing,
                            isCollector, m_backgroundColor,
                            rayId);

    // Setup m_lobesWanted (onlyDiffuse controls allow/disallow caustics).

    for (int i = 0; i < npoints; ++i) 
    {
        if (rayId[i] < 0)
        {
            m_lobesWanted[i].SetNone();
            continue;
        }
        RayInfo const &src = shadeInfoPing->rayInfo[rayId[i]];

        m_lobesWanted[i] = src.onlyDiffuse 
            ? (k_RixBXTraitsAllDiffuse | k_RixBXTraitsAllUser) 
            : k_RixBXTraitsAllLobe;
        if (lobesWanted)
            m_lobesWanted[i] &= lobesWanted[i];

        if (m_traceDepthMode == k_traceDepthModeCombined)
        {
            m_lobesWanted[i].SetMaxDiffuseDepth(src.depth >= maxDiffuseDepth);
            m_lobesWanted[i].SetMaxSpecularDepth(src.depth >= maxSpecularDepth);
        }
        else // if (m_traceDepthMode == k_traceDepthModeSeparate)
        {
            m_lobesWanted[i].SetMaxDiffuseDepth(src.diffusedepth >= maxDiffuseDepth);
            m_lobesWanted[i].SetMaxSpecularDepth(src.speculardepth >= maxSpecularDepth);
        }
    }
    
    // figure out approximately how many indirect samples will be in play
    int indSamp = 1;
    if (totalDepth > 0) {
        int _samps = 0;
        if (m_sampleMode == k_modeBxdf)
        {
            _samps = m_numIndirectSamples;
        }
        else
        {
            _samps = m_numDiffuseSamples + m_numSpecularSamples +
                        m_numSubsurfaceSamples + m_numRefractionSamples;
        }
        // Note: The count for indirect rays must always be <= 1 at 
        // non-camera hits (and passing in k_depthReduceDepth and 
        // direct=false will do this).
        indSamp = computeSampleCount(0, _samps, k_depthReduceDepth, 
                                     1.0f, false);
    }

    bool doRngSplit = (totalDepth == 0);
    // NB We don't trajectory split light samples at the integrator
    // level. Lighting services takes care of the split if necessary
    initRNG(sCtx.numPts, k_rngSamplePattern[k_sampleLight] + step, false,
            1, shadeInfoPing->rayInfo, rayId);
    RixRNG rng(iCtx.rngCtx, m_rngSamps, npoints);


    RtInt fixedSampleCount = 0;
    lightingSvc->Begin(&sCtx, &rng, evalDomain,
                       RixLightingServices::k_MaterialAndLightSamples,
                       lsvcMode, 
                       RixLightingServices::SampleMode(), // defaults 
                       &fixedSampleCount,
                       totalDepth,indSamp);


    if (lsvcMode != RixLightingServices::k_IgnoreFixedSampleCount && 
        fixedSampleCount > 0)
    {
        lgtSamp += fixedSampleCount;
        invLgtSamp = 1.0f / lgtSamp;
    }

    // XXX: if bxdf.GetAllLobeTraits() & Discrete, k_MaterialSamples

    RixBXLobeWeights genContributions(lgtSamp * npoints, 
                                      m_numPotentialDiffuseLobes, 
                                      m_numPotentialSpecularLobes,
                                      m_numPotentialUserLobes,
                                      m_ClDiffuse, 
                                      m_ClSpecular,
                                      m_ClUser);


    RixBXLobeWeights elw(lgtSamp * npoints, 
                         m_numPotentialDiffuseLobes, 
                         m_numPotentialSpecularLobes,
                         m_numPotentialUserLobes,
                         m_diffuse, 
                         m_specular,
                         m_user);

    lightingSvc->GenerateSamples(lgtSamp, &rng, m_lightGroupIds,
                                 m_lightLpeTokens, 
                                 m_PtoL, m_dist, &genContributions,
                                 m_lightTrans, m_lPdfIllum,
                                 m_lobesWanted,
                                 &elw,
                                 m_FPdf,
                                 m_RPdf,
                                 m_lobesEvaluated,
                                 NULL,
                                 m_thruput
                                 );

    RixBXActiveLobeWeights activeMtlLobes, activeLgtLobes;

    elw.GetActiveLobesIntersection(genContributions,
                                   activeMtlLobes,
                                   activeLgtLobes);

    for (int ls = 0; ls < lgtSamp; ls++) 
    {
        int offset = ls * npoints;

        // process results
        for (int i = 0; i < npoints; i++) 
        {
            if (rayId[i] < 0) continue;
            if (lobesWanted && !lobesWanted[i].HasAnyDiffSpec())
                continue;
            int idx = offset + i;

            RayInfo const &src = shadeInfoPing->rayInfo[rayId[i]];
            int lgId = m_lightGroupIds[idx];
            bool isHoldout = src.isHoldout &&
                (lgId < 0 || m_lightGroupIsHoldout[lgId]);
            bool camVisMatte = (src.depth == 0) && (matte > 0);
            bool camVisHoldout = (src.depth == 0) && src.isHoldout;
            RtColorRGB eyeTrans;
            if (!writeAlpha)
                eyeTrans = k_OneRGB;
            else if (incidentIsMatte && camVisMatte) // matte objects before this matte object
                eyeTrans = k_OneRGB;
            else if (camVisMatte) // no matte objects before this matte object
                eyeTrans = src.thruputToScatter 
                           * sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
            else if (incidentIsMatte) // there is matte objects before this non-matte object
                eyeTrans = k_OneRGB 
                           - src.thruputToScatter 
                             * sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
            else if (camVisHoldout)
                eyeTrans = sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
            else if (src.depth == 0)
                eyeTrans = m_thruputToScatter[i];
            else
                eyeTrans = k_OneRGB;

            RtColorRGB lgtTrans = m_lightTrans[idx];
            bool isReflect = m_lobesEvaluated[idx].GetReflect();

            // If compTrans is turned on, it will be responsible to compute opacity
            // along camera and indirect paths. SplatHelper should not write opacity
            bool writeOpacity = !m_compTrans || (camVisMatte || camVisHoldout);
            RixLPE::SplatHelper aovs(m_displaySvc, src.dspIdx, *m_rixLpe, 
                                     *src.lpeState, 
                                     src.depth,               // depth
                                     m_lightLpeTokens[idx],   // lgtGrpId
                                     lpeGrpId,                // lpeGrpId
                                     isReflect,               // isReflect
                                     eyeTrans,                // eyeTrans
                                     lgtTrans,                // lgtTrans
                                     &sCtx,                   // shadingCtx
                                     i,                       // shadingCtxIdx
                                     writeOpacity);           // writeOpacity

            bool zeroShadows = false;
            if (camVisMatte ||
                (m_lPdfIllum[idx] == 0.0f||
                 badSamp(m_lobesEvaluated[idx], m_FPdf[idx], m_lPdfIllum[idx], true) ||
                 m_FPdf[idx] == 0.0f) )
            {
                if (!m_rixLpe->AnyLPEs())
                {
                    aovs.SplatValue(k_ZeroRGB, k_ZeroRGB, true);
                    continue;
                }
                else
                {
                    zeroShadows = true;
                }
            }
            
            RtColorRGB backWgt(m_backgroundColor[i]);
            bool isShadowCollector = ((src.depth == 0 && isCollector) ||
                                      (src.depth >= 1 && src.isCollector));

            RtColorRGB shadowWgt;

            if (zeroShadows)
            {
                // If there are any LPE AOVs, then we may still
                // have a non-zero user lobe weight, so we want
                // to still call SplatPerLobe, but we need to 
                // zero out the diffuse/specular/shadowing terms.
                activeMtlLobes.ZeroAtIndex(idx);
                shadowWgt.Zero();
            }
            else
            {

                // Calculate shadow weight
                RtFloat invPdf = (m_lPdfIllum[idx] != 0.0f) 
                               ? (1.0f / m_lPdfIllum[idx]) : 0.0f;

                RtFloat misW = misWeight(lgtSamp, m_lPdfIllum[idx],
                                         srfSamp, m_FPdf[idx]);

                RtColorRGB wgt(sCtx.transmission[i] * sCtx.pointWeight[i] *
                               misW * invLgtSamp * invPdf);

                shadowWgt = RtColorRGB(sCtx.transmission[i].Luminance() * 
                                       sCtx.pointWeight[i] * 
                                       misW * invLgtSamp);

                // Attenuate the material response by the illumination and weight.
                for (int j = 0; j < activeMtlLobes.GetNumDiffuseLobes(); j++)
                {
                    activeMtlLobes.GetDiffuseLobe(j)[idx] *= 
                        activeLgtLobes.GetDiffuseLobe(j)[idx] * wgt;
                }
                for (int j = 0; j < activeMtlLobes.GetNumSpecularLobes(); j++)
                {
                    activeMtlLobes.GetSpecularLobe(j)[idx] *= 
                        activeLgtLobes.GetSpecularLobe(j)[idx] * wgt;
                }
                // NB: User lobes may contain albedo or objectId values, so avoid
                //     multiplying in any weighting factors to the user lobes here.
            }
            // Determine the clamping amount.
            computeClampDirect(src.depth, lgtTrans, 
                               activeMtlLobes, idx, 
                               src.thruput, invLgtSamp, isFinite, clampAmt);
                
            // Write to the display.
            aovs.SplatPerLobe(activeMtlLobes, idx, shadowWgt, 
                              src.weightedThruput, isFinite, clampAmt, 
                              backWgt, isShadowCollector, isHoldout);
        }
    } // foreach light samp

    // setup RNG for n bxdf GenerateSample() calls 
    initRNG(sCtx.numPts, k_rngSamplePattern[k_sampleBxdfGen] + step, doRngSplit, 
            srfSamp, shadeInfoPing->rayInfo, rayId);

    RixBXLobeWeights lw(srfSamp * npoints, 
                        m_numPotentialDiffuseLobes,
                        m_numPotentialSpecularLobes,
                        m_numPotentialUserLobes,
                        m_diffuse,
                        m_specular,
                        m_user);

    for (int bs = 0; bs < srfSamp; bs++) 
    {
        int offset = bs * npoints;

        // Changing the offset of the lobe weights will write into the lobe 
        // weights at the appropriate offset for this set of bxdf samples.
        lw.SetOffset(offset);

        bxdf.GenerateSample(k_RixBXDirectLighting,
                            m_lobesWanted, 
                            &rng, 
                            m_lobeSampled  + offset, 
                            m_On           + offset, 
                            lw, 
                            m_FPdf         + offset, 
                            m_RPdf         + offset,
                            NULL); // no opacity eval for direct lighting

        for (int i = 0; i < npoints; i++)
            m_dist[offset + i] = 1e20f;
    
        incRNG(sCtx);
    }

    // Reset the offset of the lobe weights back to zero for the code below.
    lw.SetOffset(0);

    RixBXLobeWeights evalContributions(srfSamp * npoints, 
                                       m_numPotentialDiffuseLobes, 
                                       m_numPotentialSpecularLobes,
                                       m_numPotentialUserLobes,
                                       m_ClDiffuse, 
                                       m_ClSpecular,
                                       m_ClUser);


    // setup RNG again for the evaluate samples call 
    initRNG(sCtx.numPts, k_rngSamplePattern[k_sampleBxdfEval] + step, doRngSplit, 
            srfSamp, shadeInfoPing->rayInfo, rayId);

    // Note we are evaluating samples for bxdf values that may be invalid.
    lightingSvc->EvaluateSamples(srfSamp, &rng, m_On, m_dist, 
                                 m_FPdf, &lw, m_lobeSampled,
                                 // outputs
                                 m_lightGroupIds, m_lightLpeTokens,
                                 &evalContributions,
                                 m_lightTrans, m_lPdfIllum,
                                 NULL,
                                 m_thruput
                                 );

    lw.GetActiveLobesIntersection(evalContributions,
                                  activeMtlLobes, activeLgtLobes);
    
    for (int bs = 0; bs < srfSamp; bs++) 
    {
        int offset = bs * npoints;

        // process results
        for (int i = 0; i < npoints; i++) 
        {
            if (rayId[i] < 0) continue;
            if (lobesWanted && !lobesWanted[i].HasAnyDiffSpec())
                continue;
            int idx = offset + i;

            RayInfo const &src = shadeInfoPing->rayInfo[rayId[i]];
            int lgId = m_lightGroupIds[idx];
            bool isHoldout = src.isHoldout &&
                (lgId < 0 || m_lightGroupIsHoldout[lgId]);
            bool camVisMatte = (src.depth == 0) && (matte > 0);
            bool camVisHoldout = (src.depth == 0) && src.isHoldout;
            RtColorRGB eyeTrans;

            if (!writeAlpha)
                eyeTrans = k_OneRGB;
            else if (incidentIsMatte && camVisMatte) // matte objects before this also matte object
                eyeTrans = k_OneRGB;
            else if (camVisMatte) // no matte objects before this
                eyeTrans = src.thruputToScatter 
                           * sCtx.transmission[i] * sCtx.pointWeight[i]* sCtx.pointSampleCount[i];
            else if (incidentIsMatte) // there are matte objects before this non-matte object
                eyeTrans = k_OneRGB 
                           - src.thruputToScatter 
                             * sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
            else if (camVisHoldout)
                eyeTrans = sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
            else if (src.depth == 0)
                eyeTrans = m_thruputToScatter[i];
            else
                eyeTrans = k_OneRGB;

            RtColorRGB lgtTrans = m_lightTrans[idx];
            bool isReflect = m_lobeSampled[idx].GetReflect();

            // If compTrans is turned on, it will be responsible to compute opacity
            // along camera and indirect paths. SplatHelper should not write opacity
            bool writeOpacity = !m_compTrans || (camVisMatte || camVisHoldout);
            RixLPE::SplatHelper aovs(m_displaySvc, src.dspIdx, *m_rixLpe,
                                     *src.lpeState, 
                                     src.depth,               // depth
                                     m_lightLpeTokens[idx],   // lgtGrpId
                                     lpeGrpId,                // lpeGrpId
                                     isReflect,               // isReflect
                                     eyeTrans,                // eyeTrans
                                     lgtTrans,                // lgtTrans
                                     &sCtx,                   // shadingCtx
                                     i,                       // shadingCtxIdx
                                     writeOpacity);           // writeOpacity

            bool zeroShadows = false;
            if (camVisMatte ||
                badSamp(m_lobeSampled[idx], m_FPdf[idx], m_lPdfIllum[idx], false) ||
                (m_lPdfIllum[idx] == 0.0f || m_FPdf[idx] == 0.0f))
            {
                if (!m_rixLpe->AnyLPEs())
                {
                    aovs.SplatValue(k_ZeroRGB, k_ZeroRGB, true);
                    continue;
                }
                else
                {
                    zeroShadows = true;
                }
            }

            RtColorRGB backWgt(m_backgroundColor[i]);
            bool isShadowCollector = ((src.depth == 0 && isCollector) ||
                                      (src.depth >= 1 && src.isCollector));

            RtColorRGB shadowWgt;

            if (zeroShadows)
            {
                    // If there are any LPE AOVs, then we may still
                    // have a non-zero user lobe weight, so we want
                    // to still call SplatPerLobe, but we need to 
                    // zero out the diffuse/specular/shadowing terms.
                    activeMtlLobes.ZeroAtIndex(idx);
                    shadowWgt.Zero();
            }
            else
            {
                // Calculate shadow weight
                RtFloat invPdf = (m_FPdf[idx] != 0.0f) 
                               ? (1.0f / m_FPdf[idx]) : 0.0f;

                RtFloat misW = 0.0f;
                if (m_lobeSampled[idx].GetDiscrete())
                    misW = 1.f;
                else
                    misW = misWeight(srfSamp, m_FPdf[idx], 
                                     lgtSamp, m_lPdfIllum[idx]);
            
                RtColorRGB wgt(sCtx.transmission[i] * sCtx.pointWeight[i] *
                               misW * invSrfSamp * invPdf);
                shadowWgt = RtColorRGB(wgt.Luminance() * m_lPdfIllum[idx]);

                // Attenuate the material response by the illumination and weight.
                for (int j = 0; j < activeMtlLobes.GetNumDiffuseLobes(); j++)
                {
                    activeMtlLobes.GetDiffuseLobe(j)[idx] *= 
                        activeLgtLobes.GetDiffuseLobe(j)[idx] * wgt;
                }
                for (int j = 0; j < activeMtlLobes.GetNumSpecularLobes(); j++)
                {
                    activeMtlLobes.GetSpecularLobe(j)[idx] *= 
                        activeLgtLobes.GetSpecularLobe(j)[idx] * wgt;
                }
                // NB: User lobes may contain albedo or objectId values, so avoid
                //     multiplying in any weighting factors to the user lobes here.
            }
            // Determine the clamping amount.
            computeClampDirect(src.depth, lgtTrans, 
                               activeMtlLobes, idx, 
                               src.thruput, invSrfSamp, isFinite, clampAmt);

            // Write to the display.
            aovs.SplatPerLobe(activeMtlLobes, idx, shadowWgt, 
                              src.weightedThruput, isFinite, clampAmt,
                              backWgt, isShadowCollector, isHoldout);
        }
    }
    lightingSvc->End();
}

void
ptWorker::directLighting(RixIntegratorContext &iCtx,
                         ShadeInfo *shadeInfoPing,
                         ShadeInfo *shadeInfoPong)
{

    for (int g = 0; g < shadeInfoPing->numSctxs; g++) 
    {
        RixShadingContext const &sCtx = *shadeInfoPing->sctxs[g];

        // This is not very pretty but it gets the job done.
        // If pong has zero shading contexts, it means we are at the very first
        // wave.  Otherwise, we can safely use ping's incidentSctxIsMatte.
        bool incidentIsMatte = shadeInfoPong->numSctxs > 0 
                               ? shadeInfoPing->incidentSctxIsMatte[g] : false;
        int totalDepth = shadeInfoPing->depthInfo[g].totalDepth;

        int npoints = sCtx.numPts;

        // Don't continue any further if there are no surface hits to
        // deal with
        if(!sCtx.HasHits()) {
            continue;
        }

        float maxThruput;

        if (m_reduceDirectSamples == k_depthReduceThruputMax) {
            // figure out maximal throughput
            maxThruput = 0.0f;
            for (int i = 0; i < npoints; ++i) 
            {
                int id = sCtx.rayId[i];
                RayInfo &src = shadeInfoPing->rayInfo[id];
                float t = src.thruput.ChannelMax();
                t = std::min(1.0f,t);
                maxThruput = std::max(maxThruput,t);
            }
        } else if (m_reduceDirectSamples == k_depthReduceThruputAvg ||
                   m_reduceDirectSamples == k_depthReduceDepthThruputAvg) {
            // figure out average throughput
            maxThruput = 0.0f;
            for (int i = 0; i < npoints; ++i) 
            {
                int id = sCtx.rayId[i];
                RayInfo &src = shadeInfoPing->rayInfo[id];
                float t = src.thruput.ChannelMax();
                t = std::min(1.0f,t);
                maxThruput += t;
            }
            maxThruput = maxThruput/(float)npoints;
        } else if (m_reduceDirectSamples == k_depthReduceThruputGAvg) {
            // figure out geometric average throughput
            maxThruput = 1.0f;
            for (int i = 0; i < npoints; ++i) 
            {
                int id = sCtx.rayId[i];
                RayInfo &src = shadeInfoPing->rayInfo[id];
                float t = src.thruput.ChannelMax();
                t = std::min(1.0f,t);
                maxThruput *= t;
            }
            maxThruput = powf(maxThruput,1.0f/(float)npoints);
        }

        // Diffuse-only surfaces use 1/2 the specified bxdf samples.
        // Diffuse material samples are really only useful very close
        // to the light and otherwise light samples are better.
        // The bxdf sample count however was specified to cope with denoising
        // glossy sample counts, and so for that we need the material samples.
        // When we're fully diffuse, use fewer bxdf samples.
        int effectiveBxdfSamps = m_numBxdfSamples; 
        RixBXLobeTraits lobes = sCtx.GetBxdf()->GetAllLobeTraits();
        if (!(lobes & k_RixBXTraitsAllSpecular).HasAnyDiffSpec())
            effectiveBxdfSamps = std::max(effectiveBxdfSamps>>1,
                                          m_numBxdfSamples?1:0);

        bool hasVol = sCtx.HasVolume(k_RixSCAnyVolume);
        bool hasSss = sCtx.HasSubsurface();
        bool hasCon = lobes.GetContinuation();

        int lgtSamp = computeSampleCount(totalDepth, m_numLightSamples,
                                         m_reduceDirectSamples, maxThruput,
                                         true, hasSss, hasCon);
        int srfSamp = computeSampleCount(totalDepth, effectiveBxdfSamps, 
                                         m_reduceDirectSamples, maxThruput,
                                         true, hasSss, hasCon);

        RtFloat invLgtSamp = (lgtSamp != 0) ? (1.0f / lgtSamp) : 1.0f;
        RtFloat invSrfSamp = (srfSamp != 0) ? (1.0f / srfSamp) : 1.0f;

        // NB: we assume directLighting precedes indirect (with whom we
        //  share the maxDiffuseDepth and maxSpecularDepth values).
        getDirectState(sCtx, 
                       shadeInfoPing->depthInfo[g].maxDiffuseDepth,
                       shadeInfoPing->depthInfo[g].maxSpecularDepth,
                       shadeInfoPing->depthInfo[g].lpeGrpId,
                       shadeInfoPing->depthInfo[g].isCollector);

        directLightContext(iCtx, totalDepth, 
                           shadeInfoPing->depthInfo[g].maxDiffuseDepth,
                           shadeInfoPing->depthInfo[g].maxSpecularDepth,
                           shadeInfoPing->depthInfo[g].lpeGrpId, 
                           shadeInfoPing->depthInfo[g].isCollector, 
                           lgtSamp, srfSamp,
                           invLgtSamp, invSrfSamp, sCtx, incidentIsMatte,
                           shadeInfoPing, 
                           shadeInfoPong,
                           NULL, 0, true, hasVol);
    }
}

void
ptWorker::emitLocalContext(RixIntegratorContext &iCtx,
                           RixShadingContext const &sCtx,
                           RixLPEToken lpeGrpId,
                           bool isCollector, 
                           ShadeInfo *shadeInfoPing,
                           RixBXLobeTraits const *lobesWanted,
                           bool writeAlpha,
                           bool isDelegate)
{
    RtInt* rayId = isDelegate? m_delegateRayIds : sCtx.rayId;

    RixBxdf &bxdf = *(sCtx.GetBxdf());
    int npoints = sCtx.numPts;
    bool isFinite;
    RtFloat clampAmt;
    
    // First, ensure we have a valid LPE token and mine one off the shading
    // context if we do not.
    if( lpeGrpId == RixLPE::k_NONE )
        lpeGrpId = resolveLPEToken(sCtx, isCollector);

    bool anyLocalEmission = bxdf.EmitLocal(m_emitLocal);

    if (sCtx.GetLightEmission(m_emitLight))
    {
        // if there was local emission, we add the light emission
        if (anyLocalEmission)
        {
            for (int i = 0; i < npoints; i++)
            {
                m_emitLocal[i] += m_emitLight[i];
            }
        }
        // else we copy light emission into local emission
        else
        {
            memcpy(m_emitLocal, m_emitLight, sizeof(RtColorRGB) * npoints);
            anyLocalEmission = true;
        }
    }

    if (anyLocalEmission)
    {
        RtInt matte = RixIsMatte(sCtx);
        for (int i = 0; i < npoints; i++)
        {
            if (rayId[i] < 0) continue;
            if (lobesWanted && !lobesWanted[i].HasAnyDiffSpec())
                continue;            
            
            RayInfo const &src = shadeInfoPing->rayInfo[rayId[i]];

            bool camVisMatte = (src.depth == 0) && (matte > 0);
            bool camVisHoldout = (src.depth == 0) && (src.isHoldout);
            RtColorRGB eyeTrans;

            // Analytic lights generate continuation rays to implement an
            // 'accumulative' behavior for camera rays. But we still want 
            // to see them in the alpha, so we need to add '|| sCtx.light'
            // to the continuation traits conditional
            if (!writeAlpha)
                eyeTrans = k_OneRGB;
            else if (camVisMatte || camVisHoldout)
                eyeTrans = sCtx.transmission[i] * sCtx.pointWeight[i];
            else if (src.depth == 0)
            {
                if (!bxdf.GetAllLobeTraits().GetContinuation() || sCtx.light)
                    eyeTrans = k_ZeroRGB;
                else
                    eyeTrans = src.thruputToScatter
                        * sCtx.transmission[i] * sCtx.pointWeight[i];
            }
            else
                eyeTrans = k_OneRGB;

            RtColorRGB val = m_emitLocal[i] * sCtx.transmission[i] * 
                                              sCtx.pointWeight[i];

            // If compTrans is turned on, it will be responsible to compute opacity
            // along camera and indirect paths. SplatHelper should not write opacity
            bool writeOpacity = !m_compTrans || (camVisMatte || camVisHoldout);
            RixLPE::SplatHelper aovs(m_displaySvc, src.dspIdx, *m_rixLpe,
                                     *src.lpeState, 
                                     src.depth,               // depth
                                     -1,                      // lgtGrpId
                                     lpeGrpId,                // lpeGrpId
                                     true,                    // isReflect
                                     eyeTrans,                // eyeTrans
                                     k_OneRGB,                // lgtTrans
                                     &sCtx,                   // shadingCtx
                                     i,                       // shadingCtxIdx
                                     writeOpacity);
            
            if (camVisMatte)
            {
                aovs.SplatValue(k_ZeroRGB, k_ZeroRGB, true);
                continue;
            }

            computeClampEmissive(src.depth, val, src.thruput, 
                                 isFinite, clampAmt);

            bool isShadowCollector = ((src.depth == 0 && isCollector) ||
                                      (src.depth >= 1 && src.isCollector));

            aovs.SplatEmission(val, src.weightedThruput, isFinite, clampAmt,
                               isShadowCollector, src.isHoldout);
        }
    }
}

void
ptWorker::emitLocal(RixIntegratorContext &iCtx,
                    ShadeInfo *shadeInfoPing)
{
    // Add in any local emission (via EmitLocal() from the bxdf).
    for (int g = 0; g < shadeInfoPing->numSctxs; g++) 
    {
        RixShadingContext const &sCtx = *shadeInfoPing->sctxs[g];
        if(sCtx.HasHits())
        {
            // The lpeGrpId in shadeInfoPing was set by directLighting()
            RixLPEToken lpeGrpId = shadeInfoPing->depthInfo[g].lpeGrpId;
            bool isCollector = shadeInfoPing->depthInfo[g].isCollector;
            emitLocalContext(iCtx, sCtx, lpeGrpId, isCollector, 
                             shadeInfoPing, NULL);
        }
    }
}

void
ptWorker::updateThroughputs(RixIntegratorContext &iCtx,
                            ShadeInfo *shadeInfoPing)
{
    for (int g = 0; g < shadeInfoPing->numSctxs; g++) 
    {
        RixShadingContext const &sCtx = *shadeInfoPing->sctxs[g];
        int npoints = sCtx.numPts;

        // Don't continue any further if there are no surface hits to
        // deal with
        if(!sCtx.HasHits()) {
            continue;
        }

        // Accumulate throughput attenuation by participating media
        // in front of the hit into the total throughput
        for (int i = 0; i < npoints; ++i) 
        {
            int id = sCtx.rayId[i];
            RayInfo &src = shadeInfoPing->rayInfo[id];
            src.thruput *= sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
            src.weightedThruput *= sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
        }
    }
}

void
ptWorker::createRays(RixIntegratorContext &iCtx, int &rayIdx, bool cameraHits, 
                     ShadeInfo *shadeInfoPing, ShadeInfo *shadeInfoPong)
{
    if (cameraHits && m_sampleMode == k_modeManual)
    {
        const int k_numTypes = 4;
        SampleType sampleTypes[] = { k_sampleDiffuse,
                                     k_sampleSpecular,
                                     k_sampleSubsurface, 
                                     k_sampleRefraction };
        
        for (int i = 0; i < k_numTypes; i++)
        {
            createRaysHelper(iCtx, sampleTypes[i], rayIdx,
                             shadeInfoPing, shadeInfoPong);
        }
    }
    else
    {
        createRaysHelper(iCtx, k_sampleIndirect, rayIdx,
                         shadeInfoPing, shadeInfoPong);
    }
}

void
ptWorker::createRaysHelper(RixIntegratorContext &iCtx, 
                           SampleType sampleType, 
                           int &rayIdx,
                           ShadeInfo *shadeInfoPing, ShadeInfo *shadeInfoPong)
{
    for (int g = 0; g < shadeInfoPing->numSctxs; g++) 
    {
        RixShadingContext const &sCtx = *shadeInfoPing->sctxs[g];
        if(!sCtx.HasHits())
            continue;

        // NB: we assume that getDirectState has been called prior to 
        //     this point.
        int totalDepth = shadeInfoPing->depthInfo[g].totalDepth;
        int maxDiffDepth = shadeInfoPing->depthInfo[g].maxDiffuseDepth; 
        int maxSpecDepth = shadeInfoPing->depthInfo[g].maxSpecularDepth; 
        RixLPEToken lpeGrpId = shadeInfoPing->depthInfo[g].lpeGrpId;
        bool isCollector = shadeInfoPing->depthInfo[g].isCollector;
        RixBxdf &bxdf = *(sCtx.GetBxdf());

        // If the Bxdf indicates the possibility of continuation, we
        // increment the depth limiter by one. If we are at the
        // maximum depth, we only allow continuation rays to be fired
        int continueStep =
            bxdf.GetAllLobeTraits().GetContinuation() ? 1 : 0;
        int npoints = sCtx.numPts;

        RtInt matte = RixIsMatte(sCtx);

        // Compute how many indirect rays to send.
        int indSamp;
        int samps = 0;
        if (m_sampleMode == k_modeBxdf)
        {
            samps = m_numIndirectSamples;
        }
        else
        {
            switch (sampleType)
            {
                case k_sampleDiffuse: 
                    samps = m_numDiffuseSamples; 
                    break;
                case k_sampleSpecular:
                    samps = m_numSpecularSamples;
                    break;
                case k_sampleSubsurface:
                    samps = m_numSubsurfaceSamples;
                    break;
                case k_sampleRefraction:
                    samps = m_numRefractionSamples;
                    break;
                default:
                    samps = 1;
                    break;
            }
        }

        indSamp = computeSampleCount(totalDepth, samps, k_depthReduceDepth, 
                                     1.0f, false,
                                     sCtx.HasSubsurface(),
                                     bxdf.GetAllLobeTraits().GetContinuation());

        if (indSamp == 0)
            continue;

        RtFloat invIndSamp = (indSamp != 0) ? (1.0f / indSamp) : 1.0f;
        
        // Fetch the attributes for the hit points in this shading context.
        RtInt autoBias; 
        RtFloat biasVal;
        RtToken reflectSubset, transmitSubset;
        RtToken reflectExcludeSubset, transmitExcludeSubset;
        getIndirectState(sCtx, autoBias, biasVal, 
                         reflectSubset, transmitSubset,
                         reflectExcludeSubset, transmitExcludeSubset); 

        shadeInfoPong->depthInfo[g].reflectSubset = reflectSubset;
        shadeInfoPong->depthInfo[g].transmitSubset = transmitSubset;
        shadeInfoPong->depthInfo[g].reflectExcludeSubset = reflectExcludeSubset;
        shadeInfoPong->depthInfo[g].transmitExcludeSubset = transmitExcludeSubset;

        // Cull the rays we would create based on depth (including the
        // trace:maxdiffusedepth and trace:maxspeculardepth attributes).
        bool anyValid = false;
        for (int i = 0; i < npoints; i++)
        {
            int id = sCtx.rayId[i];
            const RayInfo &src = shadeInfoPing->rayInfo[id];
            RixBXLobeTraits lobes;

            if (src.depth < (m_maxPathLength + continueStep) &&
                src.truedepth < m_maxContinuationLength)
            {
                // Note: It would be possible to add more user attributes,
                // user options, and/or integrator parameters that would
                // independently control the lobes we request here for
                // max transmission (diffuse/glossy/specular) depth vs. 
                // max reflection   (diffuse/glossy/specular) depth; that 
                // is, one could have, for example, six knobs to control 
                // the max ray depth for each of the six canonical lobes in
                // the RixBXLobeTrait enum. 
                // However, we currently choose in this integrator to 
                // support just the existing trace:maxdiffusedepth and 
                // trace:maxspeculardepth attributes in order to keep 
                // the number of knobs that are exposed to the user to a
                // minimum (that said, being able to control transmission
                // depth independently of glossy/specular reflection depth
                // can be useful in some cases; e.g., one could add support
                // for a "user:maxtransmissiondepth" attribute). With the 
                // code here, the max glossy/specular 
                // reflection/transmission ray depths are all controlled by
                // the one trace:maxspeculardepth attribute.
                if (m_traceDepthMode == k_traceDepthModeCombined)
                {
                    if (src.depth < (maxDiffDepth + continueStep))
                        lobes |= k_RixBXTraitsAllDiffuse;
                    if (src.depth < (maxSpecDepth + continueStep) &&
                        (!src.onlyDiffuse))
                        lobes |= k_RixBXTraitsAllSpecular;
                }
                else // if (m_traceDepthMode == k_traceDepthModeSeparate)
                {
                    if (src.diffusedepth < (maxDiffDepth + continueStep))
                        lobes |= k_RixBXTraitsAllDiffuse;
                    if (src.speculardepth < (maxSpecDepth + continueStep) &&
                        (!src.onlyDiffuse))
                        lobes |= k_RixBXTraitsAllSpecular;
                }
            }

            if (sampleType == k_sampleDiffuse)
                lobes &= k_RixBXTraitsReflectDiffuse;
            else if (sampleType == k_sampleSpecular)
                lobes &= k_RixBXTraitsReflectSpecular;
            else if (sampleType == k_sampleSubsurface)
                lobes &= k_RixBXTraitsTransmitDiffuse;
            else if (sampleType == k_sampleRefraction)
                lobes &= k_RixBXTraitsTransmitSpecular;

            if (lobes.HasAnyDiffSpec())
            {
                lobes |= k_RixBXTraitsAllUser;

                if (!anyValid)
                    anyValid = true;
            }

            m_lobesWanted[i] = lobes;
        }

        // If no lobes were requested for any of the hit points in this
        // shading context, then the bxdf.GenerateSample() call below will 
        // return no valid samples, and so we might as well immediately skip
        // to the hit points in the next shading context.
        if (!anyValid)
            continue;

        // setup RNG for n bxdf GenerateSample calls 
        bool doRngSplit = (totalDepth == 0);
        initRNG(sCtx.numPts, k_rngSamplePattern[sampleType], doRngSplit, 
                indSamp, shadeInfoPing->rayInfo, sCtx.rayId);
        RixRNG rng(iCtx.rngCtx, m_rngSamps, npoints);

        // setup a second RNG for choosing the lobe
        initChooseRNG(sCtx.numPts, doRngSplit, indSamp, shadeInfoPing->rayInfo,
                      sCtx.rayId);
        RixRNG chooseRNG(iCtx.rngCtx, m_chooseSamps, npoints);
        
        RixBXLobeWeights lw(indSamp * npoints, 
                            m_numPotentialDiffuseLobes,
                            m_numPotentialSpecularLobes,
                            m_numPotentialUserLobes,
                            m_diffuse,
                            m_specular,
                            m_user);

        if (m_compTrans) memset(m_compTrans, 0, sizeof(RtColorRGB) * indSamp * npoints);

        // Generate the indirect ray directions based on the bxdf.
        for (int bs = 0; bs < indSamp; bs++) 
        {
            int offset = bs * npoints;

            // Changing the offset of the lobe weights will write into the lobe 
            // weights at the appropriate offset for this set of bxdf samples.
            lw.SetOffset(offset);

            bxdf.GenerateSample(k_RixBXIndirectLighting,
                m_lobesWanted, 
                &rng, 
                m_lobeSampled  + offset, 
                m_On           + offset, 
                lw, 
                m_FPdf         + offset, 
                m_RPdf         + offset,
                m_compTrans ? m_compTrans + offset : NULL);

            // After having sampled the bxdf, importance sample the lobe weights
            // and select one lobe from the, possibly multiple, set of lobe
            // responses.
            // Draw the samples we will use to choose the lobe
            chooseRNG.DrawSamples1D( npoints, m_chooseXi );
            RixBXChooseLobe( npoints, m_chooseXi, lw, m_lobeSampled + offset );

            for (int i = 0; i < npoints; i++)
                m_dist[offset + i] = 1e20;
            
            incRNG(sCtx);
            incChooseRNG(sCtx);
        }

        // Reset the offset of the lobe weights back to zero for the code below.
        lw.SetOffset(0);

        RixBXActiveLobeWeights activeLobes;
        lw.GetActiveLobes(activeLobes);

        // setup RNG for n Russian Roulette events.
        initRNG(sCtx.numPts, k_rngRoulettePattern[sampleType], doRngSplit, 
                indSamp, shadeInfoPing->rayInfo, sCtx.rayId);
        
        RtPoint3 const *P;
        RtNormal3 const *Nn;
        RtNormal3 const *Ngn;
        RtFloat const *curvature; 
        RtFloat const *iradius; 
        RtFloat const *ispread; 
        RtFloat const *biasR;
        RtFloat const *biasT;
        RtFloat const *wavelength;
        sCtx.GetBuiltinVar(RixShadingContext::k_P, &P);
        sCtx.GetBuiltinVar(RixShadingContext::k_Nn, &Nn);
        sCtx.GetBuiltinVar(RixShadingContext::k_Ngn, &Ngn);
        sCtx.GetBuiltinVar(RixShadingContext::k_curvature, &curvature);
        sCtx.GetBuiltinVar(RixShadingContext::k_incidentRaySpread, &ispread);
        sCtx.GetBuiltinVar(RixShadingContext::k_incidentRayRadius, &iradius);
        sCtx.GetBuiltinVar(RixShadingContext::k_biasR, &biasR);
        sCtx.GetBuiltinVar(RixShadingContext::k_biasT, &biasT);
        sCtx.GetBuiltinVar(RixShadingContext::k_wavelength, &wavelength);

        // For continuation rays, we only allow one indirect sample. So use indSamp.
        // For any other case, we use m_numIndirectSamples at the first hits, and that
        // is what we should use here.
        float invNumIndirectGl = bxdf.GetAllLobeTraits().GetContinuation() ? 
                                 1.0f / indSamp :
                                 1.0f / m_numIndirectSamples;
        
        bool hasVol = sCtx.HasVolume(k_RixSCAnyVolume);

        for (int bs = 0; bs < indSamp; bs++) 
        {
            // process results
            for (int i = 0; i < npoints; i++) 
            {
                int idx = bs * npoints + i;
                int id = sCtx.rayId[i];
                RayInfo &src = shadeInfoPing->rayInfo[id];

                // Don't trace indirect rays off of camera rays that hit
                // matte objects (although continuation rays are okay).
                // Note: we do want to trace indirect rays off of spawned 
                // indirect rays that hit matte objects in order to obtain 
                // the same GI on camera visible non-matte objects.
                if ((matte > 0) && !m_lobeSampled[idx].GetContinuation() && 
                    src.depth == 0)
                {
                    continue;
                }

                // We need to do this even
                // if the ray has been rejected (eg because
                // it's not a continuation ray, and we
                // have reached maximum path length)

                // In the presence of comp trans at an initial
                // depth, we updated alpha in the framebuffer based
                // on a result for fdirect lighting. That result
                // is only correct for the final vertex on a ray path.
                // Now that the indirect ray has been generated by the bxdf, we
                // need to correct the transmission, which will be 0
                // for a reflection ray, or the bxdf's desired transmission
                // divided by the probability of choosing the refract
                // direction. This is accumulated with the ray's 
                // previously recorded thruputToScatter and the transmission
                // between the previous vertex and this one at the bxdf's surface
                if (m_compTrans && !src.primaryIsHoldout && !matte)
                {
                    RtColorRGB eyeTrans = src.thruputToScatter *
                                          sCtx.transmission[i] *
                                          sCtx.pointWeight[i] * 
                                          sCtx.pointSampleCount[i] *
                                          m_compTrans[idx];

                    RtColorRGB opacity = k_OneRGB - eyeTrans;
                    
                    // Since alpha is accumulated along the path, at every new bounce we replace
                    // the old alpha value with the new one. This works out to be to splat the difference
                    // between new and old alpha
                    // at ray true depth 0, there is no 'old alpha' because it is the first time
                    // we do compTrans.
                    RtColorRGB opacityOld = src.truedepth == 0 
                                            ? k_ZeroRGB : (k_OneRGB - src.thruputToScatter);

                    RtColorRGB opacityDiff = (opacity - opacityOld) * invNumIndirectGl;

                    // NB SplatOpacity ignores the channel id
                    m_displaySvc->SplatOpacity(0, src.dspIdx, opacityDiff); 
                }

                if (badSamp(m_lobeSampled[idx], m_FPdf[idx], 0.0f, false))
                {
                    continue;
                }


                // If we are the maximum depth, we only allow
                // continuation rays to be fired
                if (src.depth == m_maxPathLength &&
                    m_lobeSampled[idx].GetScattering())
                {
                    continue;
                }

                RtColorRGB newWeightedThruput;
                RtColorRGB newThruput;
                RtColorRGB newThruputToScatter;
                RtFloat    invPdf = 1.0f / m_FPdf[idx]; // non-zero if here
                RtColorRGB wgt = invPdf * invIndSamp * 
                                     sCtx.transmission[i] * sCtx.pointWeight[i];

                RtColorRGB mtlResponse = activeLobes.SumAtIndex(idx);
                RtColorRGB thruputSrf = mtlResponse * invPdf;

                // New total throughput terms
                newWeightedThruput = (src.weightedThruput * thruputSrf * 
                                      invIndSamp);
                newThruput = src.thruput * thruputSrf;
                newThruputToScatter = src.thruputToScatter *
                    sCtx.transmission[i] * sCtx.pointWeight[i] * sCtx.pointSampleCount[i];
                if (m_compTrans) newThruputToScatter *= m_compTrans[idx];
                
                bool doSkip = false;

                if (newWeightedThruput == k_ZeroRGB)
                    doSkip = true;

                // Perform Russian Roulette (adjust weightedThruput to 
                // compensate).
                if (!doSkip &&
                    m_rouletteDepth >= 0 &&
                    // If bxdf indicates continuation, we wouldn't
                    // actually increment the depth by one
                    (totalDepth + (bxdf.GetAllLobeTraits().GetContinuation() ? 0 : 1)) >= m_rouletteDepth &&
                    totalDepth < m_maxPathLength &&
                    (!m_compTrans || src.thruputToScatter.ChannelAvg() <= 0.0f))
                {
                    // We apply Russian Roulette fairly conservatively in 
                    // order to avoid situations where the acceptance 
                    // probability is so low that significant paths are 
                    // effectively never accepted. We ensure that the 
                    // cumulative acceptance probability (across all 
                    // termination events) never goes below a reasonable 
                    // minimum to avoid spiking the variance (yielding 
                    // fireflies / etc.).
                    float lum = newWeightedThruput.Luminance();
                    if (lum < m_rouletteThreshold)
                    {
                        // Don't stratify Russian Roulette random numbers.
                        if (hashToRandom(m_rngSamps[i].sampleid, 
                                         m_rngSamps[i].patternid) > 
                            m_rouletteProb)
                        {
                            doSkip = true;
                        }
                        
                        newWeightedThruput *= m_rouletteProbInv;
                        newThruput *= m_rouletteProbInv;
                        wgt *= m_rouletteProbInv;
                    }
                }
                
                if (!doSkip)
                {
                    RtRayGeometry &ray = m_rays[rayIdx];
                    RtVector3 dir = m_On[idx];
                    dir.Normalize();
                    RixBXLobeSampled lobeSampled = m_lobeSampled[idx];

                    if (autoBias) 
                    { 
                        // automatically compute good bias value
                        ray.origin = RixApplyTraceBias(P[i], Ngn[i], dir,
                                                       biasR[i], biasT[i]);
                    } 
                    else // use explicitly set Attribute trace bias value
                        ray.origin = bias(P[i], Ngn[i], dir, biasVal);

                    ray.direction = dir;
                    ray.maxDist = 1e20f;
                    ray.rayId = rayIdx;
                    ray.originRadius = iradius[i];
                    ray.lobeSampled = lobeSampled;
                    ray.wavelength  = RtRayGeometry::EncodeWavelength(wavelength[i]);
                    // Compute ray spread for the lobe
                    ray.SetRaySpread(lobeSampled,
                                     iradius[i],
                                     ispread[i],
                                     curvature[i],
                                     m_FPdf[idx]);
                    // 
                    ray.InitOrigination(&sCtx, Ngn, i);

                    // Store the updated throughput, ray depth, the current
                    // shading context and the "parent" random number context
                    // in the ping/pong buffer so that we can access this 
                    // information in traceRays() below and at the next batch 
                    // of ray hits.
                    RayInfo &dst        = shadeInfoPong->rayInfo[rayIdx];
                    dst.weightedThruput = newWeightedThruput;
                    dst.thruput         = newThruput;

                    // Increment ray depth only if the lobe sampled
                    // indicated a scattering event occurred
                    bool isScatteringEvent = lobeSampled.GetScattering();
                    dst.depth           = isScatteringEvent ?
                                            src.depth + 1 : src.depth;

                    if (isScatteringEvent && !lobeSampled.GetUser())
                    {
                        // (Do not count subsurface as a diffuse bounce)
                        dst.diffusedepth    = 
                            (lobeSampled.GetDiffuse() && 
                             !lobeSampled.LobeIdIsSubsurface())
                            ? (src.diffusedepth + 1) : src.diffusedepth;

                        dst.speculardepth   = !lobeSampled.GetDiffuse()
                            ? (src.speculardepth + 1) : src.speculardepth;
                    }
                    else
                    {
                        dst.diffusedepth = src.diffusedepth;
                        dst.speculardepth = src.speculardepth;
                    }

                    dst.scattered       = isScatteringEvent;
                    dst.truedepth       = src.truedepth + 1;
                    dst.sctxIdx         = g;
                    dst.dspIdx          = src.dspIdx;
                    dst.sctx            = &sCtx;
                    dst.rngSamp         = m_rngSamps[i];
                    dst.distanceWritten = src.distanceWritten;

                    if (!isScatteringEvent)
                    {
                        dst.onlyDiffuse = src.onlyDiffuse;
                    }
                    else
                    {
                        dst.onlyDiffuse = m_allowCaustics ? false : 
                            (src.onlyDiffuse || 
                             lobeSampled.GetDiffuse());
                    }

                    if (lobeSampled.GetTransmit() || !isScatteringEvent)
                    {                       
                        dst.thruputToScatter = newThruputToScatter;
                    }
                    else
                    {                        
                        dst.thruputToScatter = k_ZeroRGB;                        
                    }

                    // At camera hits, the sampleType and lobeTraits are set
                    // to that at the camera hit; at secondary hits, use the
                    // sampleType/lobeTraits of the originating camera hit.
                    dst.sampleType = findSampleType(src.sampleType, 
                                                    lobeSampled, 
                                                    src.depth);

                    if (src.depth == 0)
                        dst.isCollector = isCollector;
                    else
                        dst.isCollector = src.isCollector;

                    // Update holdout from src
                    dst.isHoldout = src.isHoldout;
                    dst.primaryIsHoldout = src.primaryIsHoldout;

                    // Update the lpeState for the LPE AOVs.
                    if (m_rixLpe->AnyLPEs())
                    {
                        // Note: As controlled by computeSampleCount(), we 
                        // will have a splitting/branching factor greater than
                        // one at most once along any given individual ray path.
                        // At the moment, we split/branch at the first scattering
                        // event after the initial camera hit. We can tell when 
                        // there is a split because the number of indirect samples 
                        // (e.g., 'indSamp') will be greater than 1. When we split,
                        // we switch to using the LPE states in the 
                        // m_postSplitLpeState array (since we want a different 
                        // LPE state per split ray path).

                        bool doSplit = (indSamp > 1);
                        if (doSplit) 
                        {
                            dst.lpeState = &m_postSplitLpeState[rayIdx];
                            if (hasVol)
                            {
                                // In the case of the volume, the split doesn't happen
                                // immediately, so we need to use the more expensive copy
                                // constructor, which will copy extra state over including
                                // throughput.
                                *dst.lpeState = *src.lpeState;
                            }
                            else
                            {       
                                // If this is a hard surface we can just update the pointer and 
                                // redo camera state transition (since we always 
                                // split at the first scattering event after the 
                                // initial camera hit if we ever split).                         
                                dst.lpeState->MoveCamera(&sCtx, i);
                            }
                        }
                        else
                        {
                            dst.lpeState = src.lpeState;
                        }

                        ray.lpeState = dst.lpeState;

                        // Attenuate the material response by the weight.
                        activeLobes.MultiplyByWeightAtIndex(idx, wgt);
                        // Update the LPE states
                        RixLPEScatterEvent scatterEvent(lobeSampled);
                        dst.lpeState->MoveVertex
                            (&sCtx, i, scatterEvent, 
                             activeLobes.SumAtIndex(idx) * sCtx.pointSampleCount[i],
                             lpeGrpId, isScatteringEvent);
                    }
                    else
                    {
                        ray.lpeState = NULL;
                    }
                    
                    rayIdx++;
                }
            } 
            
            incRNG(sCtx);
        } // foreach indSamp
    }
}

// This function takes a number of rays and generates a number of 
// shading contexts from the rays subject to:
// (1) Each shading context has at most 'batchSize' number of rays in them.
// (2) We expect all rays to have the same volume behavior, so either
// all of them are volume rays or none is. 
// If these is no volumetric behavior in these rays, no split is needed because 
// ptWorker::GetNearestHits (SpIntegratorCtx::GetNearestHits) will be called
// which guarantees that all the shading contexts created are properly sized. 
// Otherwise we will split rays into batches before calling volumeIntegrator's
// GetNearestHits because volume integrator has no knowledge of maxShadingSize.
// In the volume case, this func will make sure all the points 
// within the shading batch have unique shadingCtxIndex. 
void
ptWorker::splitRaysIntoShadingCtxs(RixIntegratorContext &iCtx, 
                                   int nRays, 
                                   RtRayGeometry *rays,
                                   RixBXLobeTraits const &lobesWanted,
                                   RixRNG::SampleCtx *perRayRngCtx,
                                   RtInt *delegateRayIds,
                                   RixShadingContext const *firstSctx,
                                   RtToken subset,
                                   RtToken excludeSubset,
                                   bool isPrimary,
                                   bool isIncident,
                                   int &nSctxsBatch, // out
                                   RixShadingContext const **&sctxsTmp) // out
{
    // If numIndirectSamples > 1, we need to guarantee unique shadingCtxIndex
    // within any batch.
    // Given the current implementation of createRaysHelper, the rays given to us
    // will be laid out as follows: first sample drawn for all points, second sample
    // drawn for all points, and so on.
    // This makes it easy to do the batching fast with little overhead
    RixShadingContext::Allocator memPool(firstSctx);
    bool* isUsed = memPool.Allocate<bool>(m_maxPathCount);
    int isUsedArraySize = sizeof(bool)* m_maxPathCount;

    int nvsctx = 0;
    int raysToBatch = nRays;
    int curIndex = 0;
    int s;
    while (raysToBatch > 0)
    {
        memset(isUsed, 0, isUsedArraySize);
        for (s = curIndex; s < nRays; s++)
        {
            if (isUsed[rays[s].shadingCtxIndex])
            {
                // this means we are at a new sample 
                // and need to break up from previous batch
                break;
            }
            else
            {
                isUsed[rays[s].shadingCtxIndex] = true;
            }
        }

        int size = s - curIndex;
        // run batch
        RixVolumeIntegrator *vol = isIncident ?
            firstSctx->BeginIncidentVol(size, rays + curIndex)
            : firstSctx->BeginOppositeVol(size, rays + curIndex);
        if (vol)
        {
            RixRNG volRNG(iCtx.rngCtx, perRayRngCtx + curIndex, size);



            setDelegateRayIds(size, rays + curIndex, delegateRayIds);
            m_useDelegateRayIds = true;
            vol->GetNearestHits(size, rays + curIndex, &volRNG,
                lobesWanted, iCtx,
                iCtx.GetLightingServices(),
                this,
                &nvsctx, sctxsTmp,
                subset, excludeSubset, false,
                isPrimary ? k_SidesFront : k_SidesBoth,
                isPrimary);
            nSctxsBatch += nvsctx;
            sctxsTmp += nvsctx;
            firstSctx->EndVolume(vol);
            m_useDelegateRayIds = false;
        }
        else
        {
            // No volume from this batch means no volume at all. Call
            // SpIntegratorCtx::getNearestHits and break out of loop
            // AllLobe is fine since there's no additional hidden bounces within
            getNearestHits(iCtx, nRays, rays,
                k_RixBXTraitsAllLobe,
                &nvsctx, sctxsTmp,
                subset, excludeSubset,
                isPrimary);
            nSctxsBatch += nvsctx;
            sctxsTmp += nvsctx;
            break;
        }

        curIndex = s;
        raysToBatch -= size;
    }
}

void
ptWorker::traceRays(RixIntegratorContext &iCtx, 
                    int nRays, RtRayGeometry *rays,
                    ShadeInfo *shadeInfoPing,
                    ShadeInfo *shadeInfoPong)
{
    shadeInfoPong->numSctxs = 0;
    RixShadingContext const **sctxs = shadeInfoPong->sctxs;
    bool *incidentSctxIsMatte = shadeInfoPong->incidentSctxIsMatte;
    DepthInfo *depthInfo = shadeInfoPong->depthInfo;

    int curPos = 0;
    int curSctxPos = 0;
    while (nRays > 0)
    {
        int nRaysBatch = nRays;
        if (nRaysBatch > k_maxRaysPerBatch)
            nRaysBatch = k_maxRaysPerBatch; 

        int nSctxsBatch = 0; // counts the number of additional sctxs produced

        // Ensure that all rays in batch have same interior or no interior
        // and have the same depth
        RixShadingContext const *firstSctx =shadeInfoPong->rayInfo[curPos].sctx;
        int firstDepth = shadeInfoPong->rayInfo[curPos].depth;
        int firstSctxIdx = shadeInfoPong->rayInfo[curPos].sctxIdx;
        RtToken firstSubsetR = shadeInfoPong->depthInfo[firstSctxIdx].reflectSubset;
        RtToken firstSubsetT = shadeInfoPong->depthInfo[firstSctxIdx].transmitSubset;
        RtToken firstExcludeSubsetR = shadeInfoPong->depthInfo[firstSctxIdx].reflectExcludeSubset;
        RtToken firstExcludeSubsetT = shadeInfoPong->depthInfo[firstSctxIdx].transmitExcludeSubset;
        bool isPrimary = (firstDepth == 0);
        bool hasSss = firstSctx->HasSubsurface();
        bool hasVol = firstSctx->HasVolume(k_RixSCAnyVolume);
        bool incidentIsMatte = RixIsMatte((*firstSctx)) > 0;
       if (hasSss || hasVol) 
            m_perRayRngCtx[0] = shadeInfoPong->rayInfo[curPos].rngSamp;

        for (int i = curPos+1; i < curPos+nRaysBatch; i++)
        {
            RixShadingContext const *sCtx = shadeInfoPong->rayInfo[i].sctx;
            int sctxIdx = shadeInfoPong->rayInfo[i].sctxIdx;
            RtToken subsetR = shadeInfoPong->depthInfo[sctxIdx].reflectSubset;
            RtToken subsetT = shadeInfoPong->depthInfo[sctxIdx].transmitSubset;
            RtToken excludeSubsetR = shadeInfoPong->depthInfo[sctxIdx].reflectExcludeSubset;
            RtToken excludeSubsetT = shadeInfoPong->depthInfo[sctxIdx].transmitExcludeSubset;
        
            if (shadeInfoPong->rayInfo[i].depth != firstDepth ||
                (firstSubsetR != subsetR || firstSubsetT != subsetT) || 
                (firstExcludeSubsetR != excludeSubsetR || firstExcludeSubsetT != excludeSubsetT) || 
                (hasVol && sCtx != firstSctx) ||
                (!hasVol && sCtx->HasVolume(k_RixSCAnyVolume)) ||
                (hasSss && sCtx != firstSctx) ||
                (!hasSss && sCtx->HasSubsurface()))
            {
                nRaysBatch = i - curPos;
                break;
            }
            else 
            if (hasSss || hasVol)
            {
                // We want to provide the per-ray "parent" random
                // number context to the interior integrator below so
                // that it can spawn new domains (using the
                // NewDomain() method of the rng ctx) for generating
                // stratified and non-repeating random numbers.
                m_perRayRngCtx[i-curPos] = shadeInfoPong->rayInfo[i].rngSamp;
            }
        }

        assert(nRaysBatch <= nRays);
        assert(!hasVol || shadeInfoPong->rayInfo[curPos].sctx ==
               shadeInfoPong->rayInfo[curPos+nRaysBatch-1].sctx);
        assert(shadeInfoPong->rayInfo[curPos].depth ==
               shadeInfoPong->rayInfo[curPos+nRaysBatch-1].depth);

        if (!hasSss && !hasVol) 
        {
            RixBXLobeTraits lobes = k_RixBXTraitsAllLobe;
            if( !m_allowCaustics )
            {
                // Minor optimization:
                // Assume only diffuse rays and change the type on discovery of
                // a specular scatter event.
                // This allows bxdf writers to avoid doing specular specific
                // work during BeginScatter (e.g. texture lookups)
                lobes = k_RixBXTraitsAllDiffuse;
                for( int i = curPos; i < curPos + nRaysBatch; i++ )
                {
                    if( !shadeInfoPong->rayInfo[i].onlyDiffuse )
                    {
                        lobes = k_RixBXTraitsAllLobe;
                        break;
                    }
                }
            }

            int g = shadeInfoPong->rayInfo[curPos].sctxIdx;
            RtToken reflectSubset = shadeInfoPong->depthInfo[g].reflectSubset;
            RtToken transmitSubset = shadeInfoPong->depthInfo[g].transmitSubset;
            RtToken reflectExcludeSubset = shadeInfoPong->depthInfo[g].reflectExcludeSubset;
            RtToken transmitExcludeSubset = shadeInfoPong->depthInfo[g].transmitExcludeSubset;

            if (reflectSubset == NULL && transmitSubset == NULL &&
                reflectExcludeSubset == NULL && transmitExcludeSubset == NULL)
            {
                // Iterate over source rays. Test for diffuse only batches
                getNearestHits(iCtx, nRaysBatch, rays + curPos, lobes,
                               &nSctxsBatch, sctxs,
                               NULL, NULL,
                               isPrimary);
            }
            else
            {
                // Here we split the rays up into two batches: reflect and transmit
                int nRaysAllR = 0, nRaysAllT = 0;
                for (int i = curPos; i < curPos + nRaysBatch; i++)
                {
                    int idst;
                    if(rays[i].lobeSampled.GetTransmit())
                    {
                        // fill T from the back...  (tricky index alert)
                        idst = k_maxRaysPerBatch - ++nRaysAllT;
                    }
                    else
                        idst = nRaysAllR++;
                    m_raysAll[idst] = rays[i];
                }
                
                RixShadingContext const **sctxsTmp = sctxs;
                
                if (nRaysAllR > 0)
                {
                    int nvsctx = 0;
                    getNearestHits(iCtx, nRaysAllR, m_raysAll, 
                                   lobes,
                                   &nvsctx, sctxsTmp,
                                   reflectSubset, reflectExcludeSubset,
                                   isPrimary);
                    nSctxsBatch += nvsctx;
                    sctxsTmp += nvsctx;
                }
                
                if (nRaysAllT > 0)
                {
                    // Transmission: call sss interior integrator if there is one
                    int nvsctx = 0;
                    int tindex = k_maxRaysPerBatch - nRaysAllT;
                    RtRayGeometry *_rays = m_raysAll + tindex;
                    
                    getNearestHits(iCtx, nRaysAllT, _rays,
                                   lobes,
                                   &nvsctx, sctxsTmp,
                                   transmitSubset, transmitExcludeSubset,
                                   isPrimary);
                    
                    nSctxsBatch += nvsctx;
                    sctxsTmp += nvsctx;
                }
            }
        } 
        else if (hasSss && !hasVol)
        {
            // Let the subsurf interior integrator generate the ray hit sctxs.
            // Results are written into sctxs transmission and are multiplied
            // onto the thruput in directLighting().
            // Here we split the rays up into two batches: those that should
            // be onlyDiffuse, and the rest. These are further divided into 
            // two groups (reflect and transmit) -- similar to the volume case.
            // Transmission rays are passed to the subsurface interior 
            // integrator, reflection rays are not.

            int nRaysDiffR = 0, nRaysDiffT = 0;
            int nRaysAllR = 0, nRaysAllT = 0;
            int nRaysS = 0;

            for (int i = curPos; i < curPos + nRaysBatch; i++)
            {
                bool transmit = rays[i].lobeSampled.GetTransmit();
                bool subsurf = rays[i].lobeSampled.LobeIdIsSubsurface();

                // Put sss rays in separate buffer
                if (transmit && subsurf)
                {
                    // Note: Let's not do tricky indices;
                    //       just use a separate buffer.
                    int idst = nRaysS++;
                    m_raysSss[idst] = rays[i];
                    m_perRayRngCtxSss[idst] = m_perRayRngCtx[i - curPos];
                }

                // Split other rays into diff/all refl/trans buffers
                if (shadeInfoPong->rayInfo[i].onlyDiffuse == true)
                {
                    int idst;
                    if (transmit)
                    {
                        if (!subsurf)
                        {
                            // fill T from the back...  (tricky index alert)
                            idst = k_maxRaysPerBatch - ++nRaysDiffT;
                            m_raysDiff[idst] = rays[i];
                            m_perRayRngCtxDiff[idst] = m_perRayRngCtx[i - curPos];
                        }
                    }
                    else
                    {
                        idst = nRaysDiffR++;
                        m_raysDiff[idst] = rays[i];
                        m_perRayRngCtxDiff[idst] = m_perRayRngCtx[i - curPos];
                    }
                }
                else // not only diffuse
                {
                    int idst;
                    if (transmit)
                    {
                        if (!subsurf)
                        {
                            // fill T from the back...  (tricky index alert)
                            idst = k_maxRaysPerBatch - ++nRaysAllT;
                            m_raysAll[idst] = rays[i];
                            m_perRayRngCtxAll[idst] = m_perRayRngCtx[i - curPos];
                        }
                    }
                    else
                    {
                        idst = nRaysAllR++;
                        m_raysAll[idst] = rays[i];
                        m_perRayRngCtxAll[idst] = m_perRayRngCtx[i - curPos];
                    }
                }
            }

            // Save delegate state needed for any interior direct
            // lighting requests
            m_delegateState.iCtx = &iCtx;
            m_delegateState.totalDepth = firstDepth;

            m_delegateState.lgtSamp = m_numLightSamples;
            m_delegateState.srfSamp = m_numBxdfSamples;
            m_delegateState.invLgtSamp = 1.0f / m_numLightSamples;
            m_delegateState.invSrfSamp = 1.0f / m_numBxdfSamples;
            m_delegateState.shadeInfoPing = shadeInfoPong;
            m_delegateState.shadeInfoPong = shadeInfoPing;

            int g = shadeInfoPong->rayInfo[curPos].sctxIdx;
            m_delegateState.maxDiffuseDepth = shadeInfoPing->depthInfo[g].maxDiffuseDepth;
            m_delegateState.maxSpecularDepth = shadeInfoPing->depthInfo[g].maxSpecularDepth;
            RixShadingContext const **sctxsTmp = sctxs;

            RtToken reflectSubset = shadeInfoPong->depthInfo[g].reflectSubset;
            RtToken transmitSubset = shadeInfoPong->depthInfo[g].transmitSubset;
            RtToken reflectExcludeSubset = shadeInfoPong->depthInfo[g].reflectExcludeSubset;
            RtToken transmitExcludeSubset = shadeInfoPong->depthInfo[g].transmitExcludeSubset;

            if (nRaysAllR > 0)
            {
                // Reflection rays
                int nvsctx = 0;
                getNearestHits(iCtx, nRaysAllR, m_raysAll, 
                               k_RixBXTraitsAllLobe,
                               &nvsctx, sctxsTmp,
                               reflectSubset, reflectExcludeSubset,
                               isPrimary);
                nSctxsBatch += nvsctx;
                sctxsTmp += nvsctx;
            }

            if (nRaysDiffR > 0)
            {
                // Diffuse reflection rays
                int nvsctx = 0;
                getNearestHits(iCtx, nRaysDiffR, m_raysDiff, 
                               k_RixBXTraitsAllLobe,
                               &nvsctx, sctxsTmp,
                               reflectSubset, reflectExcludeSubset,
                               isPrimary);
                nSctxsBatch += nvsctx;
                sctxsTmp += nvsctx;
            }

            if (nRaysAllT > 0)
            {
                // Transmission
                int nvsctx = 0;
                int tindex = k_maxRaysPerBatch - nRaysAllT;
                RtRayGeometry *_rays = m_raysAll + tindex;
                // AllLobe is fine since
                // there's no additional hidden bounces within
                getNearestHits(iCtx, nRaysAllT, _rays,
                               k_RixBXTraitsAllLobe,
                               &nvsctx, sctxsTmp,
                               transmitSubset, transmitExcludeSubset,
                               isPrimary);

                nSctxsBatch += nvsctx;
                sctxsTmp += nvsctx;
            }

            if (nRaysDiffT > 0)
            {
                // Diffuse transmission
                int nvsctx = 0;
                int tindex = k_maxRaysPerBatch - nRaysDiffT;
                RtRayGeometry *_rays = m_raysDiff + tindex;
                // AllLobe is fine since
                // there's no additional hidden bounces within
                getNearestHits(iCtx, nRaysDiffT, _rays,
                               k_RixBXTraitsAllLobe,
                               &nvsctx, sctxsTmp,
                               transmitSubset, transmitExcludeSubset,
                               isPrimary);
                nSctxsBatch += nvsctx;
                sctxsTmp += nvsctx;
            }

            if (nRaysS > 0)
            {
                // Subsurface
                int nvsctx = 0;
                RtRayGeometry *_rays = m_raysSss;
                RixVolumeIntegrator *sss = NULL;
                sss = firstSctx->BeginSubsurface(nRaysS, _rays);
                assert(sss);
                RixRNG sssRNG(iCtx.rngCtx, m_perRayRngCtxSss, nRaysS);
                setDelegateRayIds(nRaysS, _rays, m_delegateRayIds);
                m_useDelegateRayIds = true;
                sss->GetNearestHits(nRaysS, _rays, &sssRNG,
                                    k_RixBXTraitsAllLobe, iCtx,
                                    iCtx.GetLightingServices(),
                                    this,
                                    &nvsctx, sctxsTmp,
                                    transmitSubset, transmitExcludeSubset, false,
                                    isPrimary ? k_SidesFront : k_SidesBoth,
                                    isPrimary);
                firstSctx->EndSubsurface(sss);
                m_useDelegateRayIds = false;
                nSctxsBatch += nvsctx;
                sctxsTmp += nvsctx;
            }
        }
        else if (hasVol && !hasSss)
        {
            // Let the volume interior integrator generate the ray hit sctxs.
            // Results are written into sctxs transmission and are multiplied
            // onto the thruput in directLighting().
            // Here we split the rays up into two batches: those that should
            // be onlyDiffuse (e.g., no caustics), and the rest. These
            // are further divided into two groups (reflect and refract)
            // with the refraction rays passed to the interior or exterior
            // shader according to normal.

            int nRaysDiffR = 0, nRaysDiffT = 0;
            int nRaysAllR = 0, nRaysAllT = 0;
            for (int i = curPos; i < curPos + nRaysBatch; i++)
            {
                if (shadeInfoPong->rayInfo[i].onlyDiffuse == true)
                {
                    int idst;
                    if(rays[i].lobeSampled.GetTransmit())
                    {
                        // fill T from the back...  (tricky index alert)
                        idst = k_maxRaysPerBatch - ++nRaysDiffT;
                    }
                    else
                        idst = nRaysDiffR++;
                    m_raysDiff[idst] = rays[i];
                    m_perRayRngCtxDiff[idst] = m_perRayRngCtx[i-curPos];
                }
                else
                {
                    int idst;
                    if(rays[i].lobeSampled.GetTransmit())
                    {
                        // fill T from the back...  (tricky index alert)
                        idst = k_maxRaysPerBatch - ++nRaysAllT;
                    }
                    else
                        idst = nRaysAllR++;
                    m_raysAll[idst] = rays[i];
                    m_perRayRngCtxAll[idst] = m_perRayRngCtx[i - curPos];
                }
            }
            
            // Save delegate state needed for any interior direct
            // lighting requests
            m_delegateState.iCtx = &iCtx;
            m_delegateState.totalDepth = firstDepth;

            // Volumes currently only allowed to take at most a single
            // surface/light sample for direct lighting. Should we
            // wish to change this in the future, this code is where
            // we store a computed sample count.

            m_delegateState.lgtSamp = m_numLightSamples ? 1 : 0;
            m_delegateState.srfSamp = m_numBxdfSamples ? 1 : 0;
            m_delegateState.invLgtSamp = 1.0f;
            m_delegateState.invSrfSamp = 1.0f;
            m_delegateState.shadeInfoPing = shadeInfoPong;
            m_delegateState.shadeInfoPong = shadeInfoPing;
        
            int g = shadeInfoPong->rayInfo[curPos].sctxIdx;
            m_delegateState.maxDiffuseDepth = shadeInfoPing->depthInfo[g].maxDiffuseDepth;
            m_delegateState.maxSpecularDepth = shadeInfoPing->depthInfo[g].maxSpecularDepth;

            RtToken reflectSubset = shadeInfoPong->depthInfo[g].reflectSubset;
            RtToken transmitSubset = shadeInfoPong->depthInfo[g].transmitSubset;
            RtToken reflectExcludeSubset = shadeInfoPong->depthInfo[g].reflectExcludeSubset;
            RtToken transmitExcludeSubset = shadeInfoPong->depthInfo[g].transmitExcludeSubset;

            RixShadingContext const **sctxsTmp = sctxs;
            if (nRaysAllR > 0)
            {
                splitRaysIntoShadingCtxs(iCtx,
                    nRaysAllR,
                    m_raysAll,
                    k_RixBXTraitsAllLobe,
                    m_perRayRngCtxAll,
                    m_delegateRayIds,
                    firstSctx,
                    reflectSubset,
                    reflectExcludeSubset,
                    isPrimary,
                    true, //incident
                    nSctxsBatch,
                    sctxsTmp);
            }
                         
            if (nRaysDiffR > 0)
            {
                // The 'onlyDiffuse' reflect rays (e.g., no caustics).
                splitRaysIntoShadingCtxs(iCtx,
                    nRaysDiffR, 
                    m_raysDiff,
                    (k_RixBXTraitsAllDiffuse | k_RixBXTraitsAllUser),
                    m_perRayRngCtxDiff,
                    m_delegateRayIds,
                    firstSctx,
                    reflectSubset,
                    reflectExcludeSubset,
                    isPrimary,
                    true, //incident
                    nSctxsBatch,
                    sctxsTmp);
            }

            if (nRaysAllT > 0)
            {
                int tindex = k_maxRaysPerBatch - nRaysAllT;
                RtRayGeometry *_rays = m_raysAll + tindex;

                splitRaysIntoShadingCtxs(iCtx,
                    nRaysAllT,
                    _rays, 
                    k_RixBXTraitsAllLobe,
                    m_perRayRngCtxAll + tindex,
                    m_delegateRayIds,
                    firstSctx,
                    transmitSubset,
                    transmitExcludeSubset,
                    isPrimary,
                    false, // opposite 
                    nSctxsBatch,
                    sctxsTmp);
            }

            if (nRaysDiffT > 0)
            {
                // The 'onlyDiffuse' reflect rays (e.g., no caustics).
                int tindex = k_maxRaysPerBatch - nRaysDiffT;
                RtRayGeometry *_rays = m_raysDiff + tindex;

                splitRaysIntoShadingCtxs(iCtx,
                    nRaysDiffT,
                    _rays,
                    (k_RixBXTraitsAllDiffuse | k_RixBXTraitsAllUser),
                    m_perRayRngCtxDiff + tindex,
                    m_delegateRayIds,
                    firstSctx,
                    transmitSubset,
                    transmitExcludeSubset,
                    isPrimary,
                    false, // opposite
                    nSctxsBatch,
                    sctxsTmp);
            }
        }
        else // hasVol && hasSss
        {
            // Let the subsurface and volume interior integrators generate the
            // ray hit sctxs.
            // Results are written into sctxs transmission and are multiplied
            // onto the thruput in directLighting().
            // Here we split the rays up into two batches: those that should
            // be subsurface and those that should be volume.
            // The rays are further divided into two groups (reflect
            // and refract).

            assert(hasVol && hasSss);

            // Reuse Diff and All buffers for Sss and Vol.  This sharing
            // is for memory savings, but use clearer names locally
            RixRNG::SampleCtx *perRayRngCtxSss = m_perRayRngCtxDiff;
            RixRNG::SampleCtx *perRayRngCtxVol = m_perRayRngCtxAll;
            RtRayGeometry *raysSss = m_raysDiff;
            RtRayGeometry *raysVol = m_raysAll;

            int nRaysSssR = 0, nRaysSssT = 0; // (maybe these can be merged?)
            int nRaysVolR = 0, nRaysVolT = 0;
            for (int i = curPos; i < curPos + nRaysBatch; i++)
            {
                RixBXLobeSampled s = rays[i].lobeSampled;

                if (s.LobeIdIsSubsurface())
                {
                    int idst;
                    if(rays[i].lobeSampled.GetTransmit())
                    {
                        // fill T from the back...  (tricky index alert)
                        idst = k_maxRaysPerBatch - ++nRaysSssT;
                    }
                    else
                        idst = nRaysSssR++;
                    raysSss[idst] = rays[i];
                    perRayRngCtxSss[idst] = m_perRayRngCtx[i-curPos];
                }
                else
                {
                    int idst;
                    if(rays[i].lobeSampled.GetTransmit())
                    {
                        // fill T from the back...  (tricky index alert)
                        idst = k_maxRaysPerBatch - ++nRaysVolT;
                    }
                    else
                        idst = nRaysVolR++;
                    raysVol[idst] = rays[i];
                    perRayRngCtxVol[idst] = m_perRayRngCtx[i - curPos];
                }
            }

            // Save delegate state needed for any interior direct
            // lighting requests
            m_delegateState.iCtx = &iCtx;
            m_delegateState.totalDepth = firstDepth;

            // Volumes currently only allowed to take at most a single
            // surface/light sample for direct lighting. Should we
            // wish to change this in the future, this code is where
            // we store a computed sample count.

            m_delegateState.lgtSamp = m_numLightSamples ? 1 : 0;
            m_delegateState.srfSamp = m_numBxdfSamples ? 1 : 0;
            m_delegateState.invLgtSamp = 1.0f;
            m_delegateState.invSrfSamp = 1.0f;
            m_delegateState.shadeInfoPing = shadeInfoPong;
            m_delegateState.shadeInfoPong = shadeInfoPing;
        
            int g = shadeInfoPong->rayInfo[curPos].sctxIdx;
            m_delegateState.maxDiffuseDepth = shadeInfoPing->depthInfo[g].maxDiffuseDepth;
            m_delegateState.maxSpecularDepth = shadeInfoPing->depthInfo[g].maxSpecularDepth;

            RtToken reflectSubset = shadeInfoPong->depthInfo[g].reflectSubset;
            RtToken transmitSubset = shadeInfoPong->depthInfo[g].transmitSubset;
            RtToken reflectExcludeSubset = shadeInfoPong->depthInfo[g].reflectExcludeSubset;
            RtToken transmitExcludeSubset = shadeInfoPong->depthInfo[g].transmitExcludeSubset;

            RixShadingContext const **sctxsTmp = sctxs;
            if (nRaysVolR > 0)
            {
                splitRaysIntoShadingCtxs(iCtx,
                    nRaysVolR,
                    raysVol,
                    k_RixBXTraitsAllLobe,
                    perRayRngCtxVol,
                    m_delegateRayIds,
                    firstSctx,
                    reflectSubset,
                    reflectExcludeSubset,
                    isPrimary,
                    true, // incident
                    nSctxsBatch,
                    sctxsTmp);
            }

            if (nRaysSssR > 0)
            {
                // The sss reflection rays (is there such a thing?)
                int nvsctx = 0;
                RixVolumeIntegrator *sss = 
                    firstSctx->BeginSubsurface(nRaysSssR, raysSss);
                if(sss)
                {
                    RixRNG sssRNG(iCtx.rngCtx, perRayRngCtxSss, nRaysSssR);
                    setDelegateRayIds(nRaysSssR, raysSss, m_delegateRayIds);
                    m_useDelegateRayIds = true;           
                    sss->GetNearestHits(nRaysSssR, raysSss, &sssRNG,
                                        k_RixBXTraitsAllLobe, iCtx, 
                                        iCtx.GetLightingServices(),
                                        this,
                                        &nvsctx, sctxsTmp,
                                        reflectSubset, reflectExcludeSubset, false,
                                        isPrimary ? k_SidesFront : k_SidesBoth,
                                        isPrimary);
                    firstSctx->EndSubsurface(sss);
                    m_useDelegateRayIds = false;
                }
                else
                {
                    // no incident shader, AllLobe is fine since
                    // there's no additional hidden bounces within
                    getNearestHits(iCtx, nRaysSssR, raysSss, 
                                   k_RixBXTraitsAllLobe,
                                   &nvsctx, sctxsTmp,
                                   reflectSubset, reflectExcludeSubset,
                                   isPrimary);
                }
                nSctxsBatch += nvsctx;
                sctxsTmp += nvsctx;
            }

            if (nRaysVolT > 0)
            {
                int tindex = k_maxRaysPerBatch - nRaysVolT;
                RtRayGeometry *_rays = raysVol + tindex;
                splitRaysIntoShadingCtxs(iCtx,
                    nRaysVolT,
                    _rays,
                    k_RixBXTraitsAllLobe,
                    perRayRngCtxVol + tindex,
                    m_delegateRayIds,
                    firstSctx,
                    transmitSubset,
                    transmitExcludeSubset,
                    isPrimary,
                    false, // opposite
                    nSctxsBatch,
                    sctxsTmp);
            }

            if (nRaysSssT > 0)
            {
                // The subsurface transmission rays
                int nvsctx = 0;
                int tindex = k_maxRaysPerBatch - nRaysSssT;
                RtRayGeometry *_rays = raysSss + tindex;
                RixVolumeIntegrator *sss = 
                    firstSctx->BeginSubsurface(nRaysSssT, _rays);
                if(sss)
                {
                    RixRNG sssRNG(iCtx.rngCtx, perRayRngCtxSss + tindex, 
                                  nRaysSssT);
                    setDelegateRayIds(nRaysSssT, _rays, m_delegateRayIds);
                    m_useDelegateRayIds = true;
                    sss->GetNearestHits(nRaysSssT, _rays, &sssRNG,
                                        k_RixBXTraitsAllLobe, iCtx,
                                        iCtx.GetLightingServices(),
                                        this,
                                        &nvsctx, sctxsTmp,
                                        transmitSubset, transmitExcludeSubset, false,
                                        isPrimary ? k_SidesFront : k_SidesBoth,
                                        isPrimary);
                    firstSctx->EndSubsurface(sss);
                    m_useDelegateRayIds = false;
                }
                else
                {
                    // no opposite shader, AllLobe is fine since
                    // there's no additional hidden bounces within
                    getNearestHits(iCtx, nRaysSssT, _rays,
                                   k_RixBXTraitsAllLobe,
                                   &nvsctx, sctxsTmp,
                                   transmitSubset, transmitExcludeSubset,
                                   isPrimary);
                }
                nSctxsBatch += nvsctx;
                sctxsTmp += nvsctx;
            }
        }

        // Set the current context's incidentIsMatte to be previous context's isMatte.
        // This is important for matte volume to work
        // The assumption here is that all shade points within one shading context belong
        // to the same object, hence isMatte is uniform across all shade points within a context
        for (int i = 0; i < nSctxsBatch; ++i)
        {
            incidentSctxIsMatte[curSctxPos++] = incidentIsMatte;
        }

        shadeInfoPong->numSctxs += nSctxsBatch;
        sctxs                   += nSctxsBatch;
        for (int i = 0; i < nSctxsBatch; ++i)
        {
            depthInfo[i].totalDepth = firstDepth;
        }
        depthInfo               += nSctxsBatch;

        nRays   -= nRaysBatch;
        curPos  += nRaysBatch;
    }
}

int 
ptWorker::computeSampleCount(int depth, int numSamp, 
                             DepthReduceMode depthReduce,
                             float maxThruput, bool direct,
                             bool subsurface, bool continuation)
{
    int result;

    // Try to reduce the number of samples.
    // We choose to potentially use multiple samples only at camera hits.
    // (To avoid an exponential blow-up on ray counts at increasing ray 
    // depths.)

    if (numSamp <= 1)
        return numSamp; // no reduction possible: early out

    if (depthReduce == k_depthReduceNone) 
        return numSamp;

    if (depth == 1 && maxThruput >= 1.0f && direct && subsurface && !continuation)
        return numSamp; // don't reduce for subsurf scattering

    if (depthReduce == k_depthReduceDepth || 
        depthReduce == k_depthReduceDepthThruputAvg) 
    {
        bool canUseManySamples = (depth == 0 && !continuation);
        bool canUseSmallerManySamples = (depth == 1 && direct && !continuation);

        int newSamp = canUseManySamples ? numSamp : 
                        (canUseSmallerManySamples ? (int)sqrtf(numSamp) : 
                                            std::min(numSamp, 1));

        if (direct && depth >= 1)
            newSamp = std::min(m_numLightGroups, newSamp);

        if (depthReduce == k_depthReduceDepthThruputAvg)
        {
            int thruSamp = std::max(numSamp ? 1 : 0, 
                                  (int)(numSamp * maxThruput + 0.5f));
            
            return std::min(newSamp, thruSamp);
        }
        else
        {
            return newSamp;
        }
    }

    // k_depthReduceThruput
    result = std::max(numSamp ? 1 : 0, (int)(numSamp * maxThruput + 0.5f));
    return result;
}

void
ptWorker::computeClampDirect(int depth, 
                             RtColorRGB const &lgtTrans, 
                             RixBXActiveLobeWeights &activeLobes, 
                             int weightIndex, 
                             RtColorRGB const &thruput, 
                             float invNumSamp, 
                             bool &isFinite, RtFloat &clampAmt)
{
    clampAmt = 1.0f;

    RtColorRGB sum = activeLobes.SumAtIndex(weightIndex);
    sum *= thruput;

    isFinite = (RixIsFinite(sum.r) && RixIsFinite(sum.g) && RixIsFinite(sum.b));
    if (isFinite)
    {
        if ((depth + 1) >= m_clampDepth)
        {
            sum *= lgtTrans;
            float lum = sum.Luminance();
            float clampLuminance = m_clampLuminance * invNumSamp;
            if (lum > clampLuminance)
                clampAmt = clampLuminance / lum;
        }
    }
}

void 
ptWorker::computeClampEmissive(int depth, 
                               RtColorRGB const &emission,
                               RtColorRGB const &thruput, 
                               bool &isFinite, RtFloat &clampAmt)
{
    clampAmt = 1.0f;

    RtColorRGB sum = thruput * emission;
    isFinite = (RixIsFinite(sum.r) && RixIsFinite(sum.g) && RixIsFinite(sum.b));
    if (isFinite)
    {
        // we are clamping at the emitter, instead of the
        // reciever
        if ((depth) >= m_clampDepth)
        {
            float lum = sum.Luminance();
            if (lum > m_clampLuminance)
                clampAmt = m_clampLuminance / lum;
        }
    }
}

SampleType
ptWorker::findSampleType(SampleType srcSampleType, 
                         RixBXLobeSampled lobeSampled, int depth)
{
    SampleType ret;
    
    if (depth == 0 && lobeSampled.GetValid())
    {
        if (lobeSampled.GetDiffuse() && lobeSampled.GetReflect())
            ret = k_sampleDiffuse;
        else if (lobeSampled.GetSpecular() && lobeSampled.GetReflect())
            ret = k_sampleSpecular;
        else if (lobeSampled.GetDiffuse() && lobeSampled.GetTransmit())
            ret = k_sampleSubsurface;
        else if (lobeSampled.GetSpecular() && lobeSampled.GetTransmit())
            ret = k_sampleRefraction;
        else
            ret = srcSampleType;
    }
    else
    {
        ret = srcSampleType;
    }
    
    return ret;
}

void
ptWorker::getDirectState(RixShadingContext const &sCtx,
                         RtInt &maxDiffDepth, RtInt &maxSpecDepth,
                         RixLPEToken &lpeGrpId,
                         bool &isCollector)
{
    static const char    *k_diffDepthName = "trace:maxdiffusedepth";
    static const int       k_diffDepthLen  = sizeof(RtInt);
    static const RtInt     k_diffDepthDef  = 1;
    static const char    *k_specDepthName = "trace:maxspeculardepth";
    static const int       k_specDepthLen  = sizeof(RtInt);
    static const RtInt     k_specDepthDef  = 2;

    maxDiffDepth = k_diffDepthDef;
    maxSpecDepth = k_specDepthDef;
    lpeGrpId = RixLPE::k_BLANK;
    isCollector = false;

    if (RixRenderState *state = 
        (RixRenderState *) sCtx.GetRixInterface(k_RixRenderState))
    {
        RtFloat diffDepthVal, specDepthVal;
        RixRenderState::Type diffDepthType, specDepthType;
        RtInt diffDepthRet, specDepthRet;
        RtInt diffDepthCount, specDepthCount;

        diffDepthRet = state->GetAttribute(k_diffDepthName, &diffDepthVal, 
                                           k_diffDepthLen,  &diffDepthType, 
                                           &diffDepthCount);

        specDepthRet = state->GetAttribute(k_specDepthName, &specDepthVal, 
                                           k_specDepthLen,  &specDepthType, 
                                           &specDepthCount);

        if (diffDepthRet == 0 && diffDepthCount == 1)
            maxDiffDepth = (RtInt) diffDepthVal;

        if (specDepthRet == 0 && specDepthCount == 1)
            maxSpecDepth = (RtInt) specDepthVal;
    }

    lpeGrpId = resolveLPEToken( sCtx, isCollector );
}

void
ptWorker::getIndirectState(RixShadingContext const &sCtx,
                           RtInt &autoBias, RtFloat &bias,
                           RtToken &reflectSubset, RtToken &transmitSubset,
                           RtToken &reflectExcludeSubset, RtToken &transmitExcludeSubset)
{
    // Note: We currently call this routine to fetch the current attribute
    // state for built-in attributes (or user attributes) that we are 
    // interested in once per shading context (that is, once per similar 
    // group of hit points). Our profiling indicates that the computational
    // expense of calling this routine per shading context is neglible and
    // is currently not anywhere close to being a bottleneck. However, if 
    // one were to query the value of thousands upon thousands of different 
    // attributes within this routine, it's conceivable that performance 
    // could be affected. If that were to become an issue for some reason, 
    // one might consider using (non-primitive-specific) user options and/or 
    // custom integrator parameters instead of (per-primitive) attributes.

    static const char    *k_autoBiasName       = "trace:autobias";
    static const int       k_autoBiasLen        = sizeof(RtInt);
    static const RtInt     k_autoBiasDef        = -1;
    static const char    *k_biasName           = "trace:bias";
    static const int       k_biasLen            = sizeof(RtFloat);
    static const RtFloat   k_biasDef            = 0.01f;
    static const char    *k_reflectSubsetName  = "trace:reflectsubset";
    static const int      k_reflectSubsetLen   = sizeof(RtToken);
    static const char    *k_transmitSubsetName = "trace:transmitsubset";
    static const int      k_transmitSubsetLen  = sizeof(RtToken);
    static const char    *k_reflectExcludeSubsetName  = "trace:reflectexcludesubset";
    static const int      k_reflectExcludeSubsetLen   = sizeof(RtToken);
    static const char    *k_transmitExcludeSubsetName = "trace:transmitexcludesubset";
    static const int      k_transmitExcludeSubsetLen  = sizeof(RtToken);

    autoBias       = k_autoBiasDef;
    bias           = k_biasDef;
    reflectSubset  = NULL;
    transmitSubset = NULL;
    reflectExcludeSubset  = NULL;
    transmitExcludeSubset = NULL;

    if (RixRenderState *state = 
        (RixRenderState *) sCtx.GetRixInterface(k_RixRenderState))
    {
        RixRenderState::Type autoBiasType, biasType;
        RixRenderState::Type reflectSubsetType, transmitSubsetType;
        RixRenderState::Type reflectExcludeSubsetType, transmitExcludeSubsetType;

        RtFloat autoBiasVal, biasVal;
        RtToken reflectSubsetVal, transmitSubsetVal;
        RtToken reflectExcludeSubsetVal, transmitExcludeSubsetVal;

        RtInt autoBiasRet, biasRet;
        RtInt reflectSubsetRet, transmitSubsetRet; 
        RtInt reflectExcludeSubsetRet, transmitExcludeSubsetRet; 

        RtInt autoBiasCount, biasCount;
        RtInt reflectSubsetCount, transmitSubsetCount; 
        RtInt reflectExcludeSubsetCount, transmitExcludeSubsetCount; 
        
        autoBiasRet = state->GetAttribute(k_autoBiasName, &autoBiasVal, 
                                          k_autoBiasLen,  &autoBiasType, 
                                          &autoBiasCount);

        biasRet = state->GetAttribute(k_biasName, &biasVal, 
                                      k_biasLen,  &biasType, &biasCount);

        reflectSubsetRet = state->GetAttribute(k_reflectSubsetName,
                                               &reflectSubsetVal,
                                               k_reflectSubsetLen,
                                               &reflectSubsetType,
                                               &reflectSubsetCount);
        
        transmitSubsetRet = state->GetAttribute(k_transmitSubsetName,
                                                &transmitSubsetVal,
                                                k_transmitSubsetLen,
                                                &transmitSubsetType,
                                                &transmitSubsetCount);

        reflectExcludeSubsetRet = state->GetAttribute(k_reflectExcludeSubsetName,
                                               &reflectExcludeSubsetVal,
                                               k_reflectExcludeSubsetLen,
                                               &reflectExcludeSubsetType,
                                               &reflectExcludeSubsetCount);
        
        transmitExcludeSubsetRet = state->GetAttribute(k_transmitExcludeSubsetName,
                                                &transmitExcludeSubsetVal,
                                                k_transmitExcludeSubsetLen,
                                                &transmitExcludeSubsetType,
                                                &transmitExcludeSubsetCount);
        
        if (autoBiasRet == 0 && autoBiasCount == 1)
            autoBias = (RtInt) autoBiasVal;
            
        if (biasRet == 0 && biasCount == 1)
            bias = biasVal;
        
        if (reflectSubsetRet == 0 && reflectSubsetCount == 1)
            reflectSubset = reflectSubsetVal;

        if (transmitSubsetRet == 0 && transmitSubsetCount == 1)
            transmitSubset = transmitSubsetVal;

        if (reflectExcludeSubsetRet == 0 && reflectExcludeSubsetCount == 1)
            reflectExcludeSubset = reflectExcludeSubsetVal;

        if (transmitExcludeSubsetRet == 0 && transmitExcludeSubsetCount == 1)
            transmitExcludeSubset = transmitExcludeSubsetVal;
    }
}

RixLPEToken
ptWorker::resolveLPEToken(RixShadingContext const& sCtx,
    bool &isCollector) const
{
    static const char    *k_lpeGroupName  = "identifier:lpegroup";
    static const int      k_lpeGroupLen   = sizeof(RtToken);
    static const char    *k_objectName    = "identifier:name";
    static const int      k_objectNameLen = sizeof(RtToken);
    static RtConstString   k_collectorGroupPrefix = "collector";

    // Unkown lpe group. It is necessary to mine this from the shading
    // context here
    RixRenderState *state = 
        (RixRenderState *) sCtx.GetRixInterface(k_RixRenderState);
    RtInt ret, count;
    RixRenderState::Type type;

    char const *lpeGroup = 0;
    RtToken lpeGroupVal;
    ret = state->GetAttribute(k_lpeGroupName, &lpeGroupVal, 
                              k_lpeGroupLen,  &type, 
                              &count);
    if (ret == 0 && count == 1)
        lpeGroup = lpeGroupVal;

    char const *objName = 0;
    RtToken objNameVal;
    ret = state->GetAttribute(k_objectName, &objNameVal, 
                              k_objectNameLen,  &type, 
                              &count);
    if (ret == 0 && count == 1)
        objName = objNameVal;

    RixLPEToken lpeId = m_rixLpe->GroupAndObjectToToken(lpeGroup, objName);

    isCollector = false;
    if (lpeGroup && 
        strstr(lpeGroup, k_collectorGroupPrefix) == lpeGroup)
    {
        isCollector = true;
    }

    return lpeId;
}

void
ptWorker::volumeAggregateMultiScatter(RixIntegratorContext& iCtx,
                                      int numRays, RtRayGeometry const *rays,
                                      bool isCamera,
                                      ShadeInfo* shadeInfoPing,
                                      int* numShadingContexts,
                                      RixShadingContext const ** shadingContexts,
                                      int* newNumRays, RtRayGeometry* newRays)
{
    PxrVolumeAggregate volumeAggregate(m_volumeAggregate, iCtx, this, m_maxSamples * m_maxPathCount);
    if (isCamera)
    {
        // shadeInfoPing's rng will be used for the next wave, so use
        // the rngCtx straight from the camera
        initRNG(iCtx, 0xb497bc29, false, 1, numRays, rays);
        RixRNG rng(iCtx.rngCtx, m_rngSamps, numRays);
        volumeAggregate.MultiScatter(numRays, rays, &rng,
            numShadingContexts, shadingContexts,
            newNumRays, newRays);
    }
    else
    {
        // For non-primary rays: create a copy of the rays, because we
        // want to change the raySpread to match the primary rays
        int i, j;
        RtRayGeometry *aggregateRays = new RtRayGeometry[numRays];
        memcpy(aggregateRays, rays, numRays * sizeof(RtRayGeometry));
        RtInt* rayId = (RtInt *) alloca(numRays * sizeof(RtInt));
        for (i = 0; i < numRays; ++i)
        {
            int iCtxIndex = aggregateRays[i].integratorCtxIndex;
            rayId[i] = aggregateRays[i].rayId;
            aggregateRays[i].raySpread = iCtx.primaryRays[iCtxIndex].raySpread;
            aggregateRays[i].originRadius =
                iCtx.primaryRays[iCtxIndex].originRadius + 
                RtVector3(aggregateRays[i].origin).Length() * iCtx.primaryRays[iCtxIndex].raySpread;
        }
        initRNG(numRays, 0x6b4f3f64, false, 1, shadeInfoPing->rayInfo, rayId);
        RixRNG rng(iCtx.rngCtx, m_rngSamps, numRays);
        volumeAggregate.MultiScatter(numRays, aggregateRays, &rng,
            numShadingContexts, shadingContexts,
            newNumRays, newRays);

        // Reset the new rays to use the original ray spread that was
        // passed in
        for (i = 0; i < *newNumRays; ++i)
        {
            for (j = 0; j < numRays; ++j)
            {
                if (newRays[i].rayId == rays[j].rayId)
                {
                    newRays[i].originRadius = rays[j].originRadius;
                    newRays[i].raySpread = rays[j].raySpread;
                    break;
                }
            }
        }
        delete[] aggregateRays;
    }
}

void
ptWorker::getNearestHits(RixIntegratorContext &iCtx,
    int numRays, RtRayGeometry const* rays,
    RixBXLobeTraits const& lobesWanted,
    int* numShadingCtxs,
    RixShadingContext const** shadingCtxs,
    char const* subset,
    char const* excludeSubset,
    bool isPrimary)
{
    if (m_volumeAggregate)
    {
        int nAggregateShadingCtxs = 0;
        int nNewRays = 0;
        volumeAggregateMultiScatter(iCtx, numRays, rays,
            false, m_shadeInfoPing, &nAggregateShadingCtxs, shadingCtxs,
            &nNewRays, m_rays);
    
        iCtx.GetNearestHits(nNewRays, m_rays, lobesWanted, false,
            numShadingCtxs, shadingCtxs + nAggregateShadingCtxs, subset,
            excludeSubset, false,
            isPrimary ? k_SidesFront : k_SidesBoth, isPrimary);            
        *numShadingCtxs += nAggregateShadingCtxs;
    }
    else
    {
        iCtx.GetNearestHits(numRays, rays, lobesWanted, false,
            numShadingCtxs, shadingCtxs, subset, excludeSubset, false,
            isPrimary ? k_SidesFront : k_SidesBoth, isPrimary);
    }
}


void
PxrPathTracer::IntegrateRays(RixBXLobeTraits const& lobesWanted,
                             int* numShadingCtxs,
                             RixShadingContext const** shadingCtxs,
                             RixIntegratorContext& iCtx)
{
    ptWorker* worker = getWorker(iCtx);
    // First, make sure that our LPE automata is up-to-date
    // prior to calling Integrate(); discard/redo the iteration
    // if the LPE automata changed.
    if (worker->UpdateLPEs(iCtx))
    {
        iCtx.GetDisplayServices()->DiscardIteration(true);
    }
    else 
    {
        // Now perform the integration work.
        worker->IntegrateRays(iCtx, lobesWanted,
                              numShadingCtxs, shadingCtxs, m_timer);
    }
}

void
PxrPathTracer::Integrate(RtInt ngrps, RixShadingContext const *sgrps[],
                         RixIntegratorContext &iCtx)
{
    ptWorker* worker = getWorker(iCtx);
    // First, make sure that our LPE automata is up-to-date
    // prior to calling Integrate(); discard/redo the iteration
    // if the LPE automata changed.
    if (worker->UpdateLPEs(iCtx))
    {
        iCtx.GetDisplayServices()->DiscardIteration(true);
    }
    else 
    {
        // Now perform the integration work.
        worker->Integrate(iCtx, ngrps, sgrps, m_timer);

        if (worker->UpdateLPEs(iCtx))
            iCtx.GetDisplayServices()->DiscardIteration(true);
    }
}

void
PxrPathTracer::GetTransmission(int numRays, RtRayGeometry const* rays,
    RtColorRGB* trans, char const* subset, RixIntegratorContext& iCtx)
{
    RixStorage *storage = (RixStorage*) iCtx.GetRixInterface(k_RixThreadData);
    ptWorker *worker = ((ptWorker *) storage->Get("PxrPathTracerWorker"));
    assert(worker);
    RtRayGeometry *aggregateRays = new RtRayGeometry[numRays];
    memcpy(aggregateRays, rays, numRays * sizeof(RtRayGeometry));
    for (int i = 0; i < numRays; ++i)
    {
        int iCtxIndex = aggregateRays[i].integratorCtxIndex;
        aggregateRays[i].raySpread = iCtx.primaryRays[iCtxIndex].raySpread;
        aggregateRays[i].originRadius =
            iCtx.primaryRays[iCtxIndex].originRadius + 
            RtVector3(aggregateRays[i].origin).Length() * iCtx.primaryRays[iCtxIndex].raySpread;
    }
    worker->GetTransmission(iCtx, numRays, aggregateRays, trans, subset);
    delete[] aggregateRays;
}

bool
PxrPathTracer::GetProperty(RixIntegratorContext& ictx,
                           const int* rayId,
                           int numRays,
                           RayProperty property,
                           void const* result)
{
    switch (property)
    {
        case k_RayDepth:
        // Caller is responsible for allocating the memory. 
        // So here we assume we can safely fill in values.   
            getWorker(ictx)->GetRayDepth(rayId, numRays, result);
            return true;
            break;
        default:
            return false;
    }
}

void
PxrPathTracer::Synchronize(RixContext &rctx, RixSCSyncMsg m,
                           RixParameterList const *plist)
{
    switch(m)
    {
      case k_RixSCRenderBegin:
          break;
      default:
          break;
    }
}

void
PxrPathTracer::RenderEnd(RixContext &ctx)
{
    if (m_allWorkersMutex)
    {
        // gather stats first
        m_allWorkersMutex->Lock();

        RtInt64 bufferMemory = 0, aovMemory = 0;
        for (int i = 0; i < m_allWorkers.size(); i++)
        {
            bufferMemory += m_allWorkers[i]->GetBufferMemory();
            aovMemory += m_allWorkers[i]->GetAOVMemory();
        }
        m_statsBufferMemory = bufferMemory / (1024.0 * 1024.0);
        m_statsAovMemory = aovMemory / (1024.0 * 1024.0);

        // kill the workers
        for (int i = 0; i < m_allWorkers.size(); i++)
        {
            // accumulate per-worker stats
            for (int t=0; t<=m_maxPathLength; ++t)
            {
                m_statsDepthTimers[t] += m_allWorkers[i]->m_depthTimers[t];
                m_statsRayCounts[t] += m_allWorkers[i]->m_rayCounts[t];
            }
            delete m_allWorkers[i];
        }

        m_allWorkers.clear();

        m_allWorkersMutex->Unlock();
    }
}

void
PxrPathTracer::Finalize(RixContext &ctx)
{
    if (m_allWorkersMutex)
    {
        delete m_allWorkersMutex;
        m_allWorkersMutex = 0;
    }
}

void
PxrPathTracer::GetOptions(RixContext &ctx, RtInt &traceDepthMode)
{
    // Fetch the value of any built-in or user options here.

    static const char    *k_traceDepthModeName = "trace:depthmode";
    static const int      k_traceDepthModeLen = sizeof(RtToken);

    traceDepthMode = k_traceDepthModeCombined;

    if (RixRenderState *state = 
        (RixRenderState *) ctx.GetRixInterface(k_RixRenderState))
    {
        RtToken traceDepthModeVal = NULL;
        RixRenderState::Type traceDepthModeType;
        RtInt traceDepthModeRet;
        RtInt traceDepthModeCount;

        traceDepthModeRet = 
            state->GetOption(k_traceDepthModeName, &traceDepthModeVal, 
                             k_traceDepthModeLen,  &traceDepthModeType, 
                             &traceDepthModeCount);
        
        if (traceDepthModeRet == 0 && traceDepthModeCount == 1)
        {
            if (traceDepthModeVal != NULL)
            {
                if (!strcmp(traceDepthModeVal, "separate"))
                    traceDepthMode = k_traceDepthModeSeparate;
                else if (!strcmp(traceDepthModeVal, "combined"))
                    traceDepthMode = k_traceDepthModeCombined;
            }
        }
    }
}

void
PxrPathTracer::ReportStats(RixXmlFile* file)
{
    file->WriteText("\n");
    file->WriteXml("<stats name=\"parameters\" description=\"parameters\" >\n");
    file->WriteStat("numLightSamples", NULL, m_numLightSamples);
    file->WriteStat("numBxdfSamples", NULL, m_numBxdfSamples);
    if (m_reduceDirectSamples == k_depthReduceDepth)
        file->WriteStat("reduceDirectSamples", NULL, "depth");
    else if (m_reduceDirectSamples == k_depthReduceThruputMax)
        file->WriteStat("reduceDirectSamples", NULL, "throughputmax");
    else if (m_reduceDirectSamples == k_depthReduceThruputAvg)
        file->WriteStat("reduceDirectSamples", NULL, "throughputavg");
    else if (m_reduceDirectSamples == k_depthReduceThruputGAvg)
        file->WriteStat("reduceDirectSamples", NULL, "throughputgeoavg");
    else if (m_reduceDirectSamples == k_depthReduceNone)
        file->WriteStat("reduceDirectSamples", NULL, "none");
    file->WriteStat("numIndirectSamples", NULL, m_numIndirectSamples);
    file->WriteStat("numDiffuseSamples", NULL, m_numDiffuseSamples);
    file->WriteStat("numSpecularSamples", NULL, m_numSpecularSamples);
    file->WriteStat("numSubsurfaceSamples", NULL, m_numSubsurfaceSamples);
    file->WriteStat("numRefractionSamples", NULL, m_numRefractionSamples);
    if (m_sampleMode == k_modeBxdf)
        file->WriteStat("sampleMode", NULL, "Bxdf");
    else if (m_sampleMode == k_modeManual)
        file->WriteStat("sampleMode", NULL, "Manual");
    file->WriteStat("rouletteDepth", NULL, m_rouletteDepth);
    file->WriteStat("rouletteThreshold", NULL, m_rouletteThreshold);
    file->WriteStat("clampDepth", NULL, m_clampDepth);
    file->WriteStat("clampLuminance", NULL, m_clampLuminance);
    file->WriteStat("allowCaustics", NULL, m_allowCaustics);
    file->WriteStat("maxPathLength", NULL, m_maxPathLength);
    file->WriteStat("accumOpacity", NULL, m_accumOpacity);
    file->WriteStat("maxContinuationLength", NULL, m_maxContinuationLength);
    file->WriteStat("bufferMemory", "Buffer mem (MB)", m_statsBufferMemory);
    file->WriteStat("aovMemory", "Geom AOV mem (MB)", m_statsAovMemory);
    file->WriteXml("</stats>\n");

    // Write per-path-vertex cost (time).
    file->WriteXml("<histogram name=\"pathDepthTimer\" description=\"Ray Depth Timer (sec)\">\n");
    for (size_t i=0; i<m_statsDepthTimers.size(); ++i)
        file->WriteXml("<bin label=\"%lu\">%f</bin>\n", i+1, m_timer->ConvertIntervalToSeconds(m_statsDepthTimers[i]));
    file->WriteXml("</histogram>\n");
    file->WriteXml("<histogram name=\"pathRayCounts\" description=\"Ray Count at Depth\">\n");
    for (size_t i=0; i<m_statsRayCounts.size(); ++i)
        file->WriteXml("<bin label=\"%lu\">%llu</bin>\n", i+1, m_statsRayCounts[i]);
    file->WriteXml("</histogram>\n");
    
}

ptWorker*
PxrPathTracer::getWorker(RixIntegratorContext& iCtx)
{
    RixStorage *storage = (RixStorage*) iCtx.GetRixInterface(k_RixThreadData);
    ptWorker *worker = ((ptWorker *) storage->Get("PxrPathTracerWorker"));
    if (worker == NULL)
    {
        worker = new ptWorker(iCtx, iCtx.GetRixLPE(),
                              m_numLightSamples,      m_numBxdfSamples,
                              m_reduceDirectSamples,
                              m_numIndirectSamples, 
                              m_numDiffuseSamples,    m_numSpecularSamples,
                              m_numSubsurfaceSamples, m_numRefractionSamples,
                              m_sampleMode,           m_maxSamples, 
                              m_maxIndSamples, 
                              m_rouletteDepth,        m_rouletteThreshold, 
                              m_clampDepth,           m_clampLuminance, 
                              m_allowCaustics,        m_maxPathLength,
                              m_maxContinuationLength,
                              m_maxShadingCtxSize,
                              m_imagePlaneSubset,
                              m_geoAovIds,
                              m_traceDepthMode,
                              m_accumOpacity,
                              m_volumeAggregate);
        
        storage->Set("PxrPathTracerWorker", worker, NULL);

        if (m_allWorkersMutex)
        {
            m_allWorkersMutex->Lock();
            m_allWorkers.push_back(worker);
            m_allWorkersMutex->Unlock();
        }
    }
    return worker;
}

RIX_INTEGRATORCREATE
{
    return new PxrPathTracer();
}


RIX_INTEGRATORDESTROY
{
    delete ((PxrPathTracer*)integrator);
}
