/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2017 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

/* $Revision:  $ */

#include "RixBxdf.h"
#include "RixIntegrator.h"
#include "RixLight.h"
#include "RixRNG.h"
#include "PxrGeoAovs.h"
#include <cstdio>

PRMAN_INLINE void
DistributionCosine(
    const RtFloat2& xi,
    const RtVector3& n,
    const float spread,
    RtVector3& outDir)
{
    RtVector3 t0, t1;
    n.CreateOrthonormalBasis(t0, t1);
    float e1 = xi.x * F_TWOPI;
    float z = std::sqrt(xi.y);
    float r = spread * std::sqrt(std::max(0.0f, 1.0f - xi.y));
    if (z < 1.e-12f) z = 1.e-12f;
    outDir = r * std::cos(e1) * t0 + r * std::sin(e1) * t1 + z * n;
    outDir.Normalize();
}

PRMAN_INLINE void
DistributionUniform(
    const RtFloat2& xi,
    const RtVector3& n,
    RtVector3& outDir)
{
    RtVector3 t0, t1;
    n.CreateOrthonormalBasis(t0, t1);
    float e1 = xi.x * F_TWOPI;
    float z = xi.y;
    float r = std::sqrt(std::max(0.0f, 1.0f - z * z));
    float x = r * std::cos(e1);
    float y = r * std::sin(e1);
    if (z < 1.e-12f) z = 1.e-12f;
    outDir = x * t0 + y * t1 + z * n;
}

class PxrOcclusion : public RixIntegrator
{
    enum ParamId
    {
        k_numSamples = 0,
        k_distribution,
        k_cosineSpread,
        k_falloff,
        k_maxDistance,
        k_useAlbedo,
    };

    enum Distribution
    {
        k_distributionUniform = 0,
        k_distributionCosine,
        k_distributionBrdf,
    };

private:
    class Worker
    {
    public:
        Worker(PxrOcclusion const &master);
        ~Worker();
        virtual void Integrate(int numGrps,
                               RixShadingContext const *shadeCtxs[],
                               RixIntegratorContext &ictx);
    private:
        PxrOcclusion const &m_master;
        RixRNG::SampleCtx *m_smpCtx;
        RixRNG::SampleCtx *m_smpEvalCtx;
        RtHitPoint *m_hits;
        RtRayGeometry *m_rays;
        RtVector3 *m_sampleDirs;
        RixBXLobeTraits *m_lobesWanted;
        RixBXLobeSampled *m_lobesSampled;
        RixBXLobeTraits *m_lobesEvaluated;
        RtColorRGB *m_diffuseLobes[k_RixBXMaxNumDiffuseLobes];
        RtColorRGB *m_specularLobes[k_RixBXMaxNumSpecularLobes];
        RtColorRGB *m_userLobes[k_RixBXMaxNumUserLobes];
        float *m_forwardPdfs;
        float *m_reversePdfs;
        RtFloat3 *m_geoAovColor;
        float *m_geoAovFloat;
    };

public:
    PxrOcclusion();
    virtual ~PxrOcclusion();

    virtual int Init(RixContext &ctx, char const *pluginPath);
    virtual void Finalize(RixContext &ctx);
    virtual RixSCParamInfo const *GetParamTable();
    virtual void RenderBegin(RixContext &ctx,
                             RixIntegratorEnvironment &env,
                             RixParameterList const *params);
    virtual void RenderEnd(RixContext &ctx);
    virtual void Integrate(int numGrps,
                           RixShadingContext const *shadeCtxs[],
                           RixIntegratorContext &ictx);

private:
    int m_numSamples;
    int m_distribution;
    float m_cosineSpread;
    float m_falloff;
    float m_maxDistance;
    int m_useAlbedo;
    int m_albedoId;
    float m_raySpread;
    RixBXLobeTraits m_lobesWanted;
    RixChannelId m_beautyChanId;
    int m_maxPts;
    int *m_geoAovIds;
    RixMutex *m_allWorkersMutex;
    std::vector<Worker*> m_allWorkers;
    RixMessages *m_msgs;
};

PxrOcclusion::PxrOcclusion() :
    m_geoAovIds(NULL),
    m_allWorkersMutex(NULL),
    m_msgs(NULL)
{
}

PxrOcclusion::~PxrOcclusion()
{
    delete[] m_geoAovIds;
}

int
PxrOcclusion::Init(RixContext &ctx, char const * /*pluginPath*/)
{
    // Initilized resources shared between threads and frames
    m_msgs = (RixMessages*)ctx.GetRixInterface(k_RixMessages);
    if (RixThreadUtils *threadUtils =
        (RixThreadUtils*) ctx.GetRixInterface(k_RixThreadUtils))
    {
        m_allWorkersMutex = threadUtils->NewMutex();
    }

    return 0;
}

void
PxrOcclusion::Finalize(RixContext &/*ctx*/)
{
}

RixSCParamInfo const *
PxrOcclusion::GetParamTable()
{
    static const RixSCParamInfo s_ptable[] =
    {
        RixSCParamInfo("numSamples", k_RixSCInteger),
        RixSCParamInfo("distribution", k_RixSCInteger),
        RixSCParamInfo("cosineSpread", k_RixSCFloat),
        RixSCParamInfo("falloff", k_RixSCFloat),
        RixSCParamInfo("maxDistance", k_RixSCFloat),
        RixSCParamInfo("useAlbedo", k_RixSCInteger),
        RixSCParamInfo()
    };
    return &s_ptable[0];
}

void
PxrOcclusion::RenderBegin(
    RixContext &ctx,
    RixIntegratorEnvironment &env,
    RixParameterList const *parameterList)
{
    #define PARAM_GET_UNIFORM(_name, _val) do { \
        RtInt paramId; \
        if (!parameterList->GetParamId(_name, &paramId) \
            && parameterList->EvalParam(paramId, 0, &_val) != k_RixSCUniform) \
            m_msgs->ErrorAlways("PxrOcclusion: invalid parameter " _name); \
        } while (0)

    // Set default parameter values
    m_numSamples = 4;
    m_distribution = k_distributionCosine;
    m_cosineSpread = 1.0f;
    m_falloff = 0.0f;
    m_maxDistance = 0.0f;
    m_useAlbedo = 0;
    m_raySpread = 1.0f;

    PARAM_GET_UNIFORM("numSamples", m_numSamples);
    m_numSamples = RixMax(1, m_numSamples);
    PARAM_GET_UNIFORM("distribution", m_distribution);
    PARAM_GET_UNIFORM("cosineSpread", m_cosineSpread);
    PARAM_GET_UNIFORM("falloff", m_falloff);
    PARAM_GET_UNIFORM("maxDistance", m_maxDistance);
    PARAM_GET_UNIFORM("useAlbedo", m_useAlbedo);

    #undef PARAM_GET_UNIFORM

    if (m_maxDistance <= 0.0f)
    {
        // infinite
        m_maxDistance = FLT_MAX;
        // avoid positive values in falloff exponent
        m_falloff = std::min(0.0f, -m_falloff);
    }

    if (m_numSamples >= 4)
    {
        // Assuming (incorrectly) that distribution is uniform
        // spread = tan(theta) = R / (1 - h)
        // cos(theta) = 1 - h
        // sin(theta) = R
        // sin^2 + cos^2 = 1
        // ... R^2 = 2 h - h^2
        // solidangle = 2 pi / numSamples
        // area of spherical cap = 2 pi h
        // solidangle = area of spherical cap (by definition)
        // ... h = 1 / numSamples
        // spread = sqrt(2 numSamples - 1) / (numSamples - 1)
        m_raySpread = std::sqrt(2.0f * m_numSamples - 1.0f) / (m_numSamples - 1.0f);
    }

    // Check if we need to sample the bxdf
    m_lobesWanted = k_RixBXTraitsNullLobe;
    if (m_distribution == k_distributionBrdf) {
        m_lobesWanted |= k_RixBXTraitsAllReflect;
    }
    if (m_useAlbedo) {
        RixBXLobeSampled albedoLobe = RixBXLookupLobeByName(
            ctx, false, false, false, true, 0, "Albedo");
        m_albedoId = albedoLobe.GetLpeId();
        m_lobesWanted |= RixBXLobeTraits(albedoLobe);
    }

    // Find the beauty channel AOV
    for (int i = 0; i < env.numDisplays; ++i)
    {
        if (!strcmp("Ci", env.displays[i].channel))
        {
            m_beautyChanId = env.displays[i].id;
            break;
        }
    }

    // Geometric AOVs
    if (!PxrGeoAOV::disableIntegratorAOVs(ctx, m_geoAovIds))
    {
        PxrGeoAOV::GetChannelIds(env, m_geoAovIds);
    }

    // This value is the maximum number of points for a primary intersection
    // shading context. We use this to determine how much memory to allocate
    // for each per-thread worker
    m_maxPts = env.maxShadingCtxSize;
}

void
PxrOcclusion::RenderEnd(RixContext &/*ctx*/)
{
    // Delete all per-thread workers
    // These are not shared between renders
    if (m_allWorkersMutex)
    {
        m_allWorkersMutex->Lock();
        for (int i = 0; i < m_allWorkers.size(); ++i)
        {
            delete m_allWorkers[i];
        }
        m_allWorkers.clear();
        m_allWorkersMutex->Unlock();
    }

    delete[] m_geoAovIds;
    m_geoAovIds = NULL;
}

void
PxrOcclusion::Integrate(
    int numGrps,
    RixShadingContext const *shadeCtxs[],
    RixIntegratorContext &iCtx)
{
    // Get or create per-thread worker for integration
    static const char k_workerKey[] = "PxrOcclusionWorker";
    RixStorage *storage = (RixStorage*)iCtx.GetRixInterface(k_RixThreadData);
    Worker *worker = ((Worker *)storage->Get(k_workerKey));
    if (worker == NULL)
    {
        worker = new Worker(*this);
        storage->Set(k_workerKey, worker, NULL);
        if (m_allWorkersMutex)
        {
            m_allWorkersMutex->Lock();
            m_allWorkers.push_back(worker);
            m_allWorkersMutex->Unlock();
        }
    }
    worker->Integrate(numGrps, shadeCtxs, iCtx);
}

PxrOcclusion::Worker::Worker(PxrOcclusion const &master) :
    m_master(master),
    m_lobesWanted(NULL),
    m_lobesSampled(NULL),
    m_lobesEvaluated(NULL),
    m_forwardPdfs(NULL),
    m_reversePdfs(NULL),
    m_geoAovColor(NULL),
    m_geoAovFloat(NULL)
{
    memset(m_diffuseLobes, 0, k_RixBXMaxNumDiffuseLobes*sizeof(RtColorRGB*));
    memset(m_specularLobes, 0, k_RixBXMaxNumSpecularLobes*sizeof(RtColorRGB*));
    memset(m_userLobes, 0, k_RixBXMaxNumUserLobes*sizeof(RtColorRGB*));

    // Initilize thread worker, allocating the enough memory for
    // random number contex, ray hits/geo, and any geometric AOVs
    const int maxRays = m_master.m_maxPts * m_master.m_numSamples;

    m_smpCtx = new RixRNG::SampleCtx[m_master.m_maxPts];
    m_smpEvalCtx = new RixRNG::SampleCtx[m_master.m_maxPts];
    m_hits = new RtHitPoint[maxRays];
    m_rays = new RtRayGeometry[maxRays];
    m_sampleDirs = new RtVector3[maxRays];

    if (m_master.m_lobesWanted.HasAny())
    {
        m_lobesWanted = new RixBXLobeTraits[m_master.m_maxPts];
        for (int i = 0; i < m_master.m_maxPts; ++i)
            m_lobesWanted[i] = m_master.m_lobesWanted;
        if (m_master.m_distribution == k_distributionBrdf)
            m_lobesSampled = new RixBXLobeSampled[maxRays];
        else
            m_lobesEvaluated = new RixBXLobeTraits[maxRays];
        for (int i = 0; i < k_RixBXMaxNumDiffuseLobes; ++i)
            m_diffuseLobes[i] = new RtColorRGB[maxRays];
        for (int i = 0; i < k_RixBXMaxNumSpecularLobes; ++i)
            m_specularLobes[i] = new RtColorRGB[maxRays];
        for (int i = 0; i < k_RixBXMaxNumUserLobes; ++i)
            m_userLobes[i] = new RtColorRGB[maxRays];
        m_forwardPdfs = new float[maxRays];
        m_reversePdfs = new float[maxRays];
    }

    if (m_master.m_geoAovIds)
    {
        m_geoAovColor = new RtFloat3[m_master.m_maxPts];
        if (PxrGeoAOV::NeedTempFloat(m_master.m_geoAovIds))
            m_geoAovFloat = new float[m_master.m_maxPts];
    }
}

PxrOcclusion::Worker::~Worker()
{
    delete[] m_smpCtx;
    delete[] m_smpEvalCtx;
    delete[] m_hits;
    delete[] m_rays;
    delete[] m_sampleDirs;
    delete[] m_lobesWanted;
    delete[] m_lobesSampled;
    delete[] m_lobesEvaluated;
    for (int i = 0; i < k_RixBXMaxNumDiffuseLobes; ++i)
        delete[] m_diffuseLobes[i];
    for (int i = 0; i < k_RixBXMaxNumSpecularLobes; ++i)
        delete[] m_specularLobes[i];
    for (int i = 0; i < k_RixBXMaxNumUserLobes; ++i)
        delete[] m_userLobes[i];
    delete[] m_forwardPdfs;
    delete[] m_reversePdfs;
    delete[] m_geoAovColor;
    delete[] m_geoAovFloat;
}

void
PxrOcclusion::Worker::Integrate(
    int numGrps,
    RixShadingContext const *shadeCtxs[],
    RixIntegratorContext &iCtx)
{
    // Use a unique random unsigned integer for each sampling domain
    static const unsigned k_rngDomain = 0xf88bce9;
    static const unsigned k_rngEvalDomain = 0x8732f9a1;

    RixDisplayServices *displaySvc = iCtx.GetDisplayServices();

    // Initilize random number generator. Because occlusion is not recursive,
    // we can initilize the RNG to the same number of points as the integration
    // context.
    // Note that the sample context arrays (m_smpCtx and m_smpEvalCtx) in these
    // RNGs get initialized later (by the calls to NewDomain() below).
    RixRNG rng(iCtx.rngCtx, m_smpCtx);
    RixRNG rngEval(iCtx.rngCtx, m_smpEvalCtx);

    // For each shading group
    for (int grp = 0; grp < numGrps; ++grp)
    {
        RixShadingContext const *sCtx = shadeCtxs[grp];

        // Grab local geometric info
        RtPoint3 const *P;
        RtNormal3 const *Nn;
        RtNormal3 const *Ngn;
        RtVector3 const *Vn;
        float const *iradius;
        float const *biasR;
        float const *biasT;
        sCtx->GetBuiltinVar(RixShadingContext::k_P, &P);
        sCtx->GetBuiltinVar(RixShadingContext::k_Nn, &Nn);
        sCtx->GetBuiltinVar(RixShadingContext::k_Ngn, &Ngn);
        sCtx->GetBuiltinVar(RixShadingContext::k_Vn, &Vn);
        sCtx->GetBuiltinVar(RixShadingContext::k_incidentRayRadius, &iradius);
        sCtx->GetBuiltinVar(RixShadingContext::k_biasR, &biasR);
        sCtx->GetBuiltinVar(RixShadingContext::k_biasT, &biasT);

        RixBxdf *bxdf = sCtx->GetBxdf();
        int const numRays = m_master.m_numSamples * sCtx->numPts;
        RixBXLobeWeights lobeWeights(numRays,
                                     k_RixBXMaxNumDiffuseLobes,
                                     k_RixBXMaxNumSpecularLobes,
                                     k_RixBXMaxNumUserLobes,
                                     m_diffuseLobes,
                                     m_specularLobes,
                                     m_userLobes);

        // Init rng samples before calling bxdf GenerateSample().
        // The samples are set up for trajectory splitting if numSamples > 1,
        // otherwise just regular path tracing
        for (int pt = 0; pt < sCtx->numPts; pt++)
        {
            int ctxIdx = sCtx->integratorCtxIndex[pt];
            m_smpCtx[pt] = iCtx.rngCtx->NewDomain(ctxIdx, k_rngDomain,
                                                  m_master.m_numSamples);

            if ((m_master.m_distribution != k_distributionBrdf) && m_master.m_useAlbedo)
            {
                m_smpEvalCtx[pt] = iCtx.rngCtx->NewDomain(ctxIdx, k_rngEvalDomain,
                                                          m_master.m_numSamples);
            }
        }

        for (int smp = 0, offset = 0; smp < m_master.m_numSamples; ++smp, offset += sCtx->numPts)
        {
            // Calculate ray directions
            if (m_master.m_distribution == k_distributionBrdf)
            {
                // Make the Bxdf generate sample directions
                rng.numPts = sCtx->numPts;
                lobeWeights.SetOffset(offset);
                bxdf->GenerateSample(k_RixBXIndirectLighting,
                                     m_lobesWanted,
                                     &rng,
                                     m_lobesSampled + offset,
                                     m_sampleDirs + offset,
                                     lobeWeights,
                                     m_forwardPdfs + offset,
                                     m_reversePdfs + offset);
                // Increment sample
                for (int pt = 0; pt < sCtx->numPts; ++pt)
                    m_smpCtx[pt].sampleid++;
            }
            else
            {
                for (int pt = 0, i = offset; pt < sCtx->numPts; ++pt, ++i)
                {
                    RtFloat2 xi = rng.GenerateSample2D(pt);
                    if (m_master.m_distribution == k_distributionUniform) {
                        DistributionUniform(xi, Nn[pt], m_sampleDirs[i]);
                    } else /* k_distributionCosine */ {
                        DistributionCosine(xi, Nn[pt], m_master.m_cosineSpread, m_sampleDirs[i]);
                    }
                    if (Nn[pt].Dot(Vn[pt]) < 0)
                        m_sampleDirs[i].Negate();
                }

                if (m_master.m_useAlbedo)
                {
                    bxdf->EvaluateSample(k_RixBXIndirectLighting,
                                         m_lobesWanted,
                                         &rngEval,
                                         m_lobesEvaluated + offset,
                                         m_sampleDirs + offset,
                                         lobeWeights,
                                         m_forwardPdfs + offset,
                                         m_reversePdfs + offset);

                    // Increment sample
                    for (RtInt pt = 0; pt < sCtx->numPts; ++pt)
                        m_smpEvalCtx[pt].sampleid++;

                }
            }

            // Initilize rays
            for (int pt = 0, i = offset; pt < sCtx->numPts; ++pt, ++i)
            {
                m_rays[i].origin = RixApplyTraceBias(P[pt], Ngn[pt], m_sampleDirs[i], biasR[pt], biasT[pt]);
                m_rays[i].direction = m_sampleDirs[i];
                m_rays[i].originRadius = iradius[pt];
                m_rays[i].raySpread = m_master.m_raySpread;
                m_rays[i].maxDist = m_master.m_maxDistance;
                m_rays[i].rayId = i;
                m_rays[i].lpeState = NULL;
                m_rays[i].InitTransmitOrigination(sCtx, pt);
            }
        }
        lobeWeights.SetOffset(0);

        // Trace rays
        if (sCtx->light && sCtx->light->IsInfinite()) {
            for (int i = 0; i < numRays; ++i) m_hits[i].dist = 0.0f;
        } else {
            iCtx.GetNearestHits(numRays, m_rays, m_hits);
        }

        int albedoLobeId = -1;
        RixBXActiveLobeWeights activeLobes;
        if (m_master.m_useAlbedo)
        {
            lobeWeights.GetActiveLobes(activeLobes);
            int const numLobes = activeLobes.GetNumUserLobes();
            for (int lobeId = 0; lobeId < numLobes; ++lobeId)
            {
                int const lpeId = activeLobes.GetUserLpeId(lobeId);
                if (lpeId == m_master.m_albedoId) {
                    albedoLobeId = lobeId;
                    break;
                }
            }
        }

        // Calculate occlusion and splat
        for (int pt = 0; pt < sCtx->numPts; ++pt)
        {
            float occlusion = 0.0f;
            for (int smp = 0, i = pt; smp < m_master.m_numSamples; ++smp, i += sCtx->numPts)
            {
                bool const valid = !m_lobesSampled || m_lobesSampled[i].GetValid();
                if (valid && m_hits[i].dist != 0.0f)
                {
                    if (m_master.m_maxDistance == FLT_MAX) /* exponential falloff */ {
                        occlusion += std::exp(m_master.m_falloff * m_hits[i].dist);
                    } else /* falloff normalized to maxDistance */ {
                        occlusion += std::pow(1.0f - m_hits[i].dist / m_master.m_maxDistance, m_master.m_falloff);
                    }
                }

            }
            occlusion /= m_master.m_numSamples;
            RtColorRGB result(1.0f - occlusion);

            if (albedoLobeId >= 0) {
                result *= activeLobes.GetUserLobe(albedoLobeId)[pt];
            } else if (m_master.m_useAlbedo) {
                result = RixConstants::k_ZeroRGB;
            }

            displaySvc->Splat(m_master.m_beautyChanId,
                              sCtx->integratorCtxIndex[pt], result);
            displaySvc->WriteOpacity(m_master.m_beautyChanId,
                                     sCtx->integratorCtxIndex[pt], 1);
        }
    }

    // Write geometric AOVs
    if (m_master.m_geoAovIds)
    {
        PxrGeoAOV::Splat(numGrps, shadeCtxs, displaySvc,
                         m_geoAovColor, m_geoAovFloat, m_master.m_geoAovIds);
    }
}

RIX_INTEGRATORCREATE
{
    return new PxrOcclusion();
}

RIX_INTEGRATORDESTROY
{
    delete ((PxrOcclusion*)integrator);
}

