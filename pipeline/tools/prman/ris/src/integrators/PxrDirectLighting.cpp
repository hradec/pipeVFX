/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2016 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

/* $Revision: #12 $ */

#include "RixIntegrator.h"
#include "RixLighting.h"
#include "RixLPE.h"
#include "RixRNG.h"
#include "RixShadingUtils.h"
#include "PxrGeoAovs.h"
#include <string.h>

using namespace RixConstants;

class DirectLightingWorker;

class PxrDirectLighting : public RixIntegrator
{
  public:

    PxrDirectLighting();
    virtual ~PxrDirectLighting();

    virtual int Init(RixContext &, char const *pluginpath);
    virtual RixSCParamInfo const *GetParamTable(); 
    virtual void Finalize(RixContext &);
    virtual void RenderBegin(RixContext &ctx, RixIntegratorEnvironment &env,
                             RixParameterList const *);
    virtual void RenderEnd(RixContext &ctx);

    virtual void Integrate(RtInt nGroups, RixShadingContext const *shadeGrps[],
                           RixIntegratorContext &iCtx);

    void ReportStats(RixXmlFile* file);

  private:
    RtInt        m_maxShadingCtxSize;
    RixChannelId m_ciChan;
    std::vector<DirectLightingWorker *> m_allWorkers;

    // constructor parameters
    RtInt        m_numLightSamples;
    RtInt        m_numBxdfSamples;
    RixMessages *m_msgs;
    RixMutex    *m_allWorkersMutex;
    RtInt       *m_geoAovIds;
};

PxrDirectLighting::PxrDirectLighting() : 
    m_numLightSamples(4), 
    m_numBxdfSamples(4), 
    m_msgs(0),
    m_allWorkersMutex(0), 
    m_geoAovIds(0)
{
}

PxrDirectLighting::~PxrDirectLighting()
{
    if (m_geoAovIds)
    {
        delete[] m_geoAovIds;
        m_geoAovIds = NULL;
    }
}

int
PxrDirectLighting::Init(RixContext &ctx, char const *pluginpath)
{
    // Setup any shared resources
    m_msgs = (RixMessages *) ctx.GetRixInterface(k_RixMessages);

    if (RixThreadUtils *threadUtils = 
        (RixThreadUtils*) ctx.GetRixInterface(k_RixThreadUtils))
    {
        m_allWorkersMutex = threadUtils->NewMutex();
    }

    return 0;
}

RixSCParamInfo const *
PxrDirectLighting::GetParamTable()
{
    static RixSCParamInfo s_ptable[] = 
    {
        RixSCParamInfo("numLightSamples", k_RixSCInteger),
        RixSCParamInfo("numBxdfSamples", k_RixSCInteger),

        RixSCParamInfo() // end of table
    };
    return &s_ptable[0];
}

static void
statsReporter(void *ctx, class RixXmlFile *file)
{
    ((PxrDirectLighting*)ctx)->ReportStats(file);
}

void
PxrDirectLighting::ReportStats(RixXmlFile* file)
{
    file->WriteText("\n");
    file->WriteXml("<stats name=\"parameters\" description=\"parameters\" >\n");
    file->WriteStat("numLightSamples", NULL, m_numLightSamples);
    file->WriteStat("numBxdfSamples", NULL, m_numBxdfSamples);
    file->WriteXml("</stats>\n");
}

void
PxrDirectLighting::Finalize(RixContext &ctx)
{ 
    if (m_allWorkersMutex)
    {
        delete m_allWorkersMutex;
        m_allWorkersMutex = 0;
    }
}

void
PxrDirectLighting::RenderBegin(RixContext &ctx, RixIntegratorEnvironment &env,
                               RixParameterList const *plist)
{
    RtInt paramId;
    char const *pnm;

    pnm = "numLightSamples";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_numLightSamples) != k_RixSCUniform)
            m_msgs->Error("%s: invalid arg %s\n", pnm);
    }

    pnm = "numBxdfSamples";
    if(0 == plist->GetParamId(pnm, &paramId))
    {
        if(plist->EvalParam(paramId, 0, &m_numBxdfSamples) != k_RixSCUniform)
            m_msgs->Error("%s: invalid arg %s\n", pnm);
    }

    for (int index = 0; index < env.numDisplays; ++index) 
    {
        if (!strcmp("Ci", env.displays[index].channel))
            m_ciChan = env.displays[index].id;
    }
    env.lightingRequirements = 
                        RixIntegratorEnvironment::k_UnidirectionalLighting;
    env.supportedSamplingModes = RixIntegratorEnvironment::SamplingModes(
                                     RixIntegratorEnvironment::k_Fixed |
                                     RixIntegratorEnvironment::k_Incremental);
    m_maxShadingCtxSize = env.maxShadingCtxSize;

    RixStats* stats = (RixStats*) ctx.GetRixInterface(k_RixStats);
    stats->AddReporterCtx(statsReporter, this);

    // Get the list of requested geometric AOVs
    if (!PxrGeoAOV::disableIntegratorAOVs(ctx, m_geoAovIds))
    {
        PxrGeoAOV::GetChannelIds(env, m_geoAovIds);
    }
}

// holds scratch arrays for doing the work
class DirectLightingWorker 
{
public:
    DirectLightingWorker(const RixIntegratorContext &iCtx,
                         RixRefCntPtr<RixLPE> rixLpe, 
                         RtInt numLight, RtInt numBxdf, 
                         RtInt maxSCTXSize,
                         RixChannelId ciChan,
                         RtInt *aovIdList) :
        m_rixLpe(rixLpe),
        m_ciChan(ciChan),
        m_maxShadingCtxSize(maxSCTXSize),
        m_numLightSamples(numLight), 
        m_numBxdfSamples(numBxdf),
        m_geoAovIds(aovIdList)
    {
        int maxSamples = std::max(numLight,numBxdf);
        m_displaySvc = iCtx.GetDisplayServices();

        // allocate space per shading pt
        m_sctxs = new RixShadingContext const *[maxSCTXSize];
        m_rngSamps = new RixRNG::SampleCtx[maxSCTXSize];
        m_volRays = new RtRayGeometry[maxSCTXSize];

        // allocate space per sample
        m_emitLight   = new RtColorRGB[maxSamples*maxSCTXSize];
        m_emitLocal   = new RtColorRGB[maxSamples*maxSCTXSize];
        m_lobesWanted   = new RixBXLobeTraits[maxSamples*maxSCTXSize];
        m_lobesEvaluated = new RixBXLobeTraits[maxSamples*maxSCTXSize];
        m_lobeSampled   = new RixBXLobeSampled[maxSamples*maxSCTXSize];
        m_PtoL          = new RtVector3[maxSamples*maxSCTXSize];
        m_dist          = new RtFloat[maxSamples*maxSCTXSize];
        m_lightTrans    = new RtColorRGB[maxSamples*maxSCTXSize];
        m_Cl            = new RtColorRGB[maxSamples*maxSCTXSize];
        m_lightGroupIds = new RtInt[maxSamples*maxSCTXSize];
        m_lightLpeTokens = new RixLPEToken[maxSamples*maxSCTXSize];
        // m_lPdfP         = new RtFloat[maxSamples*maxSCTXSize];
        m_lPdfIllum     = new RtFloat[maxSamples*maxSCTXSize];
        // m_lPdfEmit      = new RtFloat[maxSamples*maxSCTXSize];
        // m_GtoL          = new RtFloat[maxSamples*maxSCTXSize];

        m_On            = new RtVector3[maxSamples*maxSCTXSize];

        for (int i = 0; i < k_RixBXMaxNumDiffuseLobes; i++)
        {
            m_ClDiffuse[i] = new RtColorRGB[maxSamples*maxSCTXSize];
            m_diffuse[i]   = new RtColorRGB[maxSamples*maxSCTXSize];
        }

        for (int i = 0; i < k_RixBXMaxNumSpecularLobes; i++)
        {
            m_ClSpecular[i] = new RtColorRGB[maxSamples*maxSCTXSize];
            m_specular[i]   = new RtColorRGB[maxSamples*maxSCTXSize];
        }

        for (int i = 0; i < k_RixBXMaxNumUserLobes; i++)
        {
            m_ClUser[i] = new RtColorRGB[maxSamples*maxSCTXSize];
            m_user[i]   = new RtColorRGB[maxSamples*maxSCTXSize];
        }

        m_FPdf          = new RtFloat[maxSamples*maxSCTXSize];
        m_RPdf          = new RtFloat[maxSamples*maxSCTXSize];

        m_camLpeState   = m_rixLpe->AllocateStates(maxSCTXSize);

        m_geoAovColor = NULL;
        m_geoAovFloat = NULL;
        if (m_geoAovIds)
        {
            m_geoAovColor = new RtFloat3[maxSCTXSize];
            if (PxrGeoAOV::NeedTempFloat(m_geoAovIds))
                m_geoAovFloat = new RtFloat[maxSCTXSize];
        }
    }

    ~DirectLightingWorker()
    {
        delete[] m_sctxs;
        delete[] m_rngSamps;
        delete[] m_volRays;
        delete[] m_emitLight;
        delete[] m_emitLocal;
        delete[] m_lobesWanted;
        delete[] m_lobesEvaluated;
        delete[] m_lobeSampled;
        delete[] m_PtoL;
        delete[] m_dist;
        delete[] m_lightTrans;
        delete[] m_Cl;
        delete[] m_lightGroupIds;
        delete[] m_lightLpeTokens;
        // delete[] m_lPdfP;
        delete[] m_lPdfIllum;
        // delete[] m_lPdfEmit;
        // delete[] m_GtoL;

        delete[] m_On;

        for (int i = 0; i < k_RixBXMaxNumDiffuseLobes; i++)
        {
            delete[] m_ClDiffuse[i];
            delete[] m_diffuse[i];
        }

        for (int i = 0; i < k_RixBXMaxNumSpecularLobes; i++)
        {
            delete[] m_ClSpecular[i];
            delete[] m_specular[i];
        }

        for (int i = 0; i < k_RixBXMaxNumUserLobes; i++)
        {
            delete[] m_ClUser[i];
            delete[] m_user[i];
        }

        delete[] m_FPdf;
        delete[] m_RPdf;

        m_rixLpe->FreeStates(m_maxShadingCtxSize, m_camLpeState);

        delete[] m_geoAovColor;
        delete[] m_geoAovFloat;
    }
    

    void Integrate(RtInt ngrps, RixShadingContext const *sgrps[],
                  RixIntegratorContext &ictx);

  private:
    void emitLocalContext(RixIntegratorContext &iCtx,
                          RixShadingContext const &sCtx);

    void directLightContext(RixIntegratorContext &iCtx,
                            RixShadingContext const &sCtx);
    
    // get a nice contiguous group of rng for calling generate
    // scale numSamples and sampleid by correct number of samples.  
    void initRNG(RixIntegratorContext &iCtx, 
                 RixShadingContext const &sCtx, bool isLight) 
    {
        // For camera hits, create a new random number domain using the
        // camera ray rng contexts that are stored on the integrator 
        // context. Note that we use the 1- and 2-argument version of 
        // NewDomain() here since this is direct lighting only. (For
        // secondary/indirect hit points, see PxrPathTracer as an example
        // of using NewDomain() at non-primary hit points.)
        
        if (isLight) {
            for(int i = 0; i < sCtx.numPts; i++)  {
                RtInt iCtxIndex = sCtx.integratorCtxIndex[i];
                m_rngSamps[i] = iCtx.rngCtx->NewDomain(iCtxIndex, 0x2d96c92b); // no splitting
            }
        } else {
            for(int i = 0; i < sCtx.numPts; i++)  {
                RtInt iCtxIndex = sCtx.integratorCtxIndex[i];
                m_rngSamps[i] = iCtx.rngCtx->NewDomain(iCtxIndex, 0x5eb182cb, 
                                                       m_numBxdfSamples); // splitting
            }
        }
    }

    void incRNG(RixShadingContext const &sCtx)
    {
        // bump the sample in the rng
        for(int i = 0; i < sCtx.numPts; i++)  {
            m_rngSamps[i].sampleid++;
        }
    }

    void computeClamp(int depth, 
                      RtColorRGB const &lgtTrans, 
                      RixBXActiveLobeWeights &activeLobes, 
                      int weightIndex, 
                      bool &isFinite, RtFloat &clampAmt)
    {
        clampAmt = 1.0f;
        
        RtColorRGB sum = activeLobes.SumAtIndex(weightIndex);
        isFinite = (RixIsFinite(sum.r) && RixIsFinite(sum.g) && RixIsFinite(sum.b));
    }

    RtFloat mis(RtFloat nG, RtFloat pdfG, RtFloat nE, RtFloat pdfE)
    {
        if (m_numLightSamples != 0 && m_numBxdfSamples != 0)
            return (nG*pdfG)*(nG*pdfG) / 
                    ((nG*pdfG)*(nG*pdfG) + (nE*pdfE)*(nE*pdfE));
        return 1.0f;
    }

    // per shading point
    RixShadingContext const **m_sctxs;    
    RixRNG::Generator const *m_rngImpl;
    RixRNG::SampleCtx *m_rngSamps;
    RtRayGeometry *m_volRays;    

    // per sample
    RtColorRGB *m_emitLight;
    RtColorRGB *m_emitLocal;
    RixBXLobeTraits  *m_lobesWanted;
    RixBXLobeTraits  *m_lobesEvaluated;
    RixBXLobeSampled *m_lobeSampled;
    RtVector3 *m_PtoL;
    RtFloat   *m_dist;
    RtColorRGB *m_lightTrans;
    RtColorRGB *m_Cl;
    RtColorRGB *m_ClDiffuse[k_RixBXMaxNumDiffuseLobes];
    RtColorRGB *m_ClSpecular[k_RixBXMaxNumSpecularLobes];
    RtColorRGB *m_ClUser[k_RixBXMaxNumUserLobes];
    RtColorRGB *m_diffuse[k_RixBXMaxNumDiffuseLobes];
    RtColorRGB *m_specular[k_RixBXMaxNumSpecularLobes];
    RtColorRGB *m_user[k_RixBXMaxNumUserLobes];
    RtInt *m_lightGroupIds;
    RixLPEToken *m_lightLpeTokens;
    RtFloat *m_lPdfIllum;

    RtVector3 *m_On;

    RtFloat *m_FPdf;
    RtFloat *m_RPdf;

    RixLPEState *m_camLpeState;

    RixDisplayServices *m_displaySvc;

    RtInt m_volContinues;
    RtFloat3 *m_geoAovColor;
    RtFloat  *m_geoAovFloat;

    // constructor parameters
    RixRefCntPtr<RixLPE> m_rixLpe;
    RixChannelId m_ciChan;
    const RtInt m_maxShadingCtxSize;
    const RtInt m_numLightSamples;
    const RtInt m_numBxdfSamples;
    RtInt *m_geoAovIds;
};

void
DirectLightingWorker::Integrate(RtInt nGroups, 
                                RixShadingContext const *shadeGrps[],
                                RixIntegratorContext &iCtx)
{
    m_rngImpl = iCtx.rngCtx->impl;
    for (int g = 0; g < nGroups; g++) 
    {
        RixShadingContext const &sCtx = *shadeGrps[g];

        // Setup the LPE state automata.
        if (m_rixLpe->AnyLPEs())
        {
            for (int i = 0; i < sCtx.numPts; i++)
                m_camLpeState[i].MoveCamera(&sCtx, i);
        }

        if(sCtx.HasHits())
        {
            emitLocalContext(iCtx, sCtx);
            directLightContext(iCtx, sCtx);
        }

        // Restore the LPE state automata.
        if (m_rixLpe->AnyLPEs())
        {
            for (int i = 0; i < sCtx.numPts; i++)
                m_camLpeState[i].Reset();
        }
    }

    if (m_geoAovIds)
    {
        PxrGeoAOV::Splat(nGroups, 
                         shadeGrps,
                         m_displaySvc, m_geoAovColor, 
                         m_geoAovFloat, m_geoAovIds);
    }
}

void
DirectLightingWorker::emitLocalContext(RixIntegratorContext &iCtx,
                                         RixShadingContext const &sCtx)
{
    RixBxdf &bxdf = *(sCtx.GetBxdf());
    int npoints = sCtx.numPts;
    bool isFinite;

    bool anyLocalEmission = bxdf.EmitLocal(m_emitLocal);

    if (sCtx.GetLightEmission(m_emitLight))
    {
        // if there was local emission, we add the light emission
        if (anyLocalEmission)
        {
            for (int i = 0; i < npoints; i++)
            {
                m_emitLocal[i] += m_emitLight[i];
            }
        }
        // else we copy light emission into local emission
        else
        {
            memcpy(m_emitLocal, m_emitLight, sizeof(RtColorRGB) * npoints);
            anyLocalEmission = true;
        }
    }

    if (anyLocalEmission)
    {
        RtInt matte = RixIsMatte(sCtx);
        for (int i = 0; i < npoints; i++)
        {
            int ctxIdx = sCtx.integratorCtxIndex[i];
            RtColorRGB eyeTrans = k_ZeroRGB;

            bool camVisMatte = (matte > 0);
            if (camVisMatte)
                eyeTrans = k_OneRGB; 

            RixLPE::SplatHelper aovs(m_displaySvc, ctxIdx, *m_rixLpe, 
                                     m_camLpeState[i],        // lpeState
                                     0,                       // depth
                                     -1,                      // lgtGrpId
                                     -1,                      // lpeGrpId
                                     true,                    // isReflect
                                     eyeTrans,                // eyeTrans
                                     k_OneRGB,                // lgtTrans
                                     &sCtx,                   // shadingCtx
                                     i);                      // shadingCtxIdx


            if (camVisMatte)
            {
                aovs.SplatValue(k_ZeroRGB, k_ZeroRGB, true);
                continue;
            }

            RtColorRGB val = m_emitLocal[i] * sCtx.transmission[i];
            isFinite = (RixIsFinite(val.r) && RixIsFinite(val.g) && RixIsFinite(val.b));
            aovs.SplatEmission(val, k_OneRGB, isFinite);
        }

    }
}


void
DirectLightingWorker::directLightContext(RixIntegratorContext &iCtx,
                                         RixShadingContext const &sCtx)
{
    RixBxdf &bxdf = *(sCtx.GetBxdf());
    RixBXEvaluateDomain evalDomain = bxdf.GetEvaluateDomain();
    int npoints = sCtx.numPts;
    bool isFinite;
    RtFloat clampAmt;
    RtInt matte = RixIsMatte(sCtx);

    if ((m_numLightSamples == 0 && m_numBxdfSamples == 0) ||
        evalDomain == k_RixBXEmptyDomain)
    {
        // If there are no light or surface samples, then write alpha and exit.
        for (int i = 0; i < npoints; i++)
        {
            int ctxIdx = sCtx.integratorCtxIndex[i];
            RtColorRGB eyeTrans = k_ZeroRGB;

            bool camVisMatte = (matte > 0);
            if (camVisMatte)
                eyeTrans = k_OneRGB; 

            RixLPE::SplatHelper aovs(m_displaySvc, ctxIdx, *m_rixLpe, 
                                     m_camLpeState[i],        // lpeState
                                     0,                       // depth
                                     -1,                      // lgtGrpId
                                     -1,                      // lpeGrpId
                                     true,                    // isReflect
                                     eyeTrans,                // eyeTrans
                                     k_OneRGB,                // lgtTrans
                                     &sCtx,                   // shadingCtx
                                     i);                      // shadingCtxIdx

            aovs.SplatValue(k_ZeroRGB, k_ZeroRGB, true);
        }
        return;
    }
   
    // setup RNG for n GenerateSamples calls 
    initRNG(iCtx, sCtx, true);
    RixRNG rng(iCtx.rngCtx, m_rngSamps, npoints);

    for (int i = 0; i < npoints; i++)
        m_lobesWanted[i].SetAll();

    RixLightingServices *lightingSvc = iCtx.GetLightingServices();

    lightingSvc->Begin(&sCtx, &rng, evalDomain,
                       RixLightingServices::k_MaterialAndLightSamples,
                       RixLightingServices::k_IgnoreFixedSampleCount,
                       RixLightingServices::SampleMode()//defaults
                       );

    // XXX: LobeTraits can tells us about all-discrete
    // and then we'd need only MaterialSamples

    RixBXLobeWeights genContributions(m_numLightSamples * npoints, 
                                      k_RixBXMaxNumDiffuseLobes, 
                                      k_RixBXMaxNumSpecularLobes,
                                      k_RixBXMaxNumUserLobes,
                                      m_ClDiffuse, 
                                      m_ClSpecular,
                                      m_ClUser);

    RixBXLobeWeights elw(m_numLightSamples * npoints, 
                         k_RixBXMaxNumDiffuseLobes, 
                         k_RixBXMaxNumSpecularLobes,
                         k_RixBXMaxNumUserLobes,
                         m_diffuse,
                         m_specular,
                         m_user);

    lightingSvc->GenerateSamples(m_numLightSamples,
                                 &rng,
                                 m_lightGroupIds,
                                 m_lightLpeTokens,
                                 m_PtoL,
                                 m_dist,
                                 &genContributions,
                                 m_lightTrans,
                                 m_lPdfIllum,
                                 m_lobesWanted,
                                 &elw,
                                 m_FPdf,
                                 m_RPdf,
                                 m_lobesEvaluated,
                                 NULL);

    RixBXActiveLobeWeights activeMtlLobes, activeLgtLobes;

    elw.GetActiveLobesIntersection(genContributions,
                                   activeMtlLobes,
                                   activeLgtLobes);

    RtFloat invLgtSamp = m_numLightSamples ? (1.0f / m_numLightSamples) : 1.0f;
    RtFloat invSrfSamp = m_numBxdfSamples  ? (1.0f / m_numBxdfSamples)  : 1.0f;
    for (int ls = 0; ls < m_numLightSamples; ls++) 
    {
        // process results
        for (int i = 0; i < npoints; i++) 
        {
            int offset = ls * npoints + i;
            bool camVisMatte = (matte > 0);
            RtColorRGB eyeTrans = k_ZeroRGB;
            if (camVisMatte)
                eyeTrans = k_OneRGB; 

            RtColorRGB lgtTrans = m_lightTrans[offset];

            int ctxIdx = sCtx.integratorCtxIndex[i];
            bool isReflect = m_lobesEvaluated[offset].GetReflect();
            RixLPE::SplatHelper aovs(m_displaySvc, ctxIdx, *m_rixLpe, 
                                     m_camLpeState[i],        // lpeState
                                     0,                       // depth
                                     m_lightLpeTokens[offset], // lgtLpeToken
                                     -1,                      // lpeGrpId
                                     isReflect,               // isReflect
                                     eyeTrans,                // eyeTrans
                                     lgtTrans,                // lgtTrans
                                     &sCtx,                   // shadingCtx
                                     i);                      // shadingCtxIdx
            
            if (!m_lobesEvaluated[offset].HasAny() ||
                camVisMatte || 
                m_FPdf[offset] == 0.0f ||
                m_lPdfIllum[offset] < 1e-12f) 
            {
                aovs.SplatValue(k_ZeroRGB, k_ZeroRGB, true);
                continue;
            }

            RtFloat    invPdf = 1.0f / m_lPdfIllum[offset]; // non-zero if here

            RtFloat    misW = mis(m_numLightSamples, m_lPdfIllum[offset],
                                  m_numBxdfSamples, m_FPdf[offset]);

            RtColorRGB wgt(sCtx.transmission[i] * misW * invLgtSamp * invPdf);

            RtColorRGB shadowWgt(sCtx.transmission[i].Luminance() * 
                                 misW * invLgtSamp);

            RtColorRGB userWgt(1.0f);

            // Attenuate the material response by the illumination and weight.
            for (int j = 0; j < activeMtlLobes.GetNumDiffuseLobes(); j++)
            {
                activeMtlLobes.GetDiffuseLobe(j)[offset] *= 
                    activeLgtLobes.GetDiffuseLobe(j)[offset] * wgt;
            }
            for (int j = 0; j < activeMtlLobes.GetNumSpecularLobes(); j++)
            {
                activeMtlLobes.GetSpecularLobe(j)[offset] *= 
                    activeLgtLobes.GetSpecularLobe(j)[offset] * wgt;
            }
            for (int j = 0; j < activeMtlLobes.GetNumUserLobes(); j++)
            {
                activeMtlLobes.GetUserLobe(j)[offset] *= userWgt;
            }

            // Determine the clamping amount.
            computeClamp(0, lgtTrans, activeMtlLobes, offset, 
                         isFinite, clampAmt);

            // Write to the display.
            aovs.SplatPerLobe(activeMtlLobes, offset, shadowWgt, k_OneRGB, 
                              isFinite, clampAmt);
        } 
        incRNG(sCtx);
    }
            
    // setup RNG for n GenerateBxdfSamples calls 
    initRNG(iCtx, sCtx, false);

    RixBXLobeWeights lw(m_numBxdfSamples * npoints, 
                        k_RixBXMaxNumDiffuseLobes,
                        k_RixBXMaxNumSpecularLobes,
                        k_RixBXMaxNumUserLobes,
                        m_diffuse,
                        m_specular,
                        m_user);

    for(int bs = 0; bs < m_numBxdfSamples; bs++) 
    {
        int offset = bs * npoints;

        // Changing the offset of the lobe weights will write into the lobe 
        // weights at the appropriate offset for this set of bxdf samples.
        lw.SetOffset(offset);

        bxdf.GenerateSample(k_RixBXDirectLighting,
                            m_lobesWanted, 
                            &rng,
                            m_lobeSampled + offset, 
                            m_On   + offset, 
                            lw, 
                            m_FPdf + offset, 
                            m_RPdf + offset);

        for(int i = 0; i < npoints; i++)
            m_dist[offset + i] = 1e20f;

        incRNG(sCtx);
    }

    // Reset the offset of the lobe weights back to zero for the code below.
    lw.SetOffset(0);

    RixBXLobeWeights evalContributions(m_numBxdfSamples * npoints, 
                                       k_RixBXMaxNumDiffuseLobes, 
                                       k_RixBXMaxNumSpecularLobes,
                                       k_RixBXMaxNumUserLobes,
                                       m_ClDiffuse, 
                                       m_ClSpecular,
                                       m_ClUser);

    // Setup RNG again for the evaluate samples calls 
    initRNG(iCtx, sCtx, false);

    // Uh Oh.  Note we are evaluating samples for bxdf values
    // that are invalid.
    lightingSvc->EvaluateSamples(m_numBxdfSamples,
                                 &rng,
                                 m_On,
                                 m_dist,
                                 m_FPdf,
                                 &lw,
                                 m_lobeSampled,
                                 // outputs
                                 m_lightGroupIds,
                                 m_lightLpeTokens,
                                 &evalContributions,
                                 m_lightTrans,
                                 m_lPdfIllum,
                                 NULL);

    lw.GetActiveLobesIntersection(evalContributions,
                                  activeMtlLobes, activeLgtLobes);
    
    for(int bs = 0; bs < m_numBxdfSamples; bs++) 
    {
        // process results
        for(int i = 0; i < npoints; i++) 
        {
            int offset = bs * npoints + i;
            bool camVisMatte = (matte > 0);
            RtColorRGB eyeTrans = k_ZeroRGB;
            if (camVisMatte)
                eyeTrans = k_OneRGB; 

            RtColorRGB lgtTrans = m_lightTrans[offset];

            int ctxIdx = sCtx.integratorCtxIndex[i];
            bool isReflect = m_lobeSampled[offset].GetReflect();

            RixLPE::SplatHelper aovs(m_displaySvc, ctxIdx, *m_rixLpe, 
                                     m_camLpeState[i],        // lpeState
                                     0,                       // depth
                                     m_lightLpeTokens[offset], // lgtLpeToken
                                     -1,                      // lpeGrpId
                                     isReflect,               // isReflect
                                     eyeTrans,                // eyeTrans
                                     lgtTrans,                // lgtTrans
                                     &sCtx,                   // shadingCtx
                                     i);                      // shadingCtxIdx
            
            if (!m_lobeSampled[offset].GetValid() || 
                camVisMatte ||
                m_lPdfIllum[offset] == 0.0f ||
                m_FPdf[offset] < 1e-12f) 
            {
                aovs.SplatValue(k_ZeroRGB, k_ZeroRGB, true);
                continue;
            }

            RtFloat    invPdf = 1.0f / m_FPdf[offset]; // non-zero if here

            RtFloat    misW = 0.0f;
            if (m_lobeSampled[offset].GetDiscrete())
                misW = 1.f;
            else
                misW = mis(m_numBxdfSamples, m_FPdf[offset], 
                           m_numLightSamples, m_lPdfIllum[offset]);

            RtColorRGB wgt(sCtx.transmission[i] * misW * invSrfSamp * invPdf);
            RtColorRGB shadowWeight(wgt.Luminance() * m_lPdfIllum[offset]);
            RtColorRGB userWgt(1.0f);

            // Attenuate the material response by the illumination and weight.
            for (int j = 0; j < activeMtlLobes.GetNumDiffuseLobes(); j++)
            {
                activeMtlLobes.GetDiffuseLobe(j)[offset] *= 
                    activeLgtLobes.GetDiffuseLobe(j)[offset] * wgt;
            }
            for (int j = 0; j < activeMtlLobes.GetNumSpecularLobes(); j++)
            {
                activeMtlLobes.GetSpecularLobe(j)[offset] *= 
                    activeLgtLobes.GetSpecularLobe(j)[offset] * wgt;
            }
            for (int j = 0; j < activeMtlLobes.GetNumUserLobes(); j++)
            {
                activeMtlLobes.GetUserLobe(j)[offset] *= userWgt;
            }

            // Determine the clamping amount.
            computeClamp(0, lgtTrans, activeMtlLobes, offset, 
                         isFinite, clampAmt);

            // Write to the display.
            aovs.SplatPerLobe(activeMtlLobes, offset, shadowWeight, k_OneRGB, 
                              isFinite, clampAmt);
        }
    }

    lightingSvc->End();
}

void
PxrDirectLighting::RenderEnd(RixContext &ctx)
{
    if (m_allWorkersMutex)
    {
        m_allWorkersMutex->Lock();

        for (int i = 0; i < m_allWorkers.size(); i++)
            delete m_allWorkers[i];

        m_allWorkers.clear();

        m_allWorkersMutex->Unlock();
    }
}

void
PxrDirectLighting::Integrate(RtInt ngrps, RixShadingContext const *sgrps[],
                             RixIntegratorContext &iCtx)
{
    RixStorage *storage = (RixStorage*) iCtx.GetRixInterface(k_RixThreadData);
    DirectLightingWorker *worker = ((DirectLightingWorker *)
                                    storage->Get("PxrDirectLightingWorker"));
    if (worker == NULL) {
        worker = new DirectLightingWorker(iCtx, iCtx.GetRixLPE(), 
                                          m_numLightSamples, m_numBxdfSamples, 
                                          m_maxShadingCtxSize, m_ciChan, 
                                          m_geoAovIds);
	storage->Set("PxrDirectLightingWorker", worker, NULL);

        if (m_allWorkersMutex)
        {
            m_allWorkersMutex->Lock();
            m_allWorkers.push_back(worker);
            m_allWorkersMutex->Unlock();
        }
    }

    worker->Integrate(ngrps, sgrps, iCtx);

}

RIX_INTEGRATORCREATE
{
    return new PxrDirectLighting();
}


RIX_INTEGRATORDESTROY
{
    delete ((PxrDirectLighting*)integrator);
}

