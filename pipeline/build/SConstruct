#!/usr/bin/python2
# =================================================================================
#    This file is part of pipeVFX.
#
#    pipeVFX is a software system initally authored back in 2006 and currently
#    developed by Roberto Hradec - https://bitbucket.org/robertohradec/pipevfx
#
#    pipeVFX is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Lesser General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    pipeVFX is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public License
#    along with pipeVFX.  If not, see <http://www.gnu.org/licenses/>.
# =================================================================================

import sys, os, traceback
sys.path.insert( 0, os.path.abspath('../tools/python/') )

gcc_version = ''.join(os.popen("gcc --version | head -1 | awk '{print $(NF)}' | awk -F'-' '{print $1}'").readlines())
os.environ['GCC_VERSION'] = 'gcc-%s' % gcc_version
# os.environ['GCC_VERSION'] = 'gcc-multi'

# build all pkgs, if not already built!
import build
print 'build.installRoot() = '+build.installRoot()
# pkgs will have all scons builds as its parameters
# ex: to use boost, just add pkgs.boost as a dependency
pkgs = build.pkgs.all(ARGUMENTS) # noqa

# get installed app versions using pipe
import pipe

# ===========================================================================================
# CORTEX VFX
# ===========================================================================================
boostMasterVersion = "1.61.0"
download = [[
    'https://github.com/ImageEngine/cortex/archive/9.18.0.tar.gz',
    'cortex-9.18.0.tar.gz',
    '9.18.0',
    'b3c55cc5e0e95668208713a01a145869',
    {pkgs.boost : "1.51.0", pkgs.alembic : "1.7.11",
     pkgs.hdf5 : [ x[4][pkgs.hdf5] for x in pkgs.alembic.download if x[2] == "1.7.11" ][0],
     pkgs.gcc : '4.1.2',
     pkgs.ocio: '1.0.9', pkgs.tbb: '4.4.6'}
],[
    'https://github.com/ImageEngine/cortex/archive/10.0.0-a68.tar.gz',
    'cortex-10.0.0-a68.tar.gz',
    '10.0.0.a68',
    'e506ed51b6e94f729925d5a6742c75c2',
    {pkgs.boost : boostMasterVersion, pkgs.gcc : '4.8.5',
     pkgs.alembic : "1.7.11",
     pkgs.hdf5 : [ x[4][pkgs.hdf5] for x in pkgs.alembic.download if x[2] == "1.7.11" ][0],
     pkgs.ocio: '1.0.9', pkgs.tbb: '4.4.6'}
]]

# cortex dependency
depend = [
    pkgs.icu, pkgs.tbb, pkgs.jpeg, pkgs.libraw,
    pkgs.freeglut, pkgs.freetype, pkgs.libpng, pkgs.hdf5,
    pkgs.tiff, pkgs.jpeg, pkgs.alembic, pkgs.openssl,
    pkgs.glew, pkgs.blosc, pkgs.usd, pkgs.opensubdiv,
    pkgs.ptex, pkgs.openvdb, pkgs.appleseed
]

# build cortex matrix
cortex = {}

# we use this to apply patches created when developing cortex
devPatch = []
patchFile = os.environ['HOME']+'/dev/cortex.git/patch'
if os.path.exists( patchFile ):
    devPatch = [ ''.join(open(patchFile).readlines()) ]


# build one version of IECore, IECorePython and IECoreGL libraries for each boost version
for boost_version in pkgs.boost.versions:
    core_sufix = "boost.%s" % boost_version
    _download = []
    extraInstall = ""
    # build versions that match boost 1.51 and the masterVersion of boost.
    if build.versionMajor(boost_version) < 1.55:
        # _download = [ x for x in download if x[4][pkgs.boost]==boost_version ]
        _download = [ []+x for x in download if build.versionMajor(x[2]) < 10.0 ]

    # build all versions newer than 10.0 with boost 1.55 and up.
    elif build.versionMajor(boost_version) >= 1.55:
        # this forces to build only versions 10.0 and up!
        # so versions below 10.0 will only build for boost versions below 1.
        _download = [ []+x for x in download if build.versionMajor(x[2]) >= 10.0 ]
        if _download:
            # if we have cortex >= 10 to build, add some installs!
            extraInstall += " installImage installScene "
            # skip boost versions that don't build with cortex 10 at the moment
            if boost_version in ['1.66.0']:
                continue

    # set the boost version of all downloads.
    for n in range(len(_download)):
        _download[n][4] = _download[n][4].copy()
        _download[n][4][ pkgs.boost     ] = boost_version
        _download[n][4][ pkgs.ilmbase   ['boost.%s' % boost_version] ] = '2.0.0'
        _download[n][4][ pkgs.pyilmbase ['boost.%s' % boost_version] ] = '2.0.0'
        _download[n][4][ pkgs.openexr   ['boost.%s' % boost_version] ] = '2.0.0'
        # we use different OIIO versions for cortex 9 and 10
        if build.versionMajor(_download[n][2]) < 10.0:
            _download[n][4][ pkgs.oiio ['boost.%s' % boost_version] ] = '1.6.15'
        else:
            _download[n][4][ pkgs.oiio ['boost.%s' % boost_version] ] = '1.8.10'


    if _download:
        # ===========================================================================================
        # CORTEX CORE for each boost
        # ===========================================================================================
        cortex[core_sufix] = build.cortex(
            ARGUMENTS, # noqa
            'cortex',
            targetSuffix = core_sufix,
            # build the version that matches the boost version in the loop!
            download = _download,
            # baseLibs = [pkgs.python],
            sed = build.cortex.onlyIECoreSED(),
            depend = depend+[pkgs.python],
            patch = devPatch,
            dontUseTargetSuffixForFolders = 1,
            # environ = { 'LD' : 'ld' },
            cmd = [
                build.cortex.cmd[0]+"installLib",
                build.cortex.cmd[0]+"installCore",
                build.cortex.cmd[0]+extraInstall+"installGL installStubs",
            ],
            environ = {
                'LDFLAGS': '$LDFLAGS ' + pkgs.exr_rpath_environ['LDFLAGS'],
            },
        )

        # ===========================================================================================
        # CORTEX ALEMBIC for each boost
        # ===========================================================================================
        for alembic_version in pkgs.alembic.versions:
            # build the alembic cortex only for the boost version used to build the current alembic version.
            alembic_boost = [ x[4][pkgs.boost] for x in pkgs.alembic.download if x[2] == alembic_version ][0]
            if alembic_boost and alembic_boost == boost_version:
                sufix = "boost.%s.alembic.%s" % (boost_version, alembic_version)

                # cortex 9 is only compatible with alembic below 1.6
                # __download = []+_download
                # if build.versionMajor(alembic_version) > 1.5:
                __download = [ []+x for x in _download if build.versionMajor(x[2]) >= 10.0 ]

                # now set the alembic version for all cortex versions
                for n in range(len(__download)):
                    alembic_dependencies = [ x[4] for x in pkgs.alembic.download if x[2] == alembic_version ][0]
                    __download[n][4] = __download[n][4].copy()
                    __download[n][4][ pkgs.boost     ] = boost_version
                    __download[n][4][ pkgs.alembic   ] = alembic_version
                    __download[n][4][ pkgs.hdf5      ] = alembic_dependencies[pkgs.hdf5]
                    __download[n][4][ cortex         ['boost.%s' % boost_version] ] = __download[n][2]
                    __download[n][4][ pkgs.ilmbase   ['boost.%s' % boost_version] ] = '2.0.0'
                    __download[n][4][ pkgs.pyilmbase ['boost.%s' % boost_version] ] = '2.0.0'
                    __download[n][4][ pkgs.openexr   ['boost.%s' % boost_version] ] = '2.0.0'
                    __download[n][4][ pkgs.oiio      ['boost.%s' % boost_version] ] = '1.8.10'

                # and build cortex
                cortex[sufix] = build.cortex(
                    ARGUMENTS, # noqa
                    'cortex',
                    targetSuffix = sufix,
                    download = __download,
                    sed = build.cortex.onlyIECoreExtraSED(),
                    # baseLibs = [pkgs.python],
                    depend = depend+[pkgs.python],
                    patch = devPatch,
                    dontUseTargetSuffixForFolders = 1,
                    cmd = [build.cortex.cmd[0]+"installAlembic"],
                    environ = {
                        'LDFLAGS': '$LDFLAGS ' + pkgs.exr_rpath_environ['LDFLAGS'],
                    },
                    # environ = { 'LD' : 'ld' },
                )

        # ===========================================================================================
        # CORTEX USD for each boost
        # ===========================================================================================
        for usd_version in pkgs.usd.versions:
            # build the usd cortex only for the boost version used to build the current usd version.
            usd_boost = [ x[4][pkgs.boost] for x in pkgs.usd.download if x[2] == usd_version ][0]
            if usd_boost and usd_boost == boost_version:

                sufix = "boost.%s.usd.%s" % (boost_version, usd_version)
                # since USD was introduced in cortex 10, only build for version >= 10
                __download = [ []+x for x in _download if build.versionMajor(x[2]) >= 10.0 ]

                # set the version of usd for all versions of cortex >= 10
                for n in range(len(__download)):
                    __download[n][4] = __download[n][4].copy()
                    __download[n][4][ pkgs.boost     ] = boost_version
                    __download[n][4][ pkgs.usd       ] = usd_version
                    __download[n][4][ cortex         ['boost.%s' % boost_version] ] = __download[n][2]
                    __download[n][4][ pkgs.ilmbase   ['boost.%s' % boost_version] ] = '2.0.0'
                    __download[n][4][ pkgs.pyilmbase ['boost.%s' % boost_version] ] = '2.0.0'
                    __download[n][4][ pkgs.openexr   ['boost.%s' % boost_version] ] = '2.0.0'
                    __download[n][4][ pkgs.oiio      ['boost.%s' % boost_version] ] = '1.8.10'

                # now build the version of cortex with the usd version
                cortex[sufix] = build.cortex(
                    ARGUMENTS, # noqa
                    'cortex',
                    targetSuffix = sufix,
                    download = __download,
                    sed = build.cortex.onlyIECoreExtraSED(),
                    # baseLibs = [pkgs.python],
                    depend = depend+[pkgs.python],
                    patch = devPatch,
                    dontUseTargetSuffixForFolders = 1,
                    cmd = [build.cortex.cmd[0]+"installUSD"],
                    environ = {
                        'LDFLAGS': '$LDFLAGS ' + pkgs.exr_rpath_environ['LDFLAGS'],
                    },
                    # environ = { 'LD' : 'ld' },
                )

        # ===========================================================================================
        # CORTEX OPENVDB for each boost
        # ===========================================================================================
        for openvdb_version in pkgs.openvdb.versions:
            # build the openvdb cortex only for the boost version used to build the current openvdb version.
            openvdb_boost = [ x[4][pkgs.boost] for x in pkgs.openvdb.download if x[2] == openvdb_version ][0]
            if openvdb_boost and openvdb_boost == boost_version:

                sufix = "boost.%s.openvdb.%s" % (boost_version, openvdb_version)

                # since openvdb was introduced in cortex 10, only build for version >= 10
                __download = [ []+x for x in _download if build.versionMajor(x[2]) >= 10.0 ]

                # set the version of openvdb for all versions of cortex.
                for n in range(len(__download)):
                    __download[n][4] = __download[n][4].copy()
                    __download[n][4][ pkgs.boost     ] = boost_version
                    __download[n][4][ pkgs.openvdb   ] = openvdb_version
                    __download[n][4][ cortex         ['boost.%s' % boost_version] ] = __download[n][2]
                    __download[n][4][ pkgs.ilmbase   ['boost.%s' % boost_version] ] = '2.0.0'
                    __download[n][4][ pkgs.pyilmbase ['boost.%s' % boost_version] ] = '2.0.0'
                    __download[n][4][ pkgs.openexr   ['boost.%s' % boost_version] ] = '2.0.0'
                    __download[n][4][ pkgs.oiio      ['boost.%s' % boost_version] ] = '1.8.10'

                # now build the version of cortex with the openvdb version
                cortex[sufix] = build.cortex(
                    ARGUMENTS, # noqa
                    'cortex',
                    targetSuffix = sufix,
                    download = __download,
                    sed = build.cortex.onlyIECoreExtraSED(),
                    # baseLibs = [pkgs.python],
                    depend = depend+[pkgs.python],
                    patch = devPatch,
                    dontUseTargetSuffixForFolders = 1,
                    cmd = [
                        build.cortex.cmd[0]+"installVDB",
                    ],
                    environ = {
                        'LDFLAGS': '$LDFLAGS ' + pkgs.exr_rpath_environ['LDFLAGS'],
                    },
                )

        # ===========================================================================================
        # CORTEX APPLESEED
        # ===========================================================================================
        # build the appleseed version for the current boost version, if any!
        appleseed_versions = [ x[2] for x in pkgs.appleseed.download if x[4][pkgs.boost] == boost_version ]
        for appleseed_version in appleseed_versions:
            # build the openvdb cortex only for the boost version used to build the current openvdb version.
            appleseed_boost = [ x[4][pkgs.boost] for x in pkgs.appleseed.download if x[2] == appleseed_version ][0]
            if appleseed_boost and appleseed_boost == boost_version:

                sufix = "boost.%s.appleseed.%s" % (boost_version, appleseed_version)

                # since openvdb was introduced in cortex 10, only build for version >= 10
                __download = [ []+x for x in download if build.versionMajor(x[2]) >= 10.0 ]

                # set the version of openvdb for all versions of cortex.
                for n in range(len(__download)):
                    __download[n][4] = __download[n][4].copy()
                    __download[n][4][ pkgs.boost     ] = boost_version
                    __download[n][4][ cortex         ['boost.%s' % boost_version] ] = __download[n][2]
                    __download[n][4][ pkgs.ilmbase   ['boost.%s' % boost_version] ] = '2.0.0'
                    __download[n][4][ pkgs.pyilmbase ['boost.%s' % boost_version] ] = '2.0.0'
                    __download[n][4][ pkgs.openexr   ['boost.%s' % boost_version] ] = '2.0.0'
                    __download[n][4][ pkgs.oiio      ['boost.%s' % boost_version] ] = '1.8.10'
                    __download[n][4][ pkgs.usd       ] = None
                    __download[n][4][ pkgs.alembic   ] = None
                    __download[n][4][ pkgs.openvdb   ] = None

                # now build the version of cortex with the openvdb version
                cortex[sufix] = build.cortex(
                    ARGUMENTS, # noqa
                    'cortex',
                    targetSuffix = sufix,
                    download = __download,
                    sed = build.cortex.onlyIECoreExtraSED(),
                    # baseLibs = [pkgs.python],
                    depend = depend+[pkgs.python],
                    patch = devPatch,
                    dontUseTargetSuffixForFolders = 1,
                    cmd = [
                        build.cortex.cmd[0]+"installAppleseed",
                    ],
                    environ = {
                        'LDFLAGS': '$LDFLAGS ' + pkgs.exr_rpath_environ['LDFLAGS'],
                    },
                )



# ===========================================================================================
# GAFFER
# ===========================================================================================
pkgs.gaffer = {}
def buildGaffer(apps=[], boost='1.61.0', __download__=None):
    suffix = ''
    version=0
    if apps:
        version = apps[0][1]
        suffix = "%s.%s" % (str(apps[0][0]).split("'")[1].split(".")[-1], version)

    # grab the latest version of cortex to build gaffer.
    _downloadCortex9 = [ []+x for x in download if build.versionMajor(x[2]) < 10.0 ]
    cortex9version = _downloadCortex9[-1][2]
    _downloadCortex10 = [ []+x for x in download if build.versionMajor(x[2]) >= 10.0 ]
    cortex10version = _downloadCortex10[-1][2]

    # use a cortex build without applessed.
    cortex_build = 'boost.%s' % boost

    # if building with a boost version that has a cortex built with appleseed, use it!
    # [ x[2] for x in pkgs.appleseed.download if x[4][pkgs.boost] == boost ]
    av = ['2.0.5.beta']
    if av:
        av = build.pkgs.versionSort( av )
        cortex_build = "boost.%s.appleseed.%s" % (boost, av[-1])

    suffix = ".".join([ x for x in [cortex_build, suffix] if x])

    gaffer_download = [[
    #     'https://github.com/GafferHQ/gaffer/archive/0.32.0.0.tar.gz',
    #     'gaffer-0.32.0.0.tar.gz',
    #     '0.32.0.0',
    #     '2ae5c942f79dff458abda6bfb4c081f2',
    #     {pkgs.alembic : "1.5.8", pkgs.ocio: '1.0.9',
    #     pkgs.pyside: None, pkgs.pyqt: '4.8.7',
    #     pkgs.gcc : '4.1.2', pkgs.tbb: '4.4.6',
    #     pkgs.boost : "1.51.0", pkgs.oiio: '1.6.15',
    #     pkgs.openexr['boost.1.51.0'] : '2.0.0',
    #     pkgs.ilmbase['boost.1.51.0'] : '2.0.0',
    #     pkgs.pyilmbase['boost.1.51.0'] : '2.0.0',
    #     cortex['boost.1.51.0'] : cortex9version}
    # ],[
        'https://github.com/GafferHQ/gaffer/archive/0.55.0.0.tar.gz',
        'gaffer-0.55.0.0.tar.gz',
        '0.55.0.0',
        '876127bfe6fd62ab9d6a8a9e6da2f75f',
        {pkgs.alembic : "1.7.11", pkgs.ocio: '1.0.9',
        pkgs.pyside: '2.0.18', pkgs.pyqt: None,
        pkgs.llvm: '7.1.0', pkgs.gcc : '4.8.5',
        pkgs.openvdb: '6.0.0', pkgs.tbb: '4.4.6',
        pkgs.boost : boost,
        pkgs.openexr['boost.%s' % boost] : '2.0.0',
        pkgs.ilmbase['boost.%s' % boost] : '2.0.0',
        pkgs.pyilmbase['boost.%s' % boost] : '2.0.0',
        pkgs.oiio['boost.%s' % boost]: '1.8.10',
        cortex[cortex_build] : cortex10version}
    ]]
    if __download__:
        gaffer_download=__download__

    return build.gaffer(
        ARGUMENTS, # noqa
        'gaffer',
        targetSuffix = suffix,
        sed=build.gaffer.sed,
        # baseLibs = [pkgs.python],
        download = gaffer_download,
        depend =  depend + [
            pkgs.qt, pkgs.qtpy, pkgs.osl, pkgs.qt,
            pkgs.oiio, pkgs.ocio, pkgs.llvm,
            pkgs.python, pkgs.usd,
        ],
        apps = apps,
        cmd = build.gaffer.cmd[0]+'install',
        dontUseTargetSuffixForFolders = 1,
        dontAddLLVMtoEnviron = 1,
        environ = {
            'CXXFLAGS' : ' '.join([
                '-isystem $GCC_TARGET_FOLDER/lib/gcc/x86_64-pc-linux-gnu/$GCC_VERSION/include/',
                '-isystem $GCC_TARGET_FOLDER/lib/gcc/x86_64-pc-linux-gnu/$GCC_VERSION/include-fixed/',
                '-isystem $GCC_TARGET_FOLDER/lib/gcc/x86_64-pc-linux-gnu/$GCC_VERSION/include/c++/',
                '-isystem $GCC_TARGET_FOLDER/lib/gcc/x86_64-pc-linux-gnu/$GCC_VERSION/include/c++/x86_64-pc-linux-gnu/',
                '-isystem $GCC_TARGET_FOLDER/lib/gcc/x86_64-pc-linux-gnu/$GCC_VERSION/include/c++/tr1/',
                '-isystem $GCC_TARGET_FOLDER/include/c++/$GCC_VERSION/',
                '-isystem $GCC_TARGET_FOLDER/include/c++/$GCC_VERSION/x86_64-pc-linux-gnu/',
                '-I$FREETYPE_TARGET_FOLDER/include/freetype2/',
                '-fno-strict-aliasing',
                '-D_GLIBCXX_USE_CXX11_ABI=0',
                '$CXXFLAGS',
            ]),
            # we need this for pre-compiled appleseed (binary tarball),
            # since centos 7 libc is too old
            'LD_PRELOAD': ':'.join([
                '/lib64/libexpat.so.1',
            ]),
            'LDFLAGS': '$LDFLAGS ' + pkgs.exr_rpath_environ['LDFLAGS'],
            'DCORES' : '1',
            # 'LD' : 'ld'
        },
    )
# build gaffer without any app support first!
gaffer = buildGaffer()
pkgs.gaffer[ gaffer.targetSuffix ] = gaffer







# ===========================================================================================
# FROM HERE, WE DEAL WITH THIRDY-PARTIE APPS
# ===========================================================================================
# we need libraries built to detect installed apps, so if we don't have then yet,
# we cant build app dependent packages.
canBuildCortexNow = False
try:
    pipe.apps.maya()
    canBuildCortexNow = True
except:
    print '''

    It seems we don't have libraries built yet, so we can't build app dependent pkgs yet! (ex: cortex,alembic, usd, openvdb, etc)
    Run scons install again after this build finishes to complete the build!

    '''
    traceback.print_exc()

# ok, so we do have the libraries built, so now lets do app dependent packages!!
if canBuildCortexNow:
    nuke    = pipe.apps.nuke()
    maya    = pipe.apps.maya()
    prman   = pipe.apps.prman()
    houdini = pipe.apps.houdini()

    # grab version lists
    mv = [ x for x in build.pkgs.versionSort( maya.versionList()  ) if float(x.split('.')[0])>2016 ]
    pv = [ x for x in build.pkgs.versionSort( prman.versionList() ) if float(x.split('.')[0])>=21 ]
    nv = [ x for x in build.pkgs.versionSort( nuke.versionList()  ) if float(x.split('.')[0])>=9 ]
    hv = build.pkgs.versionSort( houdini.versionList() )[-2:]

    # disable arnold!
    #pipe.version.set(arnold='0.0.0')

    # ===========================================================================================
    # MAYA
    # ===========================================================================================
    pkgs.maya_sip = {}
    pkgs.maya_pyqt = {}
    pkgs.maya_usd = {}
    pkgs.maya_alembic = {}
    pkgs.maya_openvdb = {}
    for n in range(len(mv)):
        version = 0
        if mv:
            version = mv[0] if len(mv)<=n else mv[n]
            pipe.version.set( maya  = version )

        targetSuffix = "maya.%s" % str(version)

        # ===========================================================================================
        # build sip/pyqt for maya version!
        # for maya 2018 we're building pyside using autodesk qt 5.6.1
        # so we don't need maya to build it!
        # ===========================================================================================
        if float(version) > 2016 and float(version) < 2018:
            pkgs.maya_sip.update({ targetSuffix : build.pythonSetup(
                ARGUMENTS,
                'sip',
                targetSuffix = targetSuffix,
                download=[(
                    'https://sourceforge.net/projects/pyqt/files/sip/sip-4.16.7/sip-4.16.7.tar.gz',
                    'sip-4.16.7.tar.gz',
                    '4.16.7',
                    '32abc003980599d33ffd789734de4c36',
                    { pkgs.gcc : '4.1.2' }
                )],
                src = 'configure.py',
                apps = [ (pipe.apps.maya, version) ],
                cmd = [
                    # 'export MAYA_LOCATION=$(/bin/python2 -c "import pipe;print pipe.roots.apps()")/maya/%s' % version,
                    'mayapy configure.py '
                    '-b $TARGET_FOLDER/bin '
                    '-d $TARGET_FOLDER/lib/python$PYTHON_VERSION_MAJOR/site-packages/ '
                    '-e $TARGET_FOLDER/include/python$PYTHON_VERSION_MAJOR/ '
                    '-v $TARGET_FOLDER/share/sip/ '
                    'CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" ',
                    'make -j $DCORES && make -j $DCORES install',
                ],
                environ = {
                    'MAYA_EXECUTABLE' : pipe.apps.maya().path('bin/maya.bin'),
                    'MAYA_LOCATION' : pipe.apps.maya().path(),
                    'MAYA_ROOT' : pipe.apps.maya().path(),
                    'PATH' : '%s:$PATH' % pipe.apps.maya().path('bin'),
                },
            )})
            pkgs.maya_pyqt.update({ targetSuffix : build.pythonSetup(
                ARGUMENTS,
                'pyqt',
                targetSuffix = targetSuffix,
                download=[(
                    'https://svwh.dl.sourceforge.net/project/pyqt/PyQt4/PyQt-4.11.4/PyQt-x11-gpl-4.11.4.tar.gz',
                    'PyQt-x11-gpl-4.11.4.tar.gz',
                    '4.11.4',
                    '2fe8265b2ae2fc593241c2c84d09d481',
                    {pkgs.maya_sip[targetSuffix]: '4.16.7.maya%s' % version, pkgs.gcc : '4.1.2'},
                )],
                # baseLibs=[pkgs.python],
                apps = [ (pipe.apps.maya, version) ],
                src = 'configure-ng.py',
                cmd = [
                    # 'python configure-ng.py --confirm-license --assume-shared --protected-is-public --designer-plugindir=$QT_TARGET_FOLDER/plugins/designer/ --sysroot=$TARGET_FOLDER CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS"',
                    '''export PYTHON_VERSION_MAJOR=$(mayapy --version 2>&1 | awk '{split($2,a,"."); print a[1] "." a[2] }')'''
                    'export QTDIR=$MAYA_LOCATION',
                    'export QMAKESPEC=$MAYA_LOCATION/mkspecs/linux-g++-64',
                    'export INCDIR_QT=$MAYA_LOCATION/include',
                    'export LIBDIR_QT=$MAYA_LOCATION/lib',
                    'export PATH=$MAYA_LOCATION/bin:$PATH',
                    'mayapy configure.py --confirm-license --assume-shared --verbose --no-designer-plugin '
                    '-b $TARGET_FOLDER/bin '
                    '-d $TARGET_FOLDER/lib/python$PYTHON_VERSION_MAJOR/site-packages/ '
                    '-v $TARGET_FOLDER/share/sip/PyQt4 '
                    'CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" '
                    'LIBDIR_QT=$MAYA_LOCATION/lib INCDIR_QT=$MAYA_LOCATION/include MOC=$MAYA_LOCATION/bin/moc -w -g ',
                    'make -j $DCORES CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" ',
                    'make -j $DCORES CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" install',
                ],
                environ = {
                    'MAYA_EXECUTABLE' : pipe.apps.maya().path('bin/maya.bin'),
                    'MAYA_LOCATION' : pipe.apps.maya().path(),
                    'MAYA_ROOT' : pipe.apps.maya().path(),
                    'PATH' : '%s:$PATH' % pipe.apps.maya().path('bin'),
                },
            )})

        # build plugins
        if version:
            # ===========================================================================================
            # MAYA USD
            # ===========================================================================================
            maya_environ = pkgs.usd.environ.copy()
            maya_environ.update({
                'MAYA_EXECUTABLE' : pipe.apps.maya().path('bin/maya.bin'),
                'MAYA_LOCATION' : pipe.apps.maya().path(),
                'MAYA_ROOT' : pipe.apps.maya().path(),
                'LDFLAGS': '$LDFLAGS ' + pkgs.exr_rpath_environ['LDFLAGS'],
            })
            pkgs.maya_usd.update({ targetSuffix : build.cmake(
                ARGUMENTS,
                'usd',
                sed = pkgs.usd.sed,
                targetSuffix = targetSuffix,
                download = pkgs.usd.download,
                depend = pkgs.usd.depend+[pkgs.usd],
                cmd = pkgs.usd.cmd,
                apps = [ (pipe.apps.maya, str(version)) ],
                environ = maya_environ,
                flags=pkgs.usd.flags+[
                    '-D PXR_BUILD_MAYA_PLUGIN=ON'
                    '-D PXR_BUILD_MATERIALX_PLUGIN=ON'
                ],
            )})
            # pkgs.maya_usd.update({ targetSuffix : build.cmake(
            #     ARGUMENTS,
            #     'usd_brides',
            #     targetSuffix = targetSuffix,
            #     download = [(
            #         'https://github.com/Autodesk/maya-usd/archive/v0.0.2.tar.gz',
            #         'maya-usd-0.0.2.tar.gz',
            #         '0.0.2',
            #         '547214e0213dd9bac705b09d7a341e5f',
            #         # use usd dependency versions to build this
            #         pkgs.usd.download[-1][4].copy(),
            #     )],
            #     depend = pkgs.usd.depend+[pkgs.usd],
            #     apps = [ (pipe.apps.maya, str(version)) ],
            #     environ = maya_environ,
            #     flags = [
            #         '-DBUILD_AL_PLUGIN=0',
            #         '-DBUILD_PXR_PLUGIN=1',
            #         '-DPXR_USD_LOCATION=$USD_TARGET_FOLDER',
            #     ]
            # )})



            # ===========================================================================================
            # MAYA ALEMBIC
            # ===========================================================================================
            for alembic_version in pkgs.alembic.versions:
                maya_environ = pkgs.alembic.environ.copy()
                maya_environ.update({
                    'CFLAGS'    : ' -std=c++11 $CFLAGS ',
                    'CXXFLAGS'  : ' -DALEMBIC_LIB_USES_BOOST=1 -std=c++11 $CXXFLAGS ',
                    'LDFLAGS'   : '$LDFLAGS ' + pkgs.exr_rpath_environ['LDFLAGS'],
                    # 'LDFLAGS'   : ' $LDFLAGS -lpthread'
                })
                # _download = []+[ x for x in pkgs.alembic.download if x[2] == alembic_version ]
                _download = pkgs.alembic.downloadVersion(alembic_version)
                for n in range(len(_download)):
                    _download[n][4] = _download[n][4].copy()
                    _download[n][4][pkgs.gcc] = '4.8.5'
                    if build.versionMajor(version)>=2018:
                        _download[n][4][pkgs.boost] = '1.61.0'

                pkgs.maya_alembic.update({ targetSuffix : build.alembic(
                    ARGUMENTS,
                    'alembic',
                    targetSuffix = targetSuffix,
                    sed = pkgs.alembic.sed,
                    baseLibs = pkgs.alembic.baseLibs,
                    download = _download,
                    depend = pkgs.alembic.depend + [pkgs.openssl],
                    cmd = pkgs.alembic.cmd,
                    apps = [ (pipe.apps.maya, str(version)) ],
                    environ = maya_environ,
                    flags = ['-DUSE_MAYA=1', '-DMAYA_ROOT=$MAYA_ROOT'],
                )})


            # ===========================================================================================
            # MAYA OPENVDB
            # ===========================================================================================
            # pkgs.maya_openvdb.update({ targetSuffix : build.make(
            #     ARGUMENTS,
            #     'openvdb',
            #     targetSuffix = "maya%s" % str(version),
            #     download = pkgs.openvdb.download,
            #     depend = pkgs.openvdb.depend,
            #     cmd = ['cd openvdb_maya']+pkgs.openvdb.cmd[1:],
            #     environ = {
            #         'MAYA_VERSION' : str(version),
            #         'MAYA_ROOT' : pipe.apps.maya().path(),
            #     },
            # )})

    # ===========================================================================================
    # PRMAN
    # ===========================================================================================
    # pkgs.prman_usd = {}
    # pkgs.prman_alembic = {}
    # for n in range(len(pv)):
    #     version = 0
    #     if pv:
    #         version = pv[0] if len(pv)<=n else pv[n]
    #         pipe.version.set( prman  = version )
    #
    #     if version:
    #         targetSuffix = "prman.%s" % str(version)
    #         pkgs.prman_usd[targetSuffix] = build.cmake(
    #             ARGUMENTS,
    #             'usd',
    #             sed = pkgs.usd.sed,
    #             targetSuffix = targetSuffix,
    #             download = pkgs.usd.download,
    #             depend = pkgs.usd.depend+[pkgs.usd],
    #             cmd = pkgs.usd.cmd,
    #             apps = [ (pipe.apps.prman, str(version)) ],
    #             environ = pkgs.usd.environ,
    #             flags=pkgs.usd.flags+[ '-D PXR_BUILD_PRMAN_PLUGIN=1' ],
    #         )
    #         # pkgs.prman_alembic += [build.alembic(
            #     ARGUMENTS,
            #     'alembic',
            #     targetSuffix = "prman%s" % str(version),
            #     baseLibs = pkgs.alembic.baseLibs,
            #     download = pkgs.alembic.download,
            #     depend = pkgs.alembic.depend,
            #     cmd = pkgs.alembic.cmd,
            #     apps = [ (pipe.apps.prman, str(version)) ],
            #     flags = ['-DUSE_PRMAN=1', '-DPRMAN_ROOT=$MAYA_ROOT'],
            # )]


    # ===========================================================================================
    # CORTEX MAYA
    # ===========================================================================================
    usd     = None #pkgs.usd.download[-1][2]
    alembic = None #pkgs.alembic.download[-1][2]
    openvdb = None #pkgs.openvdb.download[-1][2]
    for version in mv:
        sufix = "core.maya.%s" % version

        _download = []+download
        # maya less than 2018 uses cortex 9
        _download = [ []+x for x in download if build.versionMajor(x[2]) >= 10.0 ]
        if float(version) < 2018:
            _download = [ []+x for x in download if build.versionMajor(x[2]) < 10.0 ]

        # set the versions of depency to build cortex
        for n in range(len(_download)):
            # set the cortex build with the boost version of choice, using the same cortex version.
            cortexVersion   = _download[n][2]
            boostVersion    = _download[n][4][pkgs.boost]
            _download[n][4] = _download[n][4].copy()
            # as we mangle vdb, usd and alembic inside cortex (we don't use the
            # targetSuffix) we can only specify the main core cortex build here,
            # and cortex_options.pywill take care of setting the libs paths for
            # everything according with the specified boost version.
            # we specify "boost.<boost version" so this build has a dependency
            # with cortex core boost version.
            _download[n][4][ pkgs.boost    ] = boostVersion
            _download[n][4][ cortex        ["boost.%s" % boostVersion] ] = cortexVersion
            _download[n][4][ pkgs.ilmbase  ['boost.%s' % boostVersion] ] = '2.0.0'
            _download[n][4][ pkgs.openexr  ['boost.%s' % boostVersion] ] = '2.0.0'
            _download[n][4][ pkgs.pyilmbase['boost.%s' % boostVersion] ] = '2.0.0'
            _download[n][4][ pkgs.gcc      ] = '4.8.5'
            _download[n][4][ pkgs.usd      ] = usd
            _download[n][4][ pkgs.alembic  ] = alembic
            _download[n][4][ pkgs.openvdb  ] = openvdb
            # we use different OIIO versions for cortex 9 and 10
            if build.versionMajor(_download[n][2]) < 10.0:
                _download[n][4][ pkgs.oiio['boost.%s' % boostVersion]] = '1.6.15'
            else:
                _download[n][4][ pkgs.oiio['boost.%s' % boostVersion]] = '1.8.10'


        # now build the version of cortex with the openvdb version
        cortex[sufix] = build.cortex(
            ARGUMENTS, # noqa
            'cortex',
            targetSuffix = sufix,
            download = _download,
            sed = build.cortex.noIECoreSED(),
            # baseLibs = [pkgs.python],
            depend = depend+[pkgs.python],
            patch = devPatch,
            dontUseTargetSuffixForFolders = 1,
            apps = [ (pipe.apps.maya, str(version)) ],
            cmd = [
                build.cortex.cmd[0]+"install installMaya",
            ],
            environ = {
                'LDFLAGS': '$LDFLAGS ' + pkgs.exr_rpath_environ['LDFLAGS'],
            },
        )

    # ===========================================================================================
    # CORTEX PRMAN
    # ===========================================================================================
    for version in pv:
        sufix = "core.prman.%s" % version

        # prman 22 needs cortex 10, and prman 21 or less, cortex 9
        _download = [ []+x for x in download if build.versionMajor(x[2]) >= 10.0 ]
        if float(version) < 22:
            _download = [ []+x for x in download if build.versionMajor(x[2]) < 10.0 ]

        # set the versions of depency to build cortex for prman
        for n in range(len(_download)):
            # set the cortex build with the boost version of choice, using the same cortex version.
            cortexVersion   = _download[n][2]
            boostVersion    = _download[n][4][pkgs.boost]
            _download[n][4] = _download[n][4].copy()
            # as we mangle vdb, usd and alembic inside cortex (we don't use the
            # targetSuffix) we can only specify the main core cortex build here,
            # and cortex_options.pywill take care of setting the libs paths for
            # everything according with the specified boost version.
            # we specify "boost.<boost version" so this build has a dependency
            # with cortex core boost version.
            _download[n][4][ pkgs.boost    ] = boostVersion
            _download[n][4][ cortex        ["boost.%s" % boostVersion] ] = cortexVersion
            _download[n][4][ pkgs.ilmbase  ['boost.%s' % boostVersion] ] = '2.0.0'
            _download[n][4][ pkgs.openexr  ['boost.%s' % boostVersion] ] = '2.0.0'
            _download[n][4][ pkgs.pyilmbase['boost.%s' % boostVersion] ] = '2.0.0'
            _download[n][4][ pkgs.gcc      ] = '4.8.5'
            _download[n][4][ pkgs.usd      ] = usd
            _download[n][4][ pkgs.alembic  ] = alembic
            _download[n][4][ pkgs.openvdb  ] = openvdb
            # we use different OIIO versions for cortex 9 and 10
            if build.versionMajor(_download[n][2]) < 10.0:
                _download[n][4][ pkgs.oiio['boost.%s' % boostVersion]] = '1.6.15'
            else:
                _download[n][4][ pkgs.oiio['boost.%s' % boostVersion]] = '1.8.10'

        # now build the version of cortex
        cortex[sufix] = build.cortex(
            ARGUMENTS, # noqa
            'cortex',
            targetSuffix = sufix,
            download = _download,
            sed = build.cortex.noIECoreSED(),
            # baseLibs = [pkgs.python],
            depend = depend+[pkgs.python],
            patch = devPatch,
            dontUseTargetSuffixForFolders = 1,
            apps = [( pipe.apps.prman, version )],
            cmd = [
                build.cortex.cmd[0]+"installRI",
            ],
            environ = {
                'LDFLAGS': '$LDFLAGS ' + pkgs.exr_rpath_environ['LDFLAGS'],
            },
        )

    # ===========================================================================================
    # GAFFER PRMAN
    # ===========================================================================================
    # now use prman versions to build gaffer against
    # for version in pv:
    #     if float(version) > 21.4:
    #         boost="1.61.0"
    #         download = None
    #         if float(version) >= 23.0:
    #             download = [[
    #                 'https://github.com/johnhaddon/gaffer/archive/renderMan.zip',
    #                 'gaffer-0.54.0.0.tar.gz',
    #                 '0.54.0.prman',
    #                 '876127bfe6fd62ab9d6a8a9e6da2f75f',
    #                 {pkgs.alembic : "1.7.11", pkgs.ocio: '1.0.9',
    #                 pkgs.pyside: '2.0.18', pkgs.pyqt: None,
    #                 pkgs.llvm: '7.1.0', pkgs.gcc : '4.8.5',
    #                 pkgs.openvdb: '6.0.0', pkgs.tbb: '4.4.6',
    #                 pkgs.boost : boost,
    #                 pkgs.openexr['boost.%s' % boost] : '2.0.0',
    #                 pkgs.ilmbase['boost.%s' % boost] : '2.0.0',
    #                 pkgs.pyilmbase['boost.%s' % boost] : '2.0.0',
    #                 pkgs.oiio['boost.%s' % boost]: '1.8.10',
    #                 cortex[cortex_build] : cortex10version}
    #             ]]
    #
    #         gaffer = buildGaffer( [(pipe.apps.prman, version)], boost, download )
    #         pkgs.gaffer[ gaffer.targetSuffix ] = gaffer





#
